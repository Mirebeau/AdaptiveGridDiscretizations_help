window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "agd", "modulename": "agd", "kind": "module", "doc": "<p>Adaptive Grid Discretizations (agd) package.</p>\n\n<p>This package is intented as a toolbox for discretizing and solving partial differential\nequations (PDEs), especially in the following contexts : </p>\n\n<ul>\n<li>A Cartesian grid is used for the domain discretization.</li>\n<li>The PDE embeds geometric information, possibly strongly anisotropic.</li>\n<li>One puts a strong emphasis on preserving the structure of the PDE \n(monotony, causality, degenerate ellipticity, ...) at the discrete level.</li>\n<li>Generic CPU/GPU programming.</li>\n</ul>\n\n<p>This package comes with an extensive suite of notebooks, which serve simultaneously the\npurposes of documentation, mathematical description, and testing. Please see \n<a href=\"https://github.com/Mirebeau/AdaptiveGridDiscretizations\">https://github.com/Mirebeau/AdaptiveGridDiscretizations</a></p>\n\n<p>The AGD package is architectured around the following main components:</p>\n\n<ul>\n<li>AutomaticDifferentiation : automatically compute gradients, hessians, jacobians, in \ndense or sparse format, using operator and function overloading.</li>\n</ul>\n\n<ul>\n<li><p>Eikonal : a ready to use solver of (generalized, anisotropic) eikonal equations. Those\nare partial differential equations which characterize minimal distances w.r.t. Riemannian\nor other classes of metrics.</p></li>\n<li><p>Metrics : helper classes for classical and less classical objects \n(Riemannian metrics, Hooke elasticity tensors, etc) used to encode geometric information.</p></li>\n<li><p>FiniteDifferences, Domain, Interpolation : helper classes for handling function values\nstored in arrays and designing numerical schemes.</p></li>\n<li><p>LinearParallel : basic linear algebra operations, following an axes ordering convention\nsomewhat opposite to numpy's (geometry first).</p></li>\n<li><p>Selling : a decomposition method for symmetric positive definite matrices, which is a \ncentral tool in our designs of anisotropic PDE discretizations.</p></li>\n</ul>\n\n<h1 id=\"adaptive-grid-discretizations-using-lattice-basis-reduction-agd-lbr\">Adaptive Grid Discretizations using Lattice Basis Reduction (AGD-LBR)</h1>\n\n<h2 id=\"a-set-of-tools-for-discretizing-anisotropic-pdes-on-cartesian-grids\">A set of tools for discretizing anisotropic PDEs on cartesian grids</h2>\n\n<p>This repository contains</p>\n\n<ul>\n<li>the agd library (Adaptive Grid Discretizations), written in Python&reg; and cuda&reg;</li>\n<li>a series of <em>jupyter notebooks</em> in the Python&reg; language (online <a href=\"http://nbviewer.jupyter.org/urls/rawgithub.com/Mirebeau/AdaptiveGridDiscretizations_showcase/master/Summary.ipynb\">static</a> and <a href=\"https://colab.research.google.com/notebook#fileId=1exIN-55tUG1LFlgoHM582k8o8zy6H46f&offline=true&sandboxMode=true\">interactive</a> view), reproducing my research in Anisotropic PDE discretizations and their applications.</li>\n<li>a <a href=\"https://mirebeau.github.io/AdaptiveGridDiscretizations_help/docs/agd.html\">basic documentation</a>,\ngenerated with <a href=\"https://pdoc.dev/\">pdoc</a>.</li>\n</ul>\n\n<h3 id=\"the-agd-library\">The AGD library</h3>\n\n<p>The recommended ways to install are</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"go\">pip install agd</span>\n</code></pre>\n</div>\n\n<p>or alternatively (but this option does not include the GPU eikonal solver)</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"go\">conda install agd -c agd-lbr</span>\n</code></pre>\n</div>\n\n<h3 id=\"reboot-of-the-git-history-february-8th-2024\">Reboot of the git history (february 8th 2024)</h3>\n\n<p>The whole notebooks, including images and videos, were previously saved in the git history, which as a result had grown to approx 750MB. After some unsuccessful attempts with BFG, I eventually had to delete and recreate the repository.</p>\n\n<h3 id=\"the-notebooks\">The notebooks</h3>\n\n<p>You may :  </p>\n\n<ul>\n<li><a href=\"http://nbviewer.jupyter.org/urls/rawgithub.com/Mirebeau/AdaptiveGridDiscretizations_showcase/master/Summary.ipynb\">Visualize the notebooks online using nbviewer</a>.\n<em>Note</em> : prefer to use this link to view the notebooks, rather than the present repository, which contains some notebooks in a partially evaluated state.</li>\n<li><a href=\"https://colab.research.google.com/notebook#fileId=1exIN-55tUG1LFlgoHM582k8o8zy6H46f&offline=true&sandboxMode=true\">Run and modify the notebooks online using GoogleColab</a>.\n<em>Note</em> : some notebooks require turning on the GPU acceleration in GoogleColab (typical error: cannot import cupy) : Modify->Notebook parameters->GPU.</li>\n</ul>\n\n<p>The notebooks are intended as documentation and testing for the adg library. They encompass:</p>\n\n<ul>\n<li>Anisotropic fast marching methods, for shortest path computation.</li>\n<li>Non-divergence form PDEs, including non-linear PDEs such as Monge-Ampere.</li>\n<li>Divergence form anisotropic PDEs, often encountered in image processing.</li>\n<li>Algorithmic tools, related with lattice basis reduction methods, and automatic differentiation.</li>\n</ul>\n\n<p>For offline consultation, please download and install <a href=\"https://www.anaconda.com\">anaconda</a> or <a href=\"https://conda.io/en/latest/miniconda.html\">miniconda</a>. <br />\n<em>Optionally</em>, you may create a dedicated conda environnement by typing the following in a terminal:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"go\">conda env create --file agd-hfm.yaml</span>\n<span class=\"go\">conda activate agd-hfm</span>\n</code></pre>\n</div>\n\n<p>In order to open the book summary, type in a terminal:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"go\">jupyter notebook Summary.ipynb</span>\n</code></pre>\n</div>\n\n<p>Then use the hyperlinks to navigate within the notebooks.</p>\n\n<h3 id=\"matlab-users\">Matlab users</h3>\n\n<p>Recent versions of Matlab are able to call the Python interpreter, and thus to use the \nagd library. See Notebooks_FMM/Matlab for examples featuring the CPU and GPU eikonal solvers.</p>\n"}, {"fullname": "agd.AutomaticDifferentiation", "modulename": "agd.AutomaticDifferentiation", "kind": "module", "doc": "<p>This package implements automatic differentiation (AD) methods, in the following flavors:</p>\n\n<ul>\n<li>Dense, Sparse, and Reverse (experimental) modes</li>\n<li>First and second order differentiation</li>\n<li>CPU and GPU support, using numpy and cupy.\nThe AD types implement numpy's overloading mechanisms, and one should be able to use them\nas drop in replacement for numpy arrays in many contexts.</li>\n</ul>\n\n<p>Main submodules:</p>\n\n<ul>\n<li>Dense : first order, forward AD with dense storage.</li>\n<li>Dense2 : second order, forward AD with dense storage.</li>\n<li>Sparse : first order, forward AD with sparse storage.</li>\n<li>Sparse2 : second order, forward AD with sparse storage.</li>\n<li>Reverse, Reverse2 (experimental) : first and second order, reverse AD.</li>\n<li>Optimization : basic Newton method implemented using AD</li>\n</ul>\n\n<p>Main functions:</p>\n\n<ul>\n<li>asarray, array: turn a list/tuple of arrays into a larger array.</li>\n<li>is_ad : test whether a variable embeds AD information.</li>\n<li>remove_ad : remove AD information</li>\n<li>simplify_ad : compress the AD information, of Sparse and Sparse2 types.</li>\n<li>apply : apply a function to some arguments, using specified AD tricks.</li>\n<li>isndarray : returns true for numpy, cupy, and AD types.</li>\n<li>cupy_friendly : helper function for CPU/GPU generic programming.</li>\n</ul>\n"}, {"fullname": "agd.AutomaticDifferentiation.DeliberateNotebookError", "modulename": "agd.AutomaticDifferentiation", "qualname": "DeliberateNotebookError", "kind": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n", "bases": "builtins.Exception"}, {"fullname": "agd.AutomaticDifferentiation.DeliberateNotebookError.__init__", "modulename": "agd.AutomaticDifferentiation", "qualname": "DeliberateNotebookError.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">message</span></span>)</span>"}, {"fullname": "agd.AutomaticDifferentiation.AD_CUDA", "modulename": "agd.AutomaticDifferentiation.AD_CUDA", "kind": "module", "doc": "<p>This package is implementation detail for some GPU accelerated methods of the \nAutomaticDifferentation parent package. It should not be used directly</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.AD_CUDA.simplify_ad", "modulename": "agd.AutomaticDifferentiation.AD_CUDA.simplify_ad", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.AD_CUDA.simplify_ad.simplify_ad", "modulename": "agd.AutomaticDifferentiation.AD_CUDA.simplify_ad", "qualname": "simplify_ad", "kind": "function", "doc": "<p>Calls the GPU implementation of the simplify_ad method</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">atol</span>, </span><span class=\"param\"><span class=\"n\">rtol</span>, </span><span class=\"param\"><span class=\"n\">blockSize</span><span class=\"o\">=</span><span class=\"mi\">256</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base", "modulename": "agd.AutomaticDifferentiation.Base", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.ADCastError", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "ADCastError", "kind": "class", "doc": "<p>Raised when attempting to cast between different AD types</p>\n", "bases": "builtins.ValueError"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.pow", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.pow", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.log", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.exp", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.exp", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.abs", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.abs", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.sin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.sin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.cos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.cos", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.tan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.tan", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.arcsin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.arcsin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.arccos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.arccos", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.arctan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.arctan", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.sinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.sinh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.cosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.cosh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.tanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.tanh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.arcsinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.arcsinh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.arccosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.arccosh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor1.arctanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor1.arctanh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.pow", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.pow", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.log", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.exp", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.exp", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.abs", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.abs", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.sin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.sin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.cos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.cos", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.tan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.tan", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.arcsin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.arcsin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.arccos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.arccos", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.arctan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.arctan", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.sinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.sinh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.cosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.cosh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.tanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.tanh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.arcsinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.arcsinh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.arccosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.arccosh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.Taylor2.arctanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "Taylor2.arctanh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.add", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "add", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">where</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.subtract", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "subtract", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">where</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.multiply", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "multiply", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">where</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.true_divide", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "true_divide", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">where</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.maximum", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "maximum", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.minimum", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "minimum", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.shape", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.shape", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.ndim", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.ndim", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.size", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.flatten", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.flatten", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.squeeze", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.squeeze", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.T", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.T", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.stack", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.stack", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">elems</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.dtype", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.dtype", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.cupy_based", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.cupy_based", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.isndarray", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.isndarray", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.is_ad", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.is_ad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">other</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.new", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.new", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.Taylor", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.Taylor", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.sqrt", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.sqrt", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.log", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.exp", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.exp", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.abs", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.abs", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.sin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.sin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.cos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.cos", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.tan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.tan", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.arcsin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.arcsin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.arccos", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.arccos", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.arctan", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.arctan", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.sinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.sinh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.cosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.cosh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.tanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.tanh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.arcsinh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.arcsinh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.arccosh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.arccosh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.arctanh", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.arctanh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.argmin", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.argmin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.argmax", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.argmax", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.min", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.min", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">keepdims</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.max", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.max", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">keepdims</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.baseAD.prod", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "baseAD.prod", "kind": "function", "doc": "<p>Attempt to reproduce numpy prod function. (Rather inefficiently, and I presume partially)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">keepdims</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">initial</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.is_ad", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "is_ad", "kind": "function", "doc": "<p>Wether the object holds ad information</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">iterables</span><span class=\"o\">=</span><span class=\"p\">()</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.isndarray", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "isndarray", "kind": "function", "doc": "<p>Wether the object is a numpy or cupy ndarray, or an adtype</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.from_cupy", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "from_cupy", "kind": "function", "doc": "<p>Wether the variable is a cupy ndarray, or an AD type based on those</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.array", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "array", "kind": "function", "doc": "<p>Similar to np.array, but does not cast AD subclasses of np.ndarray to the base class.\nTurns a list or tuple of arrays with the same dimensions. \nTurns a scalar into an array scalar.\nInputs : </p>\n\n<ul>\n<li>caster : used to cast a scalar into an array scalar (overrides default)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">copy</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">caster</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.asarray", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "asarray", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.ascontiguousarray", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "ascontiguousarray", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.array_members", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "array_members", "kind": "function", "doc": "<p>Returns the list of all arrays in given structure, with their access paths.\nUsage : for key,value in ad.Base.array_members(self): print(key,value.nbytes/2**20)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\">iterables=(&lt;class &#x27;tuple&#x27;&gt;, &lt;class &#x27;list&#x27;&gt;, &lt;class &#x27;dict&#x27;&gt;)</span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.numpy_overloads", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "numpy_overloads", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&lt;function stack&gt;: &lt;function stack&gt;, &lt;function expand_dims&gt;: &lt;function expand_dims&gt;, &lt;function empty_like&gt;: &lt;function empty_like&gt;, &lt;function copyto&gt;: &lt;function copy_to&gt;, &lt;function broadcast_to&gt;: &lt;function broadcast_to&gt;, &lt;function where&gt;: &lt;function where&gt;, &lt;function sort&gt;: &lt;function sort&gt;, &lt;function concatenate&gt;: &lt;function concatenate&gt;, &lt;function pad&gt;: &lt;function pad&gt;, &lt;function mean&gt;: &lt;function mean&gt;, &lt;function roll&gt;: &lt;function roll&gt;, &lt;function allclose&gt;: &lt;function allclose&gt;, &lt;function flip&gt;: &lt;function flip&gt;}"}, {"fullname": "agd.AutomaticDifferentiation.Base.cupy_alt_overloads", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "cupy_alt_overloads", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&lt;function max&gt;: (&lt;function max&gt;, &lt;class &#x27;TypeError&#x27;&gt;), &lt;function put_along_axis&gt;: (&lt;function put_along_axis&gt;, &lt;class &#x27;TypeError&#x27;&gt;), &lt;function packbits&gt;: (&lt;function packbits&gt;, &lt;class &#x27;TypeError&#x27;&gt;)}"}, {"fullname": "agd.AutomaticDifferentiation.Base.numpy_implementation", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "numpy_implementation", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&lt;function argmax&gt;, &lt;function min&gt;, &lt;function sum&gt;, &lt;function prod&gt;, &lt;function take_along_axis&gt;, &lt;function amax&gt;, &lt;function argmin&gt;, &lt;function ones_like&gt;, &lt;function shape&gt;, &lt;function zeros_like&gt;, &lt;function ndim&gt;, &lt;function max&gt;, &lt;function squeeze&gt;, &lt;function reshape&gt;, &lt;function full_like&gt;, &lt;function moveaxis&gt;, &lt;function amin&gt;}"}, {"fullname": "agd.AutomaticDifferentiation.Base.implements", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "implements", "kind": "function", "doc": "<p>Register an __array_function__ implementation for MyArray objects.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">numpy_function</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.implements_cupy_alt", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "implements_cupy_alt", "kind": "function", "doc": "<p>Register an alternative to a numpy function only partially supported by cupy</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">numpy_function</span>, </span><span class=\"param\"><span class=\"n\">exception</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.stack", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "stack", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">elems</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.expand_dims", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "expand_dims", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">axis</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.empty_like", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "empty_like", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">subok</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.copy_to", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "copy_to", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dst</span>, </span><span class=\"param\"><span class=\"n\">src</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "broadcast_to", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">shape</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.where", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "where", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mask</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.sort", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "sort", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=-</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">varargs</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.concatenate", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "concatenate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">elems</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.pad", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "pad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">pad_width</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.mean", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "mean", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.roll", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "roll", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">shift</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.allclose", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "allclose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Base.flip", "modulename": "agd.AutomaticDifferentiation.Base", "qualname": "flip", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense", "modulename": "agd.AutomaticDifferentiation.Dense", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD", "kind": "class", "doc": "<p>A class for dense forward automatic differentiation</p>\n", "bases": "agd.AutomaticDifferentiation.Base.baseAD"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.__init__", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">coef</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">broadcast_ad</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.value", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.value", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.coef", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.coef", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.order", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.order", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.copy", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.copy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"s1\">&#39;C&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.as_tuple", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.as_tuple", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.as_func", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.as_func", "kind": "function", "doc": "<p>Replaces the symbolic perturbation with h</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">h</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.compose", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.compose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">t</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.size_ad", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.size_ad", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.gradient", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.gradient", "kind": "function", "doc": "<p>Returns the gradient, or the i-th component of the gradient if specified.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.reshape", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.reshape", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"s1\">&#39;C&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.broadcast_to", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.pad", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.pad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pad_width</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">constant_values</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.transpose", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.transpose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">axes</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.allclose", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.allclose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.sum", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.sum", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.solve", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.solve", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape_free</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">shape_bound</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.concatenate", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.concatenate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">elems</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.associate", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.associate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">squeeze_free_dims</span><span class=\"o\">=-</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">squeeze_bound_dims</span><span class=\"o\">=-</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD.apply_linear_operator", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD.apply_linear_operator", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">op</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.identity", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "identity", "kind": "function", "doc": "<p>Creates a dense AD variable with independent symbolic perturbations for each coordinate\n(unless some are tied together as specified by shape_free and shape_bound)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">shape_free</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">shape_bound</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">constant</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">shift</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.register", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "register", "kind": "function", "doc": "<p>Creates a series of dense AD variables with independent symbolic perturbations for each coordinate,\nand adequate intermediate shifts.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">inputs</span>,</span><span class=\"param\">\t<span class=\"n\">iterables</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">shape_bound</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">shift</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">ident</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">identity</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">considered</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_Lin", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_Lin", "kind": "class", "doc": "<p>A class implementing a linear operator L with an AD part \u03b4L, and rule\n(L+\u03b4L)(u+\u03b4u) = L(u) + (\u03b4L(u) + L(\u03b4u)) + o(\u03b4^2).</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_Lin.__init__", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_Lin.__init__", "kind": "function", "doc": "<ul>\n<li>value : Some linear operator L</li>\n<li>coef : A list of linear operators \u03b4L</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">coef</span></span>)</span>"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_Lin.value", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_Lin.value", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_Lin.coef", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_Lin.coef", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.denseAD_Lin.size_ad", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "denseAD_Lin.size_ad", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense.as_callable", "modulename": "agd.AutomaticDifferentiation.Dense", "qualname": "as_callable", "kind": "function", "doc": "<p>Make matrices and sparse matrices callable</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">L</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2", "modulename": "agd.AutomaticDifferentiation.Dense2", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2", "kind": "class", "doc": "<p>A class for dense forward second order automatic differentiation</p>\n", "bases": "agd.AutomaticDifferentiation.Base.baseAD"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.__init__", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">coef1</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">coef2</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">broadcast_ad</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.value", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.value", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.coef1", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.coef1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.coef2", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.coef2", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.order", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.order", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.copy", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.copy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"s1\">&#39;C&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.as_tuple", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.as_tuple", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.as_func", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.as_func", "kind": "function", "doc": "<p>Replaces the symbolic perturbation with h</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">h</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.compose", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.compose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">t</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.size_ad", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.size_ad", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.to_first", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.to_first", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.gradient", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.gradient", "kind": "function", "doc": "<p>Returns the gradient, or the i-th component of the gradient if specified.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.hessian", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.hessian", "kind": "function", "doc": "<p>Returns the hessian, or component (i,j) of the hessian if specified.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">j</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.reshape", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.reshape", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"s1\">&#39;C&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.broadcast_to", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.pad", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.pad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pad_width</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">constant_values</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.transpose", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.transpose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">axes</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.allclose", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.allclose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.sum", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.sum", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.concatenate", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.concatenate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">elems</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.denseAD2.apply_linear_operator", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "denseAD2.apply_linear_operator", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">op</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.identity", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "identity", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Dense2.register", "modulename": "agd.AutomaticDifferentiation.Dense2", "qualname": "register", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Optimization", "modulename": "agd.AutomaticDifferentiation.Optimization", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.norm", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "norm", "kind": "function", "doc": "<p>Returns L^p norm of array, seen as a vector, w.r.t. weights.\nDefined as : (sum_i x[i]^p)^(1/p)</p>\n\n<p>Remark : not a matrix operator norm</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>ord : exponent p</li>\n<li>axis : int or None, axis along which to compute the norm. </li>\n<li>keepdims : wether to keep singleton dimensions.</li>\n<li>averaged : wether to introduce a normalization factor, so that norm(ones(...))=1</li>\n</ul>\n\n<p>Compatible with automatic differentiation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"nb\">ord</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">keepdims</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">averaged</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.norm_infinity", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "norm_infinity", "kind": "function", "doc": "<p>L-Infinity norm (largest absolute value)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.norm_average", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "norm_average", "kind": "function", "doc": "<p>Averaged L1 norm (sum of absolute values divided by array size)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default", "kind": "class", "doc": "<p>Default stopping criterion for the Newton method, which uses the method __call__.\nParameters : </p>\n\n<ul>\n<li>residue_tol : target tolerance on the residue infinity norm</li>\n<li>niter_max : max iterations before aborting</li>\n<li>raise_on_abort : wether to raise an exception if aborting</li>\n<li>niter_print : generator for which iterations to print the state</li>\n</ul>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default.__init__", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">residue_tol</span><span class=\"o\">=</span><span class=\"mf\">1e-08</span>,</span><span class=\"param\">\t<span class=\"n\">niter_max</span><span class=\"o\">=</span><span class=\"mi\">50</span>,</span><span class=\"param\">\t<span class=\"n\">raise_on_abort</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">niter_print</span><span class=\"o\">=</span><span class=\"s1\">&#39;Default&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbosity</span><span class=\"o\">=</span><span class=\"mi\">3</span></span>)</span>"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default.residue_tol", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default.residue_tol", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default.niter_max", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default.niter_max", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default.raise_on_abort", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default.raise_on_abort", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default.niter_print_iter", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default.niter_print_iter", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default.niter_print_next", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default.niter_print_next", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default.niter_print_last", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default.niter_print_last", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default.residue_norms", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default.residue_norms", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default.verbosity", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default.verbosity", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.stop_default.abort", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "stop_default.abort", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.damping_default", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "damping_default", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.damping_default.__init__", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "damping_default.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">criterion</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">refine_factor</span><span class=\"o\">=</span><span class=\"mf\">2.0</span>,</span><span class=\"param\">\t<span class=\"n\">step_min</span><span class=\"o\">=</span><span class=\"mf\">0.002</span>,</span><span class=\"param\">\t<span class=\"n\">raise_on_abort</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.damping_default.criterion", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "damping_default.criterion", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.damping_default.refine_factor", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "damping_default.refine_factor", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.damping_default.step_min", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "damping_default.step_min", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.damping_default.raise_on_abort", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "damping_default.raise_on_abort", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.damping_default.steps", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "damping_default.steps", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.newton_root", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "newton_root", "kind": "function", "doc": "<p>Newton's method, for finding a root of a given function.\nf : function to be solved\nx0 : initial guess for the root\nstop : stopping criterion, presented as either</p>\n\n<ul>\n<li>keyword \"Default\" for using the stop_default class</li>\n<li>a dict for using the stop_class with specified initialization arguments</li>\n<li>a callable, <br />\nrelax : added to the jacobian before inversion\ndamping : criterion for step reduction\nad : is either </li>\n<li>keyword \"Sparse\" for using Sparse AD (Default)</li>\n<li>keyword \"Dense\" for using Dense AD</li>\n<li>a shape_bound given as a tuple, for Dense AD with few independent variables</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">f</span>,</span><span class=\"param\">\t<span class=\"n\">x0</span>,</span><span class=\"param\">\t<span class=\"n\">fargs</span><span class=\"o\">=</span><span class=\"p\">()</span>,</span><span class=\"param\">\t<span class=\"n\">stop</span><span class=\"o\">=</span><span class=\"s1\">&#39;Default&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">relax</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">damping</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ad</span><span class=\"o\">=</span><span class=\"s1\">&#39;Sparse&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">solver</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">in_place</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Optimization.newton_minimize", "modulename": "agd.AutomaticDifferentiation.Optimization", "qualname": "newton_minimize", "kind": "function", "doc": "<p>Inputs</p>\n\n<ul>\n<li>f : function to evaluate</li>\n<li>x0 : initial guess</li>\n<li>fargs (optional) : additional arguments for f</li>\n<li>f_value_gradient_direction (optional) : method for computing the value, gradient, \nand descent direction of f, which can be either of \n<ul>\n<li>\"Sparse2\" or \"Dense2\", automatic differentiation is applied to f</li>\n<li>a callable, with the same arguments as f, returning a Sparse2 or Dense2 result</li>\n<li>a callable, with the same arguments as f, returning a tuple (value,gradient,direction)</li>\n</ul></li>\n<li>step_min (optional) : minimum admissible step for the damped newton method</li>\n<li>maxiter (optional) : max number of iterations</li>\n<li>verbosity (optional) : amount of information displayed</li>\n<li>\u03b4_atol,\u03b4_rtol,\u03b4_ntol,\u03b4_nneg (optional) : parameters of the stopping criterion</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">f</span>,</span><span class=\"param\">\t<span class=\"n\">x0</span>,</span><span class=\"param\">\t<span class=\"n\">fargs</span><span class=\"o\">=</span><span class=\"p\">()</span>,</span><span class=\"param\">\t<span class=\"n\">f_value_gradient_direction</span><span class=\"o\">=</span><span class=\"s1\">&#39;Sparse2&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">step_min</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">maxiter</span><span class=\"o\">=</span><span class=\"mi\">50</span>,</span><span class=\"param\">\t<span class=\"n\">verbosity</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">\u03b4_atol</span><span class=\"o\">=</span><span class=\"mf\">1e-09</span>,</span><span class=\"param\">\t<span class=\"n\">\u03b4_rtol</span><span class=\"o\">=</span><span class=\"mf\">1e-09</span>,</span><span class=\"param\">\t<span class=\"n\">\u03b4_ntol</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">\u03b4_nneg</span><span class=\"o\">=</span><span class=\"mi\">3</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse", "modulename": "agd.AutomaticDifferentiation.Reverse", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD", "kind": "class", "doc": "<p>A class for reverse first order automatic differentiation.</p>\n\n<p>Fields : </p>\n\n<ul>\n<li>input_iterables : tuple, subset of {tuple,list,dict,set}.\nWhich input structures should be explored when looking for AD information</li>\n<li>output_iterables : tuple subset of (tuple,list,dict).\nWhich output structures should be explored looking for AD information</li>\n</ul>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.__init__", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">operator_data</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">input_iterables</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">output_iterables</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.operator_data", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.operator_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.deepcopy_states", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.deepcopy_states", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.input_iterables", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.input_iterables", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.output_iterables", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.output_iterables", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.size_ad", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.size_ad", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.size_rev", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.size_rev", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.register", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.register", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.identity", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.identity", "kind": "function", "doc": "<p>Creates and register a new AD variable</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.apply", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.apply", "kind": "function", "doc": "<p>Applies a function on the given args, saving adequate data\nfor reverse AD.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">func</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.apply_linear_mapping", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.apply_linear_mapping", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">matrix</span>, </span><span class=\"param\"><span class=\"n\">rhs</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.apply_linear_inverse", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.apply_linear_inverse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">solver</span>, </span><span class=\"param\"><span class=\"n\">matrix</span>, </span><span class=\"param\"><span class=\"n\">rhs</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.simplify", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.simplify", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rhs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.iterate", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.iterate", "kind": "function", "doc": "<p>Input: function, variable to be updated, niter, nrec, optional args\nIterates a function, saving adequate data for reverse AD. \nIf nrec>0, a recursive strategy is used to limit the amount of data saved.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">func</span>, </span><span class=\"param\"><span class=\"n\">var</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.to_inputshapes", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.to_inputshapes", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.gradient", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.gradient", "kind": "function", "doc": "<p>Computes the gradient of the scalar spAD variable a</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.reverseAD.output", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "reverseAD.output", "kind": "function", "doc": "<p>Computes the gradient of the output a, times the co_state, for an operator_like reverseAD</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.empty", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "empty", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.operator_like", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "operator_like", "kind": "function", "doc": "<p>Operator_like reverseAD (or reverseAD2 depending on co_output): </p>\n\n<ul>\n<li>has a fixed co_output</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">co_output</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.linear_inverse_with_adjoint", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "linear_inverse_with_adjoint", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">solver</span>, </span><span class=\"param\"><span class=\"n\">matrix</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.linear_mapping_with_adjoint", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "linear_mapping_with_adjoint", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">matrix</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse.identity_with_adjoint", "modulename": "agd.AutomaticDifferentiation.Reverse", "qualname": "identity_with_adjoint", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">co_output</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2", "modulename": "agd.AutomaticDifferentiation.Reverse2", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2", "kind": "class", "doc": "<p>A class for reverse second order automatic differentiation</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.__init__", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">operator_data</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">input_iterables</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">output_iterables</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.operator_data", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.operator_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.deepcopy_states", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.deepcopy_states", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.input_iterables", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.input_iterables", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.output_iterables", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.output_iterables", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.size_ad", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.size_ad", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.size_rev", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.size_rev", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.register", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.register", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.identity", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.identity", "kind": "function", "doc": "<p>Creates and registers a new AD variable</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.apply", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.apply", "kind": "function", "doc": "<p>Applies a function on the given args, saving adequate data\nfor reverse AD.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">func</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.apply_linear_mapping", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.apply_linear_mapping", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">matrix</span>, </span><span class=\"param\"><span class=\"n\">rhs</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.apply_linear_inverse", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.apply_linear_inverse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">matrix</span>, </span><span class=\"param\"><span class=\"n\">solver</span>, </span><span class=\"param\"><span class=\"n\">rhs</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.simplify", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.simplify", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rhs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.gradient", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.gradient", "kind": "function", "doc": "<p>Computes the gradient of the scalar spAD2 variable a</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.hessian", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.hessian", "kind": "function", "doc": "<p>Returns the hessian operator associated with the scalar spAD2 variable a</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.to_inputshapes", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.to_inputshapes", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.reverseAD2.output", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "reverseAD2.output", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.empty", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "empty", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Reverse2.operator_like", "modulename": "agd.AutomaticDifferentiation.Reverse2", "qualname": "operator_like", "kind": "function", "doc": "<p>Operator_like reverseAD2 (or Reverse depending on reverse mode): </p>\n\n<ul>\n<li>should not register new inputs (conflicts with the way dir_hessian is provided)</li>\n<li>fixed co_output </li>\n<li>gets dir_hessian from inputs</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">co_output</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse", "modulename": "agd.AutomaticDifferentiation.Sparse", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD", "kind": "class", "doc": "<p>A class for sparse forward automatic differentiation</p>\n", "bases": "agd.AutomaticDifferentiation.Base.baseAD"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.__init__", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">coef</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">broadcast_ad</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.value", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.value", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.coef", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.coef", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.index", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.index", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.order", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.order", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.copy", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.copy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"s1\">&#39;C&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.as_tuple", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.as_tuple", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.as_func", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.as_func", "kind": "function", "doc": "<p>Replaces the symbolic perturbation with h, if specified.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">h</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.compose", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.compose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">t</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.size_ad", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.size_ad", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.reshape", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.reshape", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"s1\">&#39;C&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.broadcast_to", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.pad", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.pad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pad_width</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">constant_values</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.transpose", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.transpose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">axes</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.allclose", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.allclose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.sum", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.sum", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.bound_ad", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.bound_ad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.to_dense", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.to_dense", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dense_size_ad</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.triplets", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.triplets", "kind": "function", "doc": "<p>Returns the triplets defining the sparse linear operator. </p>\n\n<ul>\n<li>tol : remove coefficients whose magnitude is below this threshold</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.tangent_operator", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.tangent_operator", "kind": "function", "doc": "<p>The tangent linear operator as a sparse matrix.</p>\n\n<ul>\n<li>**kwargs : passed to triplets</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">bound_ad</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.adjoint_operator", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.adjoint_operator", "kind": "function", "doc": "<p>The adjoint of the tangent linear operator as a sparse matrix.</p>\n\n<ul>\n<li>**kwargs : passed to triplets</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">bound_ad</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.solve", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.solve", "kind": "function", "doc": "<p>Assume that the spAD instance represents the variable y = x + A<em>delta,\nwhere delta is a symbolic perturbation. \nSolves the system x + A</em>delta = 0, assuming compatible shapes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">raw</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.is_elliptic", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.is_elliptic", "kind": "function", "doc": "<p>Tests wether the variable encodes a (linear) degenerate elliptic scheme.\nOutput :</p>\n\n<ul>\n<li>sum of the coefficients at each position (must be non-negative for \ndegenerate ellipticity, positive for strict ellipticity)</li>\n<li>maximum of off-diagonal coefficients at each position (must be non-positive)\nOutput (if tol is specified) : </li>\n<li>min_sum &gt;=-tol and max_off &lt;= tol\nSide effect warning : AD simplification, which is also possibly costly</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">identity_var</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.concatenate", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.concatenate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">elems</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.spAD.simplify_ad", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "spAD.simplify_ad", "kind": "function", "doc": "<p>Compresses the AD information by merging suitable coefficients, and optionally \nremoving negligible ones.</p>\n\n<ul>\n<li>atol : absolute tolerance to discard a coefficient. (True -> sensible default.)</li>\n<li>rtol : relative tolerance to discard a coefficient (compared to largest in row)\nOperates in place, but also returns itself.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">atol</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">rtol</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.identity", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "identity", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">constant</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">shift</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse.register", "modulename": "agd.AutomaticDifferentiation.Sparse", "qualname": "register", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">inputs</span>, </span><span class=\"param\"><span class=\"n\">iterables</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">shift</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">ident</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">identity</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2", "modulename": "agd.AutomaticDifferentiation.Sparse2", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2", "kind": "class", "doc": "<p>A class for sparse forward second order automatic differentiation</p>\n", "bases": "agd.AutomaticDifferentiation.Base.baseAD"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.__init__", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">value</span>,</span><span class=\"param\">\t<span class=\"n\">coef1</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">index</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">coef2</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">index_row</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">index_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_ad</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.value", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.value", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.coef1", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.coef1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.index", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.index", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.coef2", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.coef2", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.index_row", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.index_row", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.index_col", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.index_col", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.order", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.order", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.copy", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.copy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"s1\">&#39;C&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.as_tuple", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.as_tuple", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.as_func", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.as_func", "kind": "function", "doc": "<p>Replaces the symbolic perturbation with h</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">h</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.compose", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.compose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">t</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.size_ad1", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.size_ad1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.size_ad2", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.size_ad2", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.reshape", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.reshape", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"s1\">&#39;C&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.broadcast_to", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.broadcast_to", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.pad", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.pad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pad_width</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">constant_values</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.transpose", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.transpose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">axes</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.allclose", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.allclose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.sum", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.sum", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.bound_ad", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.bound_ad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.to_dense", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.to_dense", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dense_size_ad</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.to_first", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.to_first", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.triplets", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.triplets", "kind": "function", "doc": "<p>The hessian operator, presented as triplets</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.hessian_operator", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.hessian_operator", "kind": "function", "doc": "<p>The hessian operator, presented as an opaque matrix class, supporting mul.\nImplicitly sums over all axes. Recommendation : apply simplify_ad before call.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.tangent_operator", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.tangent_operator", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.adjoint_operator", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.adjoint_operator", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.solve_stationnary", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.solve_stationnary", "kind": "function", "doc": "<p>Finds a stationnary point to a quadratic function, provided as a spAD2 array scalar. \nUse \"raw = True\" to obtain the raw linear system and use your own solver.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">raw</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.solve_weakform", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.solve_weakform", "kind": "function", "doc": "<p>Assume that a spAD2 array scalar represents the quadratic function\nQ(u,v) = a0 + a1.(u,v) + (u,v).a2.(u,v) of the variable (u,v).\nFinds u such that Q(u,v) is independent of v.\nUse \"raw = True\" to obtain the raw linear system and use your own solver.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">raw</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.concatenate", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.concatenate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">elems</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.spAD2.simplify_ad", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "spAD2.simplify_ad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.identity", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "identity", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.register", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "register", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.Sparse2.hessian_operator", "modulename": "agd.AutomaticDifferentiation.Sparse2", "qualname": "hessian_operator", "kind": "function", "doc": "<p>Returns the sparse matrix associated to the hessian of f at x,\ngenerated using automatic differentiation.\nTypically used to obtain the sparse matrix of a quadratic form.\nOutput of f is summed, if non-scalar.</p>\n\n<ul>\n<li>simplify_ad (optional): wether to simplify the ad information \nbefore generating the sparse matrix</li>\n</ul>\n\n<p><em>Autodiff support</em> \nConsider the functional D * u**2, written with the following convention</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">D</span><span class=\"p\">,</span><span class=\"n\">ad_channel</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span><span class=\"n\">x</span><span class=\"p\">):</span> <span class=\"k\">return</span> <span class=\"n\">ad_channel</span><span class=\"p\">(</span><span class=\"n\">D</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">u</span><span class=\"o\">**</span><span class=\"mi\">2</span>\n<span class=\"go\">See Eikonal.cuda.AnisotropicWave, classes AcousticHamiltonian_Sparse and </span>\n<span class=\"go\">ElasticHamiltonian_Sparse for non-trivial examples.</span>\n</code></pre>\n</div>\n\n<ul>\n<li><p>Foward autodiff. Returns an denseAD_Lin class (operator plus perturbation), \nif f(x) is a first order dense forward AD variable, with the following convention/example :   </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ad</span><span class=\"o\">.</span><span class=\"n\">Sparse2</span><span class=\"o\">.</span><span class=\"n\">hessian_operator</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">),</span><span class=\"n\">fargs</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">ad</span><span class=\"o\">.</span><span class=\"n\">Dense</span><span class=\"o\">.</span><span class=\"n\">identity</span><span class=\"p\">(</span><span class=\"n\">constant</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">),))</span>\n</code></pre>\n</div></li>\n<li><p>Reverse autodiff support (rev_ad=True). The components of f(x,ad_channel=ones_like)\nare regarded as independent contributions w.r.t which to compute the sensitivity of the result.</p></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">simplify_ad</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">fargs</span><span class=\"o\">=</span><span class=\"p\">()</span>, </span><span class=\"param\"><span class=\"n\">rev_ad</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic", "modulename": "agd.AutomaticDifferentiation.ad_generic", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.adtype", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "adtype", "kind": "function", "doc": "<p>Returns None if no ad variable found, or the adtype if one is found.\nAlso checks consistency of the ad types.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">iterables</span><span class=\"o\">=</span><span class=\"p\">()</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.precision", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "precision", "kind": "function", "doc": "<p>Precision of the floating point type of x.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.remove_ad", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "remove_ad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">iterables</span><span class=\"o\">=</span><span class=\"p\">()</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.as_writable", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "as_writable", "kind": "function", "doc": "<p>Returns a writable array containing the same elements as a.\nIf the array a, or a field of a for an AD type, is flagged as \nnon-writable, then it is copied.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.common_cast", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "common_cast", "kind": "function", "doc": "<p>If any of the arguments is an AD type, casts all other arguments to that type.\nCasts to ndarray if no argument is an AD type. \nUsage : if a and b may or may not b AD arrays, \na,b = common_cast(a,b); a[0]=b[0]</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.min_argmin", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "min_argmin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.max_argmax", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "max_argmax", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.apply_linear_mapping", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "apply_linear_mapping", "kind": "function", "doc": "<p>Applies the provided linear operator, to a dense AD variable of first or second order.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">matrix</span>, </span><span class=\"param\"><span class=\"n\">rhs</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.apply_linear_inverse", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "apply_linear_inverse", "kind": "function", "doc": "<p>Applies the provided linear inverse to a dense AD variable of first or second order.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">solver</span>, </span><span class=\"param\"><span class=\"n\">matrix</span>, </span><span class=\"param\"><span class=\"n\">rhs</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.squeeze_shape", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "squeeze_shape", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span>, </span><span class=\"param\"><span class=\"n\">axis</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.expand_shape", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "expand_shape", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span>, </span><span class=\"param\"><span class=\"n\">axis</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.disassociate", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "disassociate", "kind": "function", "doc": "<p>Turns an array of shape shape_free + shape_bound \ninto an array of shape shape_free whose elements \nare arrays of shape shape_bound.\nTypical usage : recursive automatic differentiation.\nCaveat : by defaut, singleton dimensions are introduced \nto avoid numpy's \"clever\" treatment of scalar arrays.</p>\n\n<p>Arguments: </p>\n\n<ul>\n<li>array : reshaped array</li>\n<li>(optional) shape_free, shape_bound : outer and inner array shapes. One is deduced from the other.</li>\n<li>(optional) expand_free_dims, expand_bound_dims.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">array</span>,</span><span class=\"param\">\t<span class=\"n\">shape_free</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">shape_bound</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">expand_free_dims</span><span class=\"o\">=-</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">expand_bound_dims</span><span class=\"o\">=-</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_generic.associate", "modulename": "agd.AutomaticDifferentiation.ad_generic", "qualname": "associate", "kind": "function", "doc": "<p>Turns an array of shape shape_free, whose elements \nare arrays of shape shape_bound, into an array \nof shape shape_free+shape_bound.\nInverse opeation to disassociate.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">squeeze_free_dims</span><span class=\"o\">=-</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">squeeze_bound_dims</span><span class=\"o\">=-</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_specific", "modulename": "agd.AutomaticDifferentiation.ad_specific", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.ad_specific.simplify_ad", "modulename": "agd.AutomaticDifferentiation.ad_specific", "qualname": "simplify_ad", "kind": "function", "doc": "<p>Simplifies, if possible, the sparsity pattern of a sparse AD variable.\nSee Sparse.spAD.simplify_ad for detailed help.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_specific.apply", "modulename": "agd.AutomaticDifferentiation.ad_specific", "qualname": "apply", "kind": "function", "doc": "<p>Applies the function to the given arguments, with special treatment if the following \nkeywords : </p>\n\n<ul>\n<li>envelope : take advantage of the envelope theorem, to differentiate a min or max.\nThe function is called twice, first without AD, then with AD and the oracle parameter.</li>\n<li>shape_bound : take advantage of dense-sparse (or dense-dense) AD composition to \ndifferentiate the function efficiently. The function is called with dense AD, and \nthe dimensions in shape_bound are regarded as a simple scalar.</li>\n<li>reverse_history : use the provided reverse AD trace.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.ad_specific.compose", "modulename": "agd.AutomaticDifferentiation.ad_specific", "qualname": "compose", "kind": "function", "doc": "<p>Compose ad types, mostly intended for dense a and sparse b</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">shape_bound</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "kind": "module", "doc": "<p>This file implements functionalities needed to make the agd library generic to cupy/numpy usage.\nIt does not import cupy, unless absolutely required.</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.get_array_module", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "get_array_module", "kind": "function", "doc": "<p>Returns the cupy module or the numpy module, depending on data</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">iterables</span><span class=\"o\">=</span><span class=\"p\">()</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.samesize_int_t", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "samesize_int_t", "kind": "function", "doc": "<p>Returns an integer type of the same size (32 or 64 bits) as a given float type</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">float_t</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.dtype32to64", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "dtype32to64", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&lt;class &#x27;numpy.float32&#x27;&gt;: &lt;class &#x27;numpy.float64&#x27;&gt;, &lt;class &#x27;numpy.int32&#x27;&gt;: &lt;class &#x27;numpy.int64&#x27;&gt;, &lt;class &#x27;numpy.uint32&#x27;&gt;: &lt;class &#x27;numpy.uint64&#x27;&gt;}"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.dtype64to32", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "dtype64to32", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&lt;class &#x27;numpy.float64&#x27;&gt;: &lt;class &#x27;numpy.float32&#x27;&gt;, &lt;class &#x27;numpy.int64&#x27;&gt;: &lt;class &#x27;numpy.int32&#x27;&gt;, &lt;class &#x27;numpy.uint64&#x27;&gt;: &lt;class &#x27;numpy.uint32&#x27;&gt;}"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.cupy_get", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "cupy_get", "kind": "function", "doc": "<p>If argument is a cupy ndarray, returns output of 'get' member function, \nwhich is a numpy ndarray. Likewise for AD types. Returns unchanged argument otherwise.</p>\n\n<ul>\n<li>dtype64 : convert 32 bit floats and ints to their 64 bit counterparts</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">dtype64</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">iterables</span><span class=\"o\">=</span><span class=\"p\">()</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.cupy_set", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "cupy_set", "kind": "function", "doc": "<p>If argument is a numpy ndarray, converts it to a cupy ndarray. Applies to AD Types.</p>\n\n<ul>\n<li>dtype32 : convert 64 bit floats and ints to their 32 bit counterparts</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">dtype32</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">iterables</span><span class=\"o\">=</span><span class=\"p\">()</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.cupy_get_args", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "cupy_get_args", "kind": "function", "doc": "<p>Decorator applying cupy_get to all arguments of the given function.</p>\n\n<ul>\n<li><em>args, *</em>kwargs : passed to cupy_get</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.has_dtype", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "has_dtype", "kind": "function", "doc": "<p>Wether one member of args is an ndarray with the provided dtype.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arg</span>, </span><span class=\"param\"><span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;dtype&#39;</span>, </span><span class=\"param\">iterables=&lt;class &#x27;tuple&#x27;&gt;</span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.get_float_t", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "get_float_t", "kind": "function", "doc": "<p>Returns float32 if found in any argument, else float64.</p>\n\n<ul>\n<li>kwargs : passed to has_dtype</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arg</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.array_float_caster", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "array_float_caster", "kind": "function", "doc": "<p>returns lambda arr : xp.asarray(arr,dtype=float_t) \nwhere xp and float_t are in consistency with the arguments.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arg</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.set_output_dtype32", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "set_output_dtype32", "kind": "function", "doc": "<p>If the output of the given funtion contains ndarrays with 64bit dtype,\nint or float, they are converted to 32 bit dtype.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">silent</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\">iterables=(&lt;class &#x27;tuple&#x27;&gt;,)</span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_generic.cupy_friendly", "modulename": "agd.AutomaticDifferentiation.cupy_generic", "qualname": "cupy_friendly", "kind": "function", "doc": "<p>Returns a \"cupy-friendly\" copy of the input module, function, or object,\nfollowing arbitrary and ad-hoc rules.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arg</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.cupy_support", "modulename": "agd.AutomaticDifferentiation.cupy_support", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.cupy_support.packbits", "modulename": "agd.AutomaticDifferentiation.cupy_support", "qualname": "packbits", "kind": "function", "doc": "<p>packbits(a, /, axis=None, bitorder='big')</p>\n\n<p>Packs the elements of a binary-valued array into bits in a uint8 array.</p>\n\n<p>The result is padded to full bytes by inserting zero bits at the end.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>a : array_like\n    An array of integers or booleans whose elements should be packed to\n    bits.\naxis : int, optional\n    The dimension over which bit-packing is done.\n    <code>None</code> implies packing the flattened array.\nbitorder : {'big', 'little'}, optional\n    The order of the input bits. 'big' will mimic bin(val),\n    <code>[0, 0, 0, 0, 0, 0, 1, 1] =&gt; 3 = 0b00000011</code>, 'little' will\n    reverse the order so <code>[1, 1, 0, 0, 0, 0, 0, 0] =&gt; 3</code>.\n    Defaults to 'big'.</p>\n\n<pre><code>*New in version 1.17.0.*\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>packed : ndarray\n    Array of type uint8 whose elements represent bits corresponding to the\n    logical (0 or nonzero) value of the input elements. The shape of\n    <code>packed</code> has the same number of dimensions as the input (unless <code>axis</code>\n    is None, in which case the output is 1-D).</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>unpackbits: Unpacks elements of a uint8 array into a binary-valued output\n            array.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>               <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>               <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">packbits</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">b</span>\n<span class=\"go\">array([[[160],</span>\n<span class=\"go\">        [ 64]],</span>\n<span class=\"go\">       [[192],</span>\n<span class=\"go\">        [ 32]]], dtype=uint8)</span>\n</code></pre>\n</div>\n\n<p>Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,\nand 32 = 0010 0000.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional", "modulename": "agd.AutomaticDifferentiation.functional", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.functional.from_generator", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "from_generator", "kind": "function", "doc": "<p>Returns the method for constructing an object from a generator.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">iterable_type</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.rec_iter", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "rec_iter", "kind": "function", "doc": "<p>Iterate recursively over x. \nIn the case of dictionnaries, if specified among the iterables, one iterates over values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">iterables</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.pair", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "pair", "kind": "class", "doc": "<p>A two element iterable. \nIntroduced as an alternative of tuple, to avoid confusion in map_iterables</p>\n"}, {"fullname": "agd.AutomaticDifferentiation.functional.pair.__init__", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "pair.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">first</span>, </span><span class=\"param\"><span class=\"n\">second</span></span>)</span>"}, {"fullname": "agd.AutomaticDifferentiation.functional.pair.first", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "pair.first", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.functional.pair.second", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "pair.second", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.functional.dict_like", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "dict_like", "kind": "function", "doc": "<p>Wether a, type or instance, has 'items' attribute. \nWill be regarded as dict-like structure.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.map_iterables", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "map_iterables", "kind": "function", "doc": "<p>Apply f to variable 'a' exploring recursively certain iterables</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">iterables</span>, </span><span class=\"param\"><span class=\"n\">split</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.map_iterables2", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "map_iterables2", "kind": "function", "doc": "<p>Apply f to variable 'a' and 'b' zipped, exploring recursively certain iterables</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">iterables</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.recurse", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "recurse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">step</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.decorator_with_arguments", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "decorator_with_arguments", "kind": "function", "doc": "<p>Decorator intended to simplify writing decorators with arguments. \n(In addition to the decorated function itself.)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">decorator</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.decorate_module_functions", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "decorate_module_functions", "kind": "function", "doc": "<p>Decorate the functions of a module.\nInputs : </p>\n\n<ul>\n<li>module : whose functions must be decorated</li>\n<li>decorator : to be applied</li>\n<li>copy_module : create a shallow copy of the module</li>\n<li>fct_names (optional) : list of functions to be decorated.\nIf unspecified, all functions, builtin functions, and builtin methods, are decorated.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">module</span>,</span><span class=\"param\">\t<span class=\"n\">decorator</span>,</span><span class=\"param\">\t<span class=\"n\">copy_module</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">fct_names</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ret_decorated</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.functional.func_except_alt", "modulename": "agd.AutomaticDifferentiation.functional", "qualname": "func_except_alt", "kind": "function", "doc": "<p>Returns a callable which evaluates func, but falls back to alt if exception is caught.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span>, </span><span class=\"param\"><span class=\"n\">exception</span>, </span><span class=\"param\"><span class=\"n\">alt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc", "modulename": "agd.AutomaticDifferentiation.misc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.AutomaticDifferentiation.misc.normalize_axis", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "normalize_axis", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">axis</span>, </span><span class=\"param\"><span class=\"n\">ndim</span>, </span><span class=\"param\"><span class=\"n\">allow_tuple</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.add_ndim", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "add_ndim", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.key_expand", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "key_expand", "kind": "function", "doc": "<p>Modifies a key to access an array with more dimensions. Needed if ellipsis is used.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">depth</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.apply_linear_operator", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "apply_linear_operator", "kind": "function", "doc": "<p>Applies a linear operator to an array with more than two dimensions,\nby flattening the last dimensions</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">op</span>, </span><span class=\"param\"><span class=\"n\">rhs</span>, </span><span class=\"param\"><span class=\"n\">flatten_ndim</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.ready_ad", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "ready_ad", "kind": "function", "doc": "<p>Readies a variable for adding ad information, if possible.\nReturns : readied variable, boolean (wether AD extension is possible)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.register", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "register", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">identity</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">iterables</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.sumprod", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "sumprod", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">iterables</span>, </span><span class=\"param\"><span class=\"n\">to_first</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.reverse_mode", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "reverse_mode", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">co_output</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.recurse", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "recurse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">step</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.as_flat", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "as_flat", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.tocsr", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "tocsr", "kind": "function", "doc": "<p>Turns sparse matrix given as triplets into a csr (compressed sparse row) matrix</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">triplets</span>, </span><span class=\"param\"><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.spsolve", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "spsolve", "kind": "function", "doc": "<p>Solves a sparse linear system where the matrix is given as triplets.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">triplets</span>, </span><span class=\"param\"><span class=\"n\">rhs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.AutomaticDifferentiation.misc.spapply", "modulename": "agd.AutomaticDifferentiation.misc", "qualname": "spapply", "kind": "function", "doc": "<p>Applies a sparse matrix, given as triplets, to an rhs.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">triplets</span>, </span><span class=\"param\"><span class=\"n\">rhs</span>, </span><span class=\"param\"><span class=\"n\">crop_rhs</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain", "modulename": "agd.Domain", "kind": "module", "doc": "<p>This module allows to define domains of $R^d$ by combinations of elementary shapes, \nand to compute finite differences within these domains with Dirichlet boundary conditions.</p>\n"}, {"fullname": "agd.Domain.Domain", "modulename": "agd.Domain", "qualname": "Domain", "kind": "class", "doc": "<p>This class represents a domain from which one can query \na level set function, the boundary distance in a given direction,\nand some related methods.</p>\n"}, {"fullname": "agd.Domain.Domain.level", "modulename": "agd.Domain", "qualname": "Domain.level", "kind": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Domain.contains", "modulename": "agd.Domain", "qualname": "Domain.contains", "kind": "function", "doc": "<p>Wether x lies inside the domain.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Domain.intervals", "modulename": "agd.Domain", "qualname": "Domain.intervals", "kind": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Domain.freeway", "modulename": "agd.Domain", "qualname": "Domain.freeway", "kind": "function", "doc": "<p>Output : Least $t\\geq 0$ such that $x+tv$ intersects the boundary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Domain.contains_ball", "modulename": "agd.Domain", "qualname": "Domain.contains_ball", "kind": "function", "doc": "<p>Wether the domain contains the ball of center $x$ and radius $h$.\nApproximate predicate based on sampling, using ball_pattern.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">ball_pattern</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Domain.ball_pattern", "modulename": "agd.Domain", "qualname": "Domain.ball_pattern", "kind": "function", "doc": "<p>Produces a sampling pattern in a ball, to be used in the contains_ball predicate.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vdim</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">r</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Domain.vdim", "modulename": "agd.Domain", "qualname": "Domain.vdim", "kind": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.WholeSpace", "modulename": "agd.Domain", "qualname": "WholeSpace", "kind": "class", "doc": "<p>This class represents the full space $R^d$.</p>\n", "bases": "Domain"}, {"fullname": "agd.Domain.WholeSpace.level", "modulename": "agd.Domain", "qualname": "WholeSpace.level", "kind": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.WholeSpace.intervals", "modulename": "agd.Domain", "qualname": "WholeSpace.intervals", "kind": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Ball", "modulename": "agd.Domain", "qualname": "Ball", "kind": "class", "doc": "<p>This class represents a ball shaped domain.</p>\n\n<p>__init__ arguments : </p>\n\n<ul>\n<li>center (optional), array : the center of the ball.</li>\n<li>radius (optional), scalar : the radius of the ball.\nDefaults to defining the unit two-dimensional ball.</li>\n</ul>\n", "bases": "Domain"}, {"fullname": "agd.Domain.Ball.__init__", "modulename": "agd.Domain", "qualname": "Ball.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">)</span>, </span><span class=\"param\"><span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span>)</span>"}, {"fullname": "agd.Domain.Ball.center", "modulename": "agd.Domain", "qualname": "Ball.center", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Domain.Ball.radius", "modulename": "agd.Domain", "qualname": "Ball.radius", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Domain.Ball.vdim", "modulename": "agd.Domain", "qualname": "Ball.vdim", "kind": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.Ball.level", "modulename": "agd.Domain", "qualname": "Ball.level", "kind": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Ball.intervals", "modulename": "agd.Domain", "qualname": "Ball.intervals", "kind": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Box", "modulename": "agd.Domain", "qualname": "Box", "kind": "class", "doc": "<p>This class represents a box shaped domain in $R^k$, mathematically defined \nas the product\n$$\n        [a_1,b_1] \\times ... \\times [a_k,b_k]\n$$\nof some intervals. </p>\n\n<p>__init__ argument : </p>\n\n<ul>\n<li>sides (optional) : [[a1,b1], ..., [ak,bk]] the intervals defining the box.\nDefaults to defining the two dimensional unit square.</li>\n</ul>\n", "bases": "Domain"}, {"fullname": "agd.Domain.Box.__init__", "modulename": "agd.Domain", "qualname": "Box.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sides</span><span class=\"o\">=</span><span class=\"p\">((</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">))</span></span>)</span>"}, {"fullname": "agd.Domain.Box.sides", "modulename": "agd.Domain", "qualname": "Box.sides", "kind": "variable", "doc": "<p>The intervals $[[a_1,b_1], ..., [a_k,b_k]]$ defining the box.</p>\n"}, {"fullname": "agd.Domain.Box.center", "modulename": "agd.Domain", "qualname": "Box.center", "kind": "variable", "doc": "<p>The center $[ (a_1+b_1)/2, ..., (a_k+b_k)/2 ]$ of the box.</p>\n"}, {"fullname": "agd.Domain.Box.edgelengths", "modulename": "agd.Domain", "qualname": "Box.edgelengths", "kind": "variable", "doc": "<p>The edge lengths $[ b_1-a_1, ..., b_k-a_k ]$ of the box.</p>\n"}, {"fullname": "agd.Domain.Box.vdim", "modulename": "agd.Domain", "qualname": "Box.vdim", "kind": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.Box.level", "modulename": "agd.Domain", "qualname": "Box.level", "kind": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Box.intervals", "modulename": "agd.Domain", "qualname": "Box.intervals", "kind": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.AbsoluteComplement", "modulename": "agd.Domain", "qualname": "AbsoluteComplement", "kind": "class", "doc": "<p>This class represents the complement $R^d \\setminus \\Omega$, in the entire space,\n of a given domain $\\Omega\\subset R^d$.</p>\n\n<p>__init__ argument: </p>\n\n<ul>\n<li>dom : Domain of which to take the complement.</li>\n</ul>\n", "bases": "Domain"}, {"fullname": "agd.Domain.AbsoluteComplement.__init__", "modulename": "agd.Domain", "qualname": "AbsoluteComplement.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dom</span></span>)</span>"}, {"fullname": "agd.Domain.AbsoluteComplement.dom", "modulename": "agd.Domain", "qualname": "AbsoluteComplement.dom", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Domain.AbsoluteComplement.vdim", "modulename": "agd.Domain", "qualname": "AbsoluteComplement.vdim", "kind": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.AbsoluteComplement.contains", "modulename": "agd.Domain", "qualname": "AbsoluteComplement.contains", "kind": "function", "doc": "<p>Wether x lies inside the domain.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.AbsoluteComplement.level", "modulename": "agd.Domain", "qualname": "AbsoluteComplement.level", "kind": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.AbsoluteComplement.freeway", "modulename": "agd.Domain", "qualname": "AbsoluteComplement.freeway", "kind": "function", "doc": "<p>Output : Least $t\\geq 0$ such that $x+tv$ intersects the boundary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.AbsoluteComplement.intervals", "modulename": "agd.Domain", "qualname": "AbsoluteComplement.intervals", "kind": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Intersection", "modulename": "agd.Domain", "qualname": "Intersection", "kind": "class", "doc": "<p>This class represents an intersection of several subdomains.</p>\n\n<p>__init__ arguments : </p>\n\n<ul>\n<li>*doms : domains to intersect.</li>\n</ul>\n", "bases": "Domain"}, {"fullname": "agd.Domain.Intersection.__init__", "modulename": "agd.Domain", "qualname": "Intersection.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">doms</span></span>)</span>"}, {"fullname": "agd.Domain.Intersection.doms", "modulename": "agd.Domain", "qualname": "Intersection.doms", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Domain.Intersection.vdim", "modulename": "agd.Domain", "qualname": "Intersection.vdim", "kind": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.Intersection.contains", "modulename": "agd.Domain", "qualname": "Intersection.contains", "kind": "function", "doc": "<p>Wether x lies inside the domain.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Intersection.level", "modulename": "agd.Domain", "qualname": "Intersection.level", "kind": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Intersection.intervals", "modulename": "agd.Domain", "qualname": "Intersection.intervals", "kind": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Complement", "modulename": "agd.Domain", "qualname": "Complement", "kind": "function", "doc": "<p>Relative complement $\\Omega_1 \\setminus \\Omega_2$ of two given domains \n$\\Omega_1,\\Omega_2 \\subset R^d$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dom1</span>, </span><span class=\"param\"><span class=\"n\">dom2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Union", "modulename": "agd.Domain", "qualname": "Union", "kind": "function", "doc": "<p>Union of several domains.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">doms</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Band", "modulename": "agd.Domain", "qualname": "Band", "kind": "class", "doc": "<p>Defines a banded domain in space, in between two parallel hyperplanes.\n$$\n        l_b &lt; &lt; x,v> &lt; u_b,\n$$\nwhere $v \\in R^d$ is a direction, and $l_b,u_b$ are a lower bound and an upper bound.</p>\n\n<p>__init__ arguments : </p>\n\n<ul>\n<li>direction : array of shape $(d,)$, where $d$ is the ambient space dimension.</li>\n<li>bounds : $[l_b, u_b]$, the lower bound and upper bound.</li>\n</ul>\n", "bases": "Domain"}, {"fullname": "agd.Domain.Band.__init__", "modulename": "agd.Domain", "qualname": "Band.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">direction</span>, </span><span class=\"param\"><span class=\"n\">bounds</span></span>)</span>"}, {"fullname": "agd.Domain.Band.vdim", "modulename": "agd.Domain", "qualname": "Band.vdim", "kind": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.Band.level", "modulename": "agd.Domain", "qualname": "Band.level", "kind": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Band.intervals", "modulename": "agd.Domain", "qualname": "Band.intervals", "kind": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.ConvexPolygon", "modulename": "agd.Domain", "qualname": "ConvexPolygon", "kind": "function", "doc": "<p>Defines a two dimensional <em>convex</em> polygonal domain from its vertices.</p>\n\n<p>__init__ arguments :</p>\n\n<ul>\n<li>pts : array of shape (2,n). The polygon vertices, given in trigonometric order.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pts</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.AffineTransform", "modulename": "agd.Domain", "qualname": "AffineTransform", "kind": "class", "doc": "<p>Defines a domain which is the image of another domain\nby the affine transformation, \n$$\n        x' = A x + b\n$$</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li><code>mult</code> (optional) : the multiplier $A$, which is either a scalar or a matrix \nof shape $(d,d)$. (Defaults to the identity matrix.)</li>\n<li><code>shift</code> (optional) : the vector $b$. (Defaults to zero.)</li>\n<li><code>center</code> (optional) : reference point for the transformation. (Defaults to zero.)</li>\n</ul>\n", "bases": "Domain"}, {"fullname": "agd.Domain.AffineTransform.__init__", "modulename": "agd.Domain", "qualname": "AffineTransform.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dom</span>, </span><span class=\"param\"><span class=\"n\">mult</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">shift</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">center</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "agd.Domain.AffineTransform.dom", "modulename": "agd.Domain", "qualname": "AffineTransform.dom", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Domain.AffineTransform.vdim", "modulename": "agd.Domain", "qualname": "AffineTransform.vdim", "kind": "variable", "doc": "<p>Dimension of the embedding space</p>\n"}, {"fullname": "agd.Domain.AffineTransform.forward", "modulename": "agd.Domain", "qualname": "AffineTransform.forward", "kind": "function", "doc": "<p>Forward affine transformation, from the original domain to the transformed one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">linear</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.AffineTransform.reverse", "modulename": "agd.Domain", "qualname": "AffineTransform.reverse", "kind": "function", "doc": "<p>Reverse affine transformation, from the transformed domain to the original one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">linear</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.AffineTransform.contains", "modulename": "agd.Domain", "qualname": "AffineTransform.contains", "kind": "function", "doc": "<p>Wether x lies inside the domain.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.AffineTransform.level", "modulename": "agd.Domain", "qualname": "AffineTransform.level", "kind": "function", "doc": "<p>A level set function, negative inside the domain, positive outside.\nGuaranteed to be 1-Lipschitz.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.AffineTransform.intervals", "modulename": "agd.Domain", "qualname": "AffineTransform.intervals", "kind": "function", "doc": "<p>A union of disjoint intervals, sorted in increasing order, \n$$\n        ] a_0,b_0 [ \\cup ] a_1,b_1 [ \\cup ... \\cup ] a_{n-1},b_{n-1} [\n$$\nsuch that $x+t v$ lies in the domain iff $t$ lies on one of these intervals.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.AffineTransform.freeway", "modulename": "agd.Domain", "qualname": "AffineTransform.freeway", "kind": "function", "doc": "<p>Output : Least $t\\geq 0$ such that $x+tv$ intersects the boundary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Dirichlet", "modulename": "agd.Domain", "qualname": "Dirichlet", "kind": "class", "doc": "<p>Implements Dirichlet boundary conditions.\nWhen computing finite differences, values queried outside the domain interior\nare replaced with values obtained on the boundary along the given direction.</p>\n\n<p>__init__ arguments :</p>\n\n<ul>\n<li>domain: geometrical description of the domain </li>\n<li>value: a scalar or map yielding the value of the boundary conditions</li>\n<li>grid: the cartesian grid. Ex: np.array(np.meshgrid(aX,aY,indexing='ij')) for suitable aX,aY</li>\n</ul>\n\n<ul>\n<li>interior (optional): the points regarded as interior to the domain. </li>\n<li><p>interior_radius (optional): sets\n    interior = domain.contains_ball(interior_radius)</p></li>\n<li><p>grid_values (optional): placeholder values to be used on the grid.\n    Either an array of values, or a function</p></li>\n</ul>\n\n<p>member fields : </p>\n\n<ul>\n<li>interior : mask for the discretization grid points inside the domain.</li>\n</ul>\n"}, {"fullname": "agd.Domain.Dirichlet.__init__", "modulename": "agd.Domain", "qualname": "Dirichlet.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">domain</span>,</span><span class=\"param\">\t<span class=\"n\">value</span>,</span><span class=\"param\">\t<span class=\"n\">grid</span>,</span><span class=\"param\">\t<span class=\"n\">interior_radius</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">interior</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">grid_values</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span>)</span>"}, {"fullname": "agd.Domain.Dirichlet.domain", "modulename": "agd.Domain", "qualname": "Dirichlet.domain", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Domain.Dirichlet.grid", "modulename": "agd.Domain", "qualname": "Dirichlet.grid", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Domain.Dirichlet.gridscale", "modulename": "agd.Domain", "qualname": "Dirichlet.gridscale", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Domain.Dirichlet.shape", "modulename": "agd.Domain", "qualname": "Dirichlet.shape", "kind": "variable", "doc": "<p>The shape of the domain (discretization grid).</p>\n"}, {"fullname": "agd.Domain.Dirichlet.vdim", "modulename": "agd.Domain", "qualname": "Dirichlet.vdim", "kind": "variable", "doc": "<p>The dimension of the vector space containing the domain.</p>\n"}, {"fullname": "agd.Domain.Dirichlet.as_field", "modulename": "agd.Domain", "qualname": "Dirichlet.as_field", "kind": "function", "doc": "<p>Adds trailing dimensions, and broadcasts arr, if necessary,\nso that the shape ends with the domain shape.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Dirichlet.not_interior", "modulename": "agd.Domain", "qualname": "Dirichlet.not_interior", "kind": "variable", "doc": "<p>Mask for the grid points outside the domain.</p>\n"}, {"fullname": "agd.Domain.Dirichlet.Mock", "modulename": "agd.Domain", "qualname": "Dirichlet.Mock", "kind": "variable", "doc": "<p>Returns mock Dirichlet boundary conditions obtained by evaluating \nthe boundary condition outside the interior.</p>\n"}, {"fullname": "agd.Domain.Dirichlet.DiffUpwind", "modulename": "agd.Domain", "qualname": "Dirichlet.DiffUpwind", "kind": "function", "doc": "<p>First order upwind finite differences of u, along the offsets direction. \nUses boundary values when needed.\nInput : </p>\n\n<ul>\n<li>u : array with the domain shape.</li>\n<li>offsets :  array of integers, with shape \n(vdim, n1,...,nk) or (vdim, n1,...,nk, shape) \nwhere vdim,shape is the ambient space dimension and domain shape, \nand n1,...,nk are arbitrary.</li>\n<li>reth (optional) : wether to return the grid scale used (differs from the \ngrid scale on the neighborhood of the boundary).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offsets</span>, </span><span class=\"param\"><span class=\"n\">reth</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Dirichlet.DiffCentered", "modulename": "agd.Domain", "qualname": "Dirichlet.DiffCentered", "kind": "function", "doc": "<p>Centered finite differences of u, along the offsets direction, \ncomputed using the second order accurate centered scheme.\nFalls back to upwind finite differences close to the boundary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offsets</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.Dirichlet.Diff2", "modulename": "agd.Domain", "qualname": "Dirichlet.Diff2", "kind": "function", "doc": "<p>Second order finite differences of u, along the offsets direction.\nSecond order accurate in the interior, \nbut only first order accurate at the boundary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offsets</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.MockDirichlet", "modulename": "agd.Domain", "qualname": "MockDirichlet", "kind": "class", "doc": "<p>Implements a crude version of Dirichlet boundary conditions, \nwhere the boundary conditions are given on the full domain complement.</p>\n\n<p>(No geometrical computations involved.)</p>\n\n<p>__init__ arguments : </p>\n\n<ul>\n<li>grid_values : the Dirichlet boundary conditions. \nPlease set to np.nan the values interior to domain.</li>\n<li>gridscale : the discretization grid scale.</li>\n<li>padding : the padding values to be used outside the discretization grid.</li>\n</ul>\n"}, {"fullname": "agd.Domain.MockDirichlet.__init__", "modulename": "agd.Domain", "qualname": "MockDirichlet.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">grid_values</span>, </span><span class=\"param\"><span class=\"n\">gridscale</span>, </span><span class=\"param\"><span class=\"n\">padding</span><span class=\"o\">=</span><span class=\"n\">nan</span></span>)</span>"}, {"fullname": "agd.Domain.MockDirichlet.grid_values", "modulename": "agd.Domain", "qualname": "MockDirichlet.grid_values", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Domain.MockDirichlet.gridscale", "modulename": "agd.Domain", "qualname": "MockDirichlet.gridscale", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Domain.MockDirichlet.padding", "modulename": "agd.Domain", "qualname": "MockDirichlet.padding", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Domain.MockDirichlet.interior", "modulename": "agd.Domain", "qualname": "MockDirichlet.interior", "kind": "variable", "doc": "<p>The discretization grid points inside the domain.</p>\n"}, {"fullname": "agd.Domain.MockDirichlet.not_interior", "modulename": "agd.Domain", "qualname": "MockDirichlet.not_interior", "kind": "variable", "doc": "<p>The discretization grid points outside the domain.</p>\n"}, {"fullname": "agd.Domain.MockDirichlet.vdim", "modulename": "agd.Domain", "qualname": "MockDirichlet.vdim", "kind": "variable", "doc": "<p>The dimension of the vector space containing the domain.</p>\n"}, {"fullname": "agd.Domain.MockDirichlet.shape", "modulename": "agd.Domain", "qualname": "MockDirichlet.shape", "kind": "variable", "doc": "<p>The shape of the domain discretization grid.</p>\n"}, {"fullname": "agd.Domain.MockDirichlet.as_field", "modulename": "agd.Domain", "qualname": "MockDirichlet.as_field", "kind": "function", "doc": "<p>Adds trailing dimensions, and broadcasts arr, if necessary,\nso that the shape ends with the discretization grid shape.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.MockDirichlet.DiffUpwind", "modulename": "agd.Domain", "qualname": "MockDirichlet.DiffUpwind", "kind": "function", "doc": "<p>First order upwind finite differences of u, along the offsets direction. \nUses grid_values outside the domain interior.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offsets</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.MockDirichlet.DiffCentered", "modulename": "agd.Domain", "qualname": "MockDirichlet.DiffCentered", "kind": "function", "doc": "<p>First order centered finite differences of u, along the offsets direction. \nUses grid_values outside the domain interior.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offsets</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Domain.MockDirichlet.Diff2", "modulename": "agd.Domain", "qualname": "MockDirichlet.Diff2", "kind": "function", "doc": "<p>Second order order finite differences of u, along the offsets direction. \nUses grid_values outside the domain interior.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offsets</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal", "modulename": "agd.Eikonal", "kind": "module", "doc": "<p>The Eikonal package embeds CPU and GPU numerical solvers of (generalized) eikonal \nequations. These are variants of the fast marching and fast sweeping method, based on \nsuitable discretizations of the PDE, and written and C++.</p>\n\n<p>Please see the illustrative notebooks for detailed usage instructions and examples:\n<a href=\"https://github.com/Mirebeau/AdaptiveGridDiscretizations\">https://github.com/Mirebeau/AdaptiveGridDiscretizations</a></p>\n\n<p>Main object : </p>\n\n<ul>\n<li>dictIn : a dictionary-like structure, used to gathers the arguments of the \neikonal solver, and eventually call it.</li>\n</ul>\n"}, {"fullname": "agd.Eikonal.VoronoiDecomposition", "modulename": "agd.Eikonal", "qualname": "VoronoiDecomposition", "kind": "function", "doc": "<p>Voronoi decomposition of arr, an array of dxd symmetric positive definite matrices, \nwith shape (d,d,n1,...nk), and possibly with AD.\nargs,kwargs : see _VoronoiDecomposition_noAD</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn", "modulename": "agd.Eikonal.DictIn", "kind": "module", "doc": "<p>The Eikonal.dictIn class is used to hold the input parameters to the eikonal solvers of \nthe HFM library, CPU based or GPU based.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.SEModels", "modulename": "agd.Eikonal.DictIn", "qualname": "SEModels", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;ReedsSheppExt2&#x27;, &#x27;ReedsShepp3&#x27;, &#x27;ConvexDubins2&#x27;, &#x27;ReedsShepp2&#x27;, &#x27;Elastica2&#x27;, &#x27;ConvexElastica2&#x27;, &#x27;Dubins2&#x27;, &#x27;ElasticaExt2&#x27;, &#x27;ReedsSheppForward2&#x27;, &#x27;ConvexReedsSheppForward2&#x27;, &#x27;ReedsSheppForwardExt2&#x27;, &#x27;DubinsExt2&#x27;, &#x27;ReedsSheppForward3&#x27;, &#x27;ElasticaExt2_5&#x27;}"}, {"fullname": "agd.Eikonal.DictIn.dimModels", "modulename": "agd.Eikonal.DictIn", "qualname": "dimModels", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;ElasticaExt2_5&#x27;: 3, &#x27;Riemann3_Periodic&#x27;: 3, &#x27;ReedsSheppGPU3&#x27;: 5}"}, {"fullname": "agd.Eikonal.DictIn.dictOut", "modulename": "agd.Eikonal.DictIn", "qualname": "dictOut", "kind": "class", "doc": "<p>A dictionnary like structure used as output of the Eikonal solvers.</p>\n", "bases": "collections.abc.MutableMapping"}, {"fullname": "agd.Eikonal.DictIn.dictOut.__init__", "modulename": "agd.Eikonal.DictIn", "qualname": "dictOut.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">store</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "agd.Eikonal.DictIn.dictOut.store", "modulename": "agd.Eikonal.DictIn", "qualname": "dictOut.store", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictOut.copy", "modulename": "agd.Eikonal.DictIn", "qualname": "dictOut.copy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictOut.keys", "modulename": "agd.Eikonal.DictIn", "qualname": "dictOut.keys", "kind": "function", "doc": "<p>The keys of the dictionary-like structure.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.CenteredLinspace", "modulename": "agd.Eikonal.DictIn", "qualname": "CenteredLinspace", "kind": "function", "doc": "<p>Returns a linspace shifted by half a node length.\nInputs : </p>\n\n<ul>\n<li>a,b : interval endpoints</li>\n<li>n : number of points</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn", "kind": "class", "doc": "<p>A dictionary like structure used as input of the Eikonal solvers.</p>\n\n<p>__init__ arguments: </p>\n\n<ul>\n<li>store : a dictionary, used for initialization.</li>\n</ul>\n\n<p>See dictIn().RunHelp() for details on the eikonal solver inputs.</p>\n", "bases": "collections.abc.MutableMapping"}, {"fullname": "agd.Eikonal.DictIn.dictIn.__init__", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">store</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "agd.Eikonal.DictIn.dictIn.default_mode", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.default_mode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;cpu&#x27;"}, {"fullname": "agd.Eikonal.DictIn.dictIn.store", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.store", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.copy", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.copy", "kind": "function", "doc": "<p>Returns a shallow copy of the structure.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.mode", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.mode", "kind": "variable", "doc": "<p>The running mode of the eikonal solver, see the Run method.\nThe input data must be provided using a compatible array module: \nnumpy in 'cpu' mode, cupy in 'gpu' mode.</p>\n\n<p>Supported running mode for the eikonal solver : </p>\n\n<ul>\n<li>'cpu' : Run algorithm on host, store data on host</li>\n<li>'cpu_transfer' : Run algorithm on host, store data on device</li>\n<li>'cpu_raw' : Raw call to the HFM CPU library (debug purposes)</li>\n<li>'gpu' : Run algorithm on device, store data on device</li>\n<li>'gpu_transfer' : Run algorithm on device, store data on host</li>\n</ul>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.float_t", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.float_t", "kind": "variable", "doc": "<p>The floating point type of the data arrays. Typically np.float64 in 'cpu' mode, \nand np.float32 in 'gpu' mode.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.keys", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.keys", "kind": "function", "doc": "<p>The keys of this dictionary structure.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.RunHelp", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.RunHelp", "kind": "function", "doc": "<p>Help on the eikonal solver, depending on the running mode.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.Run", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.Run", "kind": "function", "doc": "<p>Calls the HFM library, prints log and returns output.\nInputs : </p>\n\n<ul>\n<li>join (optional) : join the dictionary with these additional entries before running.</li>\n<li>**kwargs (optional) : passed to the run_detail.RunSmart or HFM_CUDA.RunGPU methods.</li>\n</ul>\n\n<p>See dictIn().RunHelp() for additional details, depending on the running mode.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">join</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.shape", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.shape", "kind": "variable", "doc": "<p>The shape of the discretization grid.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.size", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.size", "kind": "variable", "doc": "<p>The number of points in the discretization grid.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.SE", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.SE", "kind": "variable", "doc": "<p>Wether the model is based on the Special Euclidean group.\nTrue for curvature penalized models.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.vdim", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.vdim", "kind": "variable", "doc": "<p>The dimension of the ambient vector space.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.nTheta", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.nTheta", "kind": "variable", "doc": "<p>Number of points for discretizing the interval [0,2 pi], in the angular space \ndiscretization, for the SE models (a.k.a. curvature penalized models).</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.gridScales", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.gridScales", "kind": "variable", "doc": "<p>The discretization grid scale along each axis.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.corners", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.corners", "kind": "variable", "doc": "<p>Returns the extreme points grid[:,0,...,0] and grid[:,-1,...,-1] of the \ndiscretization grid.</p>\n"}, {"fullname": "agd.Eikonal.DictIn.dictIn.Axes", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.Axes", "kind": "function", "doc": "<p>The discretization points used along each coordinate axis.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dims</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.Grid", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.Grid", "kind": "function", "doc": "<p>Returns a grid of coordinates, containing all the discretization points of the domain.\nSimilar to np.meshgrid(*self.Axes(),indexing='ij')\nInputs : </p>\n\n<ul>\n<li>dims(optional) : use a different sampling of the domain</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dims</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.SetUniformTips", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.SetUniformTips", "kind": "function", "doc": "<p>Place regularly spaced tip points all over the domain, \nfrom which to backtrack minimal geodesics.\nInputs : </p>\n\n<ul>\n<li>dims : number of tips to use along each dimension.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dims</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.SetRect", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.SetRect", "kind": "function", "doc": "<p>Defines a box domain, for the HFM library.\nInputs:</p>\n\n<ul>\n<li>sides, e.g. ((a,b),(c,d),(e,f)) for the domain [a,b]x[c,d]x[e,f]</li>\n<li>sampleBoundary : switch between sampling at the pixel centers, and sampling including the boundary</li>\n<li>gridScale, gridScales : side h>0 of each pixel (alt : axis dependent)</li>\n<li>dimx, dims : number of points along the first axis (alt : along all axes)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">sides</span>,</span><span class=\"param\">\t<span class=\"n\">sampleBoundary</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">gridScale</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">gridScales</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dimx</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dims</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.PointFromIndex", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.PointFromIndex", "kind": "function", "doc": "<p>Turns an index into a point.\nOptional argument to: if true, inverse transformation, turning a point into a continuous index</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index</span>, </span><span class=\"param\"><span class=\"n\">to</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.IndexFromPoint", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.IndexFromPoint", "kind": "function", "doc": "<p>Returns the index that yields the position closest to a point, and the error.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">point</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.OrientedPoints", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.OrientedPoints", "kind": "function", "doc": "<p>Appends all possible orientations to the point coordinates.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pointU</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.VectorFromOffset", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.VectorFromOffset", "kind": "function", "doc": "<p>Turns a finite difference offset into a vector, by multiplying by the gridScale.\nInputs : </p>\n\n<ul>\n<li>offset : the offset to convert.</li>\n<li>to (optional) : if True, produces an offset from a vector (reverse operation).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">offset</span>, </span><span class=\"param\"><span class=\"n\">to</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.GridNeighbors", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.GridNeighbors", "kind": "function", "doc": "<p>Returns the neighbors around a point on the grid. \nGeometry last convention\nInputs: </p>\n\n<ul>\n<li>point (array): geometry last</li>\n<li>gridRadius (scalar): given in pixels</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">point</span>, </span><span class=\"param\"><span class=\"n\">gridRadius</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.SetFactor", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.SetFactor", "kind": "function", "doc": "<p>This function setups additive factorization around the seeds.\nInputs (optional): </p>\n\n<ul>\n<li>radius.\nPositive number -> approximate radius, in pixels, of source factorization.\n-1 -> Factorization over all the domain. \nNone -> source factorization over all the domain</li>\n<li>value (optional).\ncallable, array -> approximate values of the solution. \nNone -> reconstructed from the metric.</li>\n<li>gradient (optional) \ncallable, array -> approximate gradient of the solution.\nObtained from the values by automatic differentiation if unspecified.</li>\n</ul>\n\n<p>Outputs : the subgrid used for factorization\nSide effect : sets 'factoringValues', 'factoringGradients', \n   and in the case of a subgrid 'factoringIndexShift'</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">gradient</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.SetSphere", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.SetSphere", "kind": "function", "doc": "<p>Setups the manifold R^(d-k) x S^k, using the equatorial projection for the sphere S^k.\nOnly compatible with the GPU accelerated eikonal solver. \nInputs : \n        dimsp (int): the discretization of a half sphere involves dimsp^k pixels.\n        radius (optional, float &gt; 1): each local chart has base domain [-radius,radius]^k.\n          (This is NOT the radius of the sphere, which is 1, but of the parametrization.)\n        separation (optional, int) : number of pixels separating the two local charts.\n                Set to false to define a projective space using a single chart. \nSide effects : \n        Sets chart_mapping,chart_jump, dimensions, origin, gridScales.\nOutput : \n        - Conversion utilities, between the equatorial plane and the sphere \n                (and grid in the non-projective case)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dimsp</span>, </span><span class=\"param\"><span class=\"n\">separation</span><span class=\"o\">=</span><span class=\"mi\">5</span>, </span><span class=\"param\"><span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"mf\">1.1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn.dictIn.factoringPointChoice", "modulename": "agd.Eikonal.DictIn", "qualname": "dictIn.factoringPointChoice", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.DictIn_detail", "modulename": "agd.Eikonal.DictIn_detail", "kind": "module", "doc": "<p>This file implements additional functionality of the Eikonal.dictIn class, related to \nsource factorization, and to solving PDEs on spheres.</p>\n"}, {"fullname": "agd.Eikonal.DictIn_detail.factoringPointChoice", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "factoringPointChoice", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn_detail.SetFactor", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "SetFactor", "kind": "function", "doc": "<p>This function setups additive factorization around the seeds.\nInputs (optional): </p>\n\n<ul>\n<li>radius.\nPositive number -> approximate radius, in pixels, of source factorization.\n-1 -> Factorization over all the domain. \nNone -> source factorization over all the domain</li>\n<li>value (optional).\ncallable, array -> approximate values of the solution. \nNone -> reconstructed from the metric.</li>\n<li>gradient (optional) \ncallable, array -> approximate gradient of the solution.\nObtained from the values by automatic differentiation if unspecified.</li>\n</ul>\n\n<p>Outputs : the subgrid used for factorization\nSide effect : sets 'factoringValues', 'factoringGradients', \n   and in the case of a subgrid 'factoringIndexShift'</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">gradient</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn_detail.proj_tosphere", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "proj_tosphere", "kind": "function", "doc": "<p>Maps a point of the equatorial plane to the sphere, by projection : \nx -> (2 x,1-|x\u220f^2)/(1+|x|^2)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn_detail.proj_fromsphere", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "proj_fromsphere", "kind": "function", "doc": "<p>Maps a point of the sphere to the equatorial plane, by projection.\n(q,qz) -> q/(1+qz)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">q</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn_detail.sphere_tosphere", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "sphere_tosphere", "kind": "function", "doc": "<p>See proj_tosphere. Last component is reversed according to chart.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">chart</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn_detail.sphere_fromsphere", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "sphere_fromsphere", "kind": "function", "doc": "<p>See proj_fromsphere. Last component of q is reversed according to chart.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">chart</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.DictIn_detail.SetSphere", "modulename": "agd.Eikonal.DictIn_detail", "qualname": "SetSphere", "kind": "function", "doc": "<p>Setups the manifold R^(d-k) x S^k, using the equatorial projection for the sphere S^k.\nOnly compatible with the GPU accelerated eikonal solver. \nInputs : \n        dimsp (int): the discretization of a half sphere involves dimsp^k pixels.\n        radius (optional, float &gt; 1): each local chart has base domain [-radius,radius]^k.\n          (This is NOT the radius of the sphere, which is 1, but of the parametrization.)\n        separation (optional, int) : number of pixels separating the two local charts.\n                Set to false to define a projective space using a single chart. \nSide effects : \n        Sets chart_mapping,chart_jump, dimensions, origin, gridScales.\nOutput : \n        - Conversion utilities, between the equatorial plane and the sphere \n                (and grid in the non-projective case)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dimsp</span>, </span><span class=\"param\"><span class=\"n\">separation</span><span class=\"o\">=</span><span class=\"mi\">5</span>, </span><span class=\"param\"><span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"mf\">1.1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.FileIO", "modulename": "agd.Eikonal.FileIO", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.FileIO.RawToFiles", "modulename": "agd.Eikonal.FileIO", "qualname": "RawToFiles", "kind": "function", "doc": "<p>Exports a dictionary to a pair of files, whose name begins with 'prefix'.\nThe dictionnary elements must by strings, scalars, and numpy arrays.\nThe resulting files are readable by the HFM library.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">params</span>, </span><span class=\"param\"><span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;input&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.FileIO.FilesToRaw", "modulename": "agd.Eikonal.FileIO", "qualname": "FilesToRaw", "kind": "function", "doc": "<p>Imports a pair of files, whose name begins with 'prefix', into a dictionary.\nThese files may be produced by the HFM library.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;output&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.FileIO.WriteCallRead", "modulename": "agd.Eikonal.FileIO", "qualname": "WriteCallRead", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">inputData</span>,</span><span class=\"param\">\t<span class=\"n\">executable</span>,</span><span class=\"param\">\t<span class=\"n\">binary_dir</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">working_dir</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">inputPrefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;input&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">outputPrefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;output&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA", "modulename": "agd.Eikonal.HFM_CUDA", "kind": "module", "doc": "<p>This package is implementation detail for a GPU accelerated eikonal solver. It should \nnot be used directly, but through the parent package. (Run method of the dictIn class,\nwith mode='gpu'.)</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.RunGPU", "modulename": "agd.Eikonal.HFM_CUDA", "qualname": "RunGPU", "kind": "function", "doc": "<p>Runs the GPU eikonal solver.</p>\n\n<p>Main input:</p>\n\n<ul>\n<li>hfmIn : a dictionary like-structure</li>\n</ul>\n\n<p>The solver embeds some help information, which can be accessed as follows.</p>\n\n<ul>\n<li>set hfmIn['verbosity'] to 1 or 2 to display information on run, including the defaulted keys.\nset to 0 to silence the run.</li>\n<li>look at hfmOut['keys']['help'] to see a basic help regarding each key,\nwhere hfmOut is the output of this function.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hfmIn</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">cache</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.EikonalGPU_NotImplementedError", "modulename": "agd.Eikonal.HFM_CUDA", "qualname": "EikonalGPU_NotImplementedError", "kind": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n", "bases": "builtins.Exception"}, {"fullname": "agd.Eikonal.HFM_CUDA.EikonalGPU_NotImplementedError.__init__", "modulename": "agd.Eikonal.HFM_CUDA", "qualname": "EikonalGPU_NotImplementedError.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">message</span></span>)</span>"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "kind": "module", "doc": "<p>This file implements the linear acoustic and elastic wave equations, using custom \nGPU kernels for efficiency. A reference implementation using sparse matrices is provided \nfor completeness.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.rm_ad", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "rm_ad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">iterables</span><span class=\"o\">=</span><span class=\"p\">()</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.bc_to_padding", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "bc_to_padding", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;Periodic&#x27;: None, &#x27;Neumann&#x27;: nan, &#x27;Dirichlet&#x27;: 0}"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Sparse", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Sparse", "kind": "function", "doc": "<p>Sparse matrix based implementation of the Hamiltonian of the acoustic wave equation,\nnamely : \n$$\n        \\frac 1 2 \\int_X \\frac {p^2} \u03c1 + &lt;\\nabla q,D,\\nabla q> dx\n$$</p>\n\n<ul>\n<li>\u03c1 : density. Array of shape (n1,...,nd) or just a scalar</li>\n<li>D : dual-metric. Array of shape (d,d,n1,...,nd) or just (d,d)</li>\n<li>dx (optional) : grid scale.</li>\n<li>order_x (optional) : consistency order of the scheme, in space.</li>\n<li>shape_dom (optional) : shape (n1,...,nd) of the domain (usually inferred from \u03c1,D) </li>\n<li>bc : boundary conditions, see bc_to_padding.keys()</li>\n<li>rev_ad (optional) : Implement reverse autodiff for the decomposition weights and inverse density</li>\n<li>save_weights : save the weights of the Selling decomposition of D, accessible as .weights field</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">\u03c1</span>,</span><span class=\"param\">\t<span class=\"n\">D</span>,</span><span class=\"param\">\t<span class=\"n\">dx</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">order_x</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">shape_dom</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bc</span><span class=\"o\">=</span><span class=\"s1\">&#39;Periodic&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">rev_ad</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">save_weights</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Sparse", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Sparse", "kind": "function", "doc": "<p>Sparse matrix based implementation of the Hamiltonian of the elastic wave equation, namely\n$$\n        \\frac 1 2 \\int_X &lt; p,M,p &gt; + &lt;\u03b5,C,\u03b5&gt; dx,\n$$\n        where X is the domain, and the strain tensor is defined by \n$$\n        2 \u03b5 = \\nabla q + \\nabla q^T - S q.\n$$</p>\n\n<ul>\n<li>M : (metric) array of positive definite matrices, shape (d,d,n1,...,nd),\nAlso accepts (1,1,n1,...,nd) for isotropic metric. Ex: M = (1/\u03c1)[None,None]</li>\n<li>C : (hooke tensor in voigt notation) array of positive definite matrices,\nshape (s,s,n1,...,nd) where s = d (d+1)/2</li>\n<li>dx (optional) : grid scale.</li>\n<li>order_x (optional) : consistency order of the scheme, in space.</li>\n<li>S (optional) : see strain tensor expression, array of shape (d,d,d,n1,...,nd)</li>\n<li>shape_dom (optional) : shape (n1,...,nd), usually inferred from other parameters.</li>\n<li>bc : boundary conditions, see bc_to_padding.keys()</li>\n<li>rev_ad (optional) : Implement reverse autodiff for the decomposition weights and M.</li>\n<li>save_weights (optional) : save the weights of the Hooke tensor decomposition, as a \nfield of the Hamiltonian.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">M</span>,</span><span class=\"param\">\t<span class=\"n\">C</span>,</span><span class=\"param\">\t<span class=\"n\">dx</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">order_x</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">S</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">shape_dom</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bc</span><span class=\"o\">=</span><span class=\"s1\">&#39;Periodic&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">rev_ad</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">save_weights</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticChgVar", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticChgVar", "kind": "function", "doc": "<p>Change of variables in the acoustic wave equation.</p>\n\n<ul>\n<li>q,p,\u03c1,D (callable) : problem data</li>\n<li>\u03d5 : change of variables</li>\n<li>X : points where to evaluate \nreturns</li>\n<li>tq,tp,t\u03c1,tD,\u03d5(X) (arrays) : coordinate changed problem data, obtained as \n$$\nq(\u03d5), p(\u03d5) J, \u03c1(\u03d5) J, \u03a6^{-1} D(\u03d5) \u03a6^{-T} J.\n$$</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03c1</span>, </span><span class=\"param\"><span class=\"n\">D</span>, </span><span class=\"param\"><span class=\"n\">\u03c6</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticChgVar", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticChgVar", "kind": "function", "doc": "<p>Change of variables in the elastic wave equation.</p>\n\n<ul>\n<li>q,p,M,C,S (callable) : problem data</li>\n<li>\u03d5 (callable) : change of variables</li>\n<li>X : points where to evaluate\nreturns</li>\n<li>tq,tp,tM,tC,tS,\u03d5(X) (arrays) : coordinate changed problem data, obtained as \n$$\n\u03a6^t q(\u03d5), \u03a6^{-1} p(\u03d5) J, \u03a6^t M(\u03d5) \u03a6 / J, (\u03a6^t \u03b5(\u03d5) \u03a6,)\n$$\n$$\n\u2211_{i'j'k'l'} C_{i'j'k'l'}(\u03d5) \u03a8^{i'}_i \u03a8^{j'}_j \u03a8^{k'}_k \u03a8^{l'}_l  J,\n$$\n$$\n\u2211_{i'j'} \u03a6^i_{i'} \u03a6^j_{j'} S^{i'j'}_{k'}(\u03d5) \u03a8_k^{k'} + \u2211_{k'} \u2202^{ij} \u03d5_{k'} \u03a8_k^{k'}.\n$$</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">M</span>, </span><span class=\"param\"><span class=\"n\">C</span>, </span><span class=\"param\"><span class=\"n\">S</span>, </span><span class=\"param\"><span class=\"n\">\u03c6</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel", "kind": "class", "doc": "<p>The Hamiltonian of an anisotropic acoustic wave equation, implemented with GPU kernels,\nwhose geometry is defined by a generic Riemannianian (dual-)metric field.\nThe Hamiltonian is a sum of squares of finite differences, via Selling's decomposition.</p>\n\n<p>The Mathematical expression of the Hamiltonian is \n$$\n\\frac 1 2 \\int_X \\frac {p^2} \u03c1 + &lt;\\nabla q,D,\\nabla q> dx\n$$\nwhere X is the domain, and D the is the (dual-)metric.</p>\n\n<ul>\n<li>\u03c1 : density. Array of shape (n1,...,nd) or just a scalar</li>\n<li>D : dual-metric. Array of shape (d,d,n1,...,nd) or just (d,d)</li>\n<li>dx (optional) : grid scale.</li>\n<li>order_x (optional) : consistency order of the scheme, in space.</li>\n<li>shape_dom (optional) : shape (n1,...,nd) of the domain (usually inferred from \u03c1,D)</li>\n<li>rev_ad (optional) : Number of channels for reverse autodiff of the decomposition weights and inverse density</li>\n<li>block_size (optional) : number of threads per GPU block.</li>\n<li>save_weights (optional) : save the weights and offsets of Selling's decomposition of D.</li>\n</ul>\n", "bases": "agd.ODE.hamiltonian.QuadraticHamiltonianBase"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.__init__", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">\u03c1</span>,</span><span class=\"param\">\t<span class=\"n\">D</span>,</span><span class=\"param\">\t<span class=\"n\">dx</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">order_x</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">shape_dom</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bc</span><span class=\"o\">=</span><span class=\"s1\">&#39;Periodic&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">flattened</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">rev_ad</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">i\u03c1</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">256</span>,</span><span class=\"param\">\t<span class=\"n\">traits</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">save_weights</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.shape_free", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.shape_free", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.dx", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.dx", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.i\u03c1", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.i\u03c1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.dt_max", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.dt_max", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.M", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.M", "kind": "variable", "doc": "<p>Alias for the inverse density</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.weights", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.weights", "kind": "variable", "doc": "<p>The weights of Selling's decomposition of D.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.size_ad", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.size_ad", "kind": "variable", "doc": "<p>Number of automatic differentiation components, for forward or reverse AD</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.way_ad", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.way_ad", "kind": "variable", "doc": "<p>0 : no AD. 1 : forward AD. -1 : reverse AD</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.rev_reset", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.rev_reset", "kind": "function", "doc": "<p>Reset the accumulators for reverse autodiff \nNamely (self.metric.coef and self.weights.coef)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.shape_dom", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.shape_dom", "kind": "variable", "doc": "<p>Shape of the PDE discretization domain.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.ndim", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.ndim", "kind": "variable", "doc": "<p>Number of dimensions of the domain.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.decompdim", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.decompdim", "kind": "variable", "doc": "<p>Length of quadratic form decomposition.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.traits", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.traits", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.int_t", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.int_t", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.float_t", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.float_t", "kind": "variable", "doc": "<p>Floating point type used by the GPU</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.order_x", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.order_x", "kind": "variable", "doc": "<p>Spatial consistency order of the finite differences scheme</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.Expl_p", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.Expl_p", "kind": "function", "doc": "<p>Explicit time step for the impulsion p.\nExpects : q and p reshaped in GPU friendly format, using self.reshape</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.Expl_q", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.Expl_q", "kind": "function", "doc": "<p>Explicit time step for the position q.\nExpects : q and p reshaped in GPU friendly format, using self.reshape</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.check_ad", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.check_ad", "kind": "function", "doc": "<p>Puts zero ad coefficients, with the correct c-contiguity, if those are empty.\nBasic additional checks of shapes, contiguity.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel.check", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "AcousticHamiltonian_Kernel.check", "kind": "function", "doc": "<p>Basic check of the types, shapes, contiguity of GPU inputs.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase", "kind": "class", "doc": "<p>A base class for GPU implementations of Hamiltonians of wave equations.\nWarning : position and impulsion arrays are padded and reshaped in a GPU friendly format.\n__init__ arguments </p>\n\n<ul>\n<li>constant values : default padding in the reshape function</li>\n</ul>\n", "bases": "agd.ODE.hamiltonian.QuadraticHamiltonianBase"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.__init__", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape_dom</span>, </span><span class=\"param\"><span class=\"n\">traits</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">periodic</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">constant_values</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.constant_values", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.constant_values", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.shape_dom", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.shape_dom", "kind": "variable", "doc": "<p>Shape of the PDE discretization domain.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.shape_o", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.shape_o", "kind": "variable", "doc": "<p>Outer shape : number of blocks in each dimension (for GPU kernels).</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.shape_i", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.shape_i", "kind": "variable", "doc": "<p>Inner shape : accessed by a block of threads (for GPU kernels).</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.size_o", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.size_o", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.size_i", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.size_i", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.ndim", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.ndim", "kind": "variable", "doc": "<p>Number of dimensions of the domain.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.symdim", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.symdim", "kind": "variable", "doc": "<p>DImension of the space of symmetric matrices.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.traits", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.traits", "kind": "variable", "doc": "<p>Collection of traits, passed to GPU kernel.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.float_t", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.float_t", "kind": "variable", "doc": "<p>Scalar type used by the GPU kernel. Defaults to float32.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.int_t", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.int_t", "kind": "variable", "doc": "<p>Int type used by the GPU kernel. Defaults to int32.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.order_x", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.order_x", "kind": "variable", "doc": "<p>Consistency order of the finite differences scheme.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.periodic", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.periodic", "kind": "variable", "doc": "<p>Wether to apply periodic boundary conditions, for each axis.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.SetCst", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.SetCst", "kind": "function", "doc": "<p>Set a constant in the cuda module</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">dtype</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.reshape", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.reshape", "kind": "function", "doc": "<p>Reshapes and pads the array x in a kernel friendly format.\nFactors shape_i. Also moves the geometry axis before\nshape_i, following the convention of HookeWave.h</p>\n\n<ul>\n<li>**kwargs : passed to fd.block_expand</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">constant_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonianBase.unshape", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonianBase.unshape", "kind": "function", "doc": "<p>Inverse operation to reshape</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">value</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel", "kind": "class", "doc": "<p>The Hamiltonian of an anisotropic elastic wave equation, implemented with GPU kernels,\nwhose geometry is defined by a generic Hooke tensor field.\nThe Hamiltonian is a sum of squares of finite differences, via Voronoi's decomposition.\nDirichlet boundary conditions are applied, see also optional damping layers.</p>\n\n<p>The Mathematical expression of the Hamiltonian is \n$$\n        \\frac 1 2 \\int_X &lt; p,M,p &gt; + &lt;\u03b5,C,\u03b5&gt; dx,\n$$\nwhere X is the domain, and the strain tensor is defined by\n$$ \n        2 \u03b5 = \\nabla q + \\nabla q^T.\n$$</p>\n\n<ul>\n<li>M : (metric) array of positive definite matrices, shape (d,d,n1,...,nd),\nAlso accepts (1,1,n1,...,nd) for isotropic metric. Ex: M = (1/\u03c1)[None,None]</li>\n<li>C : (hooke tensor in voigt notation) array of positive definite matrices,\nshape (s,s,n1,...,nd) where s = d (d+1)/2\nReuse decomposition from previous run : C = H_prev.C_for_reuse</li>\n<li>dx (optional) : grid scale.</li>\n<li>order_x (optional) : consistency order of the scheme, in space.</li>\n<li>shape_dom (optional) : shape (n1,...,nd), usually inferred from other parameters.</li>\n<li>rev_ad (optional) : Implement reverse autodiff for the decomposition weights and M.</li>\n<li>kwargs : passed to WaveHamiltonianBase</li>\n</ul>\n\n<p>Warning : accessing some of this object's properties has a significant memory and \ncomputational cost, because all data is reshaped and padded in a GPU kernel friendly format.</p>\n", "bases": "WaveHamiltonianBase"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.__init__", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">M</span>,</span><span class=\"param\">\t<span class=\"n\">C</span>,</span><span class=\"param\">\t<span class=\"n\">dx</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">order_x</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">shape_dom</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bc</span><span class=\"o\">=</span><span class=\"s1\">&#39;Periodic&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">rev_ad</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">traits</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">save_weights</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.dx", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.dx", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.shape_free", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.shape_free", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.damp_q", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.damp_q", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.damp_p", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.damp_p", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.size_ad", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.size_ad", "kind": "variable", "doc": "<p>Number of independent components for forward or reverse automatic differentiation.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.way_ad", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.way_ad", "kind": "variable", "doc": "<p>0 : no AD. 1 : forward AD. -1 : reverse AD</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.rev_reset", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.rev_reset", "kind": "function", "doc": "<p>Reset the accumulators for reverse autodiff \nNamely (self.metric.coef and self.weights.coef)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.isotropic_metric", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.isotropic_metric", "kind": "variable", "doc": "<p>Wether M has shape (1,1,...) or (d,d,...)</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.offsetpack_t", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.offsetpack_t", "kind": "variable", "doc": "<p>Type used to store a matrix offset. Defaults to int32.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.decompdim", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.decompdim", "kind": "variable", "doc": "<p>Number of terms in the decomposition of a generic Hooke tensor.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.offsetnbits", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.offsetnbits", "kind": "variable", "doc": "<p>Number of bits for storing each integer coefficient of the matrix offsets</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.voigt2lower", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.voigt2lower", "kind": "variable", "doc": "<p>Correspondance between voigt notation and symmetric matrix indexing.\nd=2 : [0  ]        d=3 : [0    ]\n      [2 1]          [5 1  ]\n                     [4 3 2]</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.weights", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.weights", "kind": "variable", "doc": "<p>Weights, obtained from Voronoi's decomposition of the Hooke tensors.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.offsets", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.offsets", "kind": "variable", "doc": "<p>Offsets, obtained from Voronoi's decomposition of the Hooke tensors.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.C_for_reuse", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.C_for_reuse", "kind": "variable", "doc": "<p>Avoid the initial tensor decomposition step.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.hooke", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.hooke", "kind": "variable", "doc": "<p>The Hooke tensor, input 'C', defining the elasticity properties of the medium.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.M", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.M", "kind": "variable", "doc": "<p>The metric tensor, input 'M'. Defines the norm for measuring momentum. \nUsually metric = Id/\u03c1 .</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.i\u03c1", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.i\u03c1", "kind": "variable", "doc": "<p>Inverse density. Alias for the metric M used to define the kinetic energy.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.Expl_p", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.Expl_p", "kind": "function", "doc": "<p>Explicit time step for the impulsion p.\nExpects : q and p reshaped in GPU friendly format, using self.reshape</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.Expl_q", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.Expl_q", "kind": "function", "doc": "<p>Explicit time step for the position q.\nExpects : q and p reshaped in GPU friendly format, using self.reshape</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.check_ad", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.check_ad", "kind": "function", "doc": "<p>Puts zero coefficients with the correct contiguity if those are empty.\nChecks that the AD variable x has the correct c-contiguity for the kernel.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.check", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.check", "kind": "function", "doc": "<p>Basic check of the types, shapes, contiguity of GPU inputs.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.Sympl_p", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.Sympl_p", "kind": "function", "doc": "<p>See super().Sympl_p for a detailed description.</p>\n\n<ul>\n<li>reshape (optional, default=False) : convert q,p to GPU friendly format</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">reshape</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.seismogram", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.seismogram", "kind": "function", "doc": "<p>See super().seismogram for a detailed description.</p>\n\n<ul>\n<li>reshape (optional, default=True) : convert q,p,qh_ind,ph_ind to GPU friendly format</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">qh_ind</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ph_ind</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">reshape</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.seismogram_with_backprop", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.seismogram_with_backprop", "kind": "function", "doc": "<p>See super().seismogram for a detailed description</p>\n\n<ul>\n<li>reshape (optional, default=True) : convert q,p,qh_ind,ph_ind,qf_grad,ph_grad to GPU friendly format</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">qh_ind</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ph_ind</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">reshape</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.H_p", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.H_p", "kind": "function", "doc": "<p>See super().H_p for a detailed description</p>\n\n<ul>\n<li>reshape (optional, default=True) : convert q,p to GPU friendly format</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">reshape</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.H", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.H", "kind": "function", "doc": "<p>See super().H for a detailed description</p>\n\n<ul>\n<li>reshape (optional, default=True) : convert q,p to GPU friendly format</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">reshape</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel.Damp_qp", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "ElasticHamiltonian_Kernel.Damp_qp", "kind": "function", "doc": "<p>See super().damp_qp for a detailed description</p>\n\n<ul>\n<li>reshape (optional, default=False) : convert q,p to GPU friendly format</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span>, </span><span class=\"param\"><span class=\"n\">reshape</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.AnisotropicWave.WaveHamiltonian", "modulename": "agd.Eikonal.HFM_CUDA.AnisotropicWave", "qualname": "WaveHamiltonian", "kind": "variable", "doc": "<p></p>\n", "default_value": "{(&#x27;Acoustic&#x27;, &#x27;Sparse&#x27;): &lt;function AcousticHamiltonian_Sparse&gt;, (&#x27;Elastic&#x27;, &#x27;Sparse&#x27;): &lt;function ElasticHamiltonian_Sparse&gt;, (&#x27;Acoustic&#x27;, &#x27;Kernel&#x27;): &lt;class &#x27;agd.Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Kernel&#x27;&gt;, (&#x27;Elastic&#x27;, &#x27;Kernel&#x27;): &lt;class &#x27;agd.Eikonal.HFM_CUDA.AnisotropicWave.ElasticHamiltonian_Kernel&#x27;&gt;}"}, {"fullname": "agd.Eikonal.HFM_CUDA.BeckmanOT", "modulename": "agd.Eikonal.HFM_CUDA.BeckmanOT", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.BeckmanOT.solve_ot", "modulename": "agd.Eikonal.HFM_CUDA.BeckmanOT", "qualname": "solve_ot", "kind": "function", "doc": "<p>Numerically solves a relaxed Bellman formulation of optimal transport</p>\n\n<ul>\n<li>\u03bb (positive) : the relaxation parameter</li>\n<li>\u03be (array) : the difference of measures \u03bd-\u03bc</li>\n<li>dx (array) : the grid scales (one per dimension)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">\u03bb</span>,</span><span class=\"param\">\t<span class=\"n\">\u03be</span>,</span><span class=\"param\">\t<span class=\"n\">dx</span>,</span><span class=\"param\">\t<span class=\"n\">relax_norm_constraint</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">\u03c4_primal</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">\u03c1_overrelax</span><span class=\"o\">=</span><span class=\"mf\">1.8</span>,</span><span class=\"param\">\t<span class=\"n\">\u03c60</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">\u03c30</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">atol</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">rtol</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span>,</span><span class=\"param\">\t<span class=\"n\">E_rtol</span><span class=\"o\">=</span><span class=\"mf\">0.001</span>,</span><span class=\"param\">\t<span class=\"n\">maxiter</span><span class=\"o\">=</span><span class=\"mi\">5000</span>,</span><span class=\"param\">\t<span class=\"n\">shape_i</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">stop_period</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">verbosity</span><span class=\"o\">=</span><span class=\"mi\">2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.Eigh", "modulename": "agd.Eikonal.HFM_CUDA.Eigh", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.Eigh.eigh", "modulename": "agd.Eikonal.HFM_CUDA.Eigh", "qualname": "eigh", "kind": "function", "doc": "<p>Computes the eigenvalues of the symmetric matrix m, of dimension d&lt;=3.\nThe cuda routines are likely more accurate, but they are often slow and memory\nintensive for large arrays of small matrices.\nInput : </p>\n\n<ul>\n<li>m : array of shape (n1,...,nk,d,d) symmetric w.r.t the last two entries, or of \nshape (n1,...,nk, d(d+1)/2) if flatsym==True</li>\n<li>flatsym (bool, default: autodetect): format for the symmetric matrices, see above.</li>\n<li>quaternion (bool): format specifier for the eigenvectors, see below</li>\n<li>use_numpy : use the numpy.linalg.eigh routine (calls cuda)\nOutput :</li>\n<li>\u03bb : array of shape (n1,...,nk,d). The eigenvalues of m, sorted increasingly.</li>\n<li>v : the eigenvectors of m, in the following format\nquaternion == false : shape (n1,...,nk,d,d)\n<ul>\n<li>true : export the eigenvectors compactly using the quaternion format\n(d=3), or omitting the second eigenvector (d=2).</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">quaternion</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">flatsym</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">use_numpy</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.Eigh.eigvalsh", "modulename": "agd.Eikonal.HFM_CUDA.Eigh", "qualname": "eigvalsh", "kind": "function", "doc": "<p>Computes the eigenvalues of the symmetric matrix m, of dimension d&lt;=3.\nThe cuda routines are likely more accurate, but often slow and memory intensive.\nInput : </p>\n\n<ul>\n<li>m : array of shape (n1,...,nk,d,d) symmetric w.r.t the last two entries, or of \nshape (n1,...,nk, d(d+1)/2) if flatsym==True</li>\n<li>flatsym (bool): format for the symmetric matrices, see above</li>\n</ul>\n\n<p>Output :</p>\n\n<ul>\n<li>\u03bb : array of shape (n1,...,nk,d). The eigenvalues of m, sorted increasingly.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">flatsym</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.MinCut", "modulename": "agd.Eikonal.HFM_CUDA.MinCut", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.MinCut.stag_grids", "modulename": "agd.Eikonal.HFM_CUDA.MinCut", "qualname": "stag_grids", "kind": "function", "doc": "<p>Generates the grid, staggered grid, and boundary conditions, as suitable for the mincut\nproblem, for a rectangular domain. Grids use 'ij' indexing.\nInput : </p>\n\n<ul>\n<li>shape (tuple) : the domain dimensions (n1,...,nd)</li>\n<li>corners (array of shape (2,d)) : the extreme points of the domain</li>\n<li>sparse (bool) : wether to generate a dense or a sparse grid \nOutput : Xm,X\u03d5,dx,weights (last element only if retweights=True)</li>\n<li>Xs : standard grid coordinates (for the scalar potential)</li>\n<li>Xv : staggered grid coordinates, at the center of each cell (for the gradient)</li>\n<li>dx : the discretization scale</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span>,</span><span class=\"param\">\t<span class=\"n\">corners</span>,</span><span class=\"param\">\t<span class=\"n\">sparse</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">xp</span><span class=\"o\">=&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;numpy&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;C:</span><span class=\"se\">\\\\</span><span class=\"s1\">Users</span><span class=\"se\">\\\\</span><span class=\"s1\">jmmir</span><span class=\"se\">\\\\</span><span class=\"s1\">miniconda3</span><span class=\"se\">\\\\</span><span class=\"s1\">envs</span><span class=\"se\">\\\\</span><span class=\"s1\">agd-hfm_cupy12</span><span class=\"se\">\\\\</span><span class=\"s1\">Lib</span><span class=\"se\">\\\\</span><span class=\"s1\">site-packages</span><span class=\"se\">\\\\</span><span class=\"s1\">numpy</span><span class=\"se\">\\\\</span><span class=\"s1\">__init__.py&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.MinCut.mincut", "modulename": "agd.Eikonal.HFM_CUDA.MinCut", "qualname": "mincut", "kind": "function", "doc": "<p>Numerically solves the mincut problem.</p>\n\n<ul>\n<li>g (array) : the ground cost functions</li>\n<li>metric : the geometric metric </li>\n<li>grad (optional, string): gradient discretization. Possible values : \n<ul>\n<li>'gradb' -> upwind</li>\n<li>'gradc' -> centered (accurate but unstable)</li>\n<li>'grad2' -> use both upwind and downwind</li>\n</ul></li>\n<li>\u03c4_primal : time step for the primal proximal operator</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">g</span>,</span><span class=\"param\">\t<span class=\"n\">metric</span>,</span><span class=\"param\">\t<span class=\"n\">dx</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">grad</span><span class=\"o\">=</span><span class=\"s1\">&#39;gradb&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">\u03c4_primal</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">\u03c1_overrelax</span><span class=\"o\">=</span><span class=\"mf\">1.8</span>,</span><span class=\"param\">\t<span class=\"n\">maxiter</span><span class=\"o\">=</span><span class=\"mi\">5000</span>,</span><span class=\"param\">\t<span class=\"n\">E_rtol</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">shape_i</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">use_numpy_eigh</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbosity</span><span class=\"o\">=</span><span class=\"mi\">2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.ProjectionTTI", "modulename": "agd.Eikonal.HFM_CUDA.ProjectionTTI", "kind": "module", "doc": "<p>This module attempts to find the parameters of a TTI norm, given a hooke tensor.\nThis boils down to minimizing a polynomial over a sphere. We follow a naive approach, where\nNewton methods are started from a large number of points in the sphere, and the best result \nis selected. In principle however, SDP relaxation techniques are applicable.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.ProjectionTTI.rotation_xy", "modulename": "agd.Eikonal.HFM_CUDA.ProjectionTTI", "qualname": "rotation_xy", "kind": "function", "doc": "<p>A composition of two rotations, along the x and y axes, with the given angles.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">\u03b1</span>, </span><span class=\"param\"><span class=\"n\">\u03b2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.ProjectionTTI.rotation_TTI", "modulename": "agd.Eikonal.HFM_CUDA.ProjectionTTI", "qualname": "rotation_TTI", "kind": "function", "doc": "<p>Construction of the rotation associated to the parameter x returned by ProjectionTTI</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">vdim</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.ProjectionTTI.ProjectionTTI", "modulename": "agd.Eikonal.HFM_CUDA.ProjectionTTI", "qualname": "ProjectionTTI", "kind": "function", "doc": "<p>Attempts to produce a TTI norm matching the given Hooke tensors.\nInputs : </p>\n\n<ul>\n<li>n_newton = number of Newton steps in the optimization.</li>\n<li>samples = seed points in unit sphere (or number of them)</li>\n</ul>\n\n<p>Output : \nReturns the score (squared projection error), an HexagonalMaterial, and \nif retx==False : a rotation matrix\nif retx==True  : the parameters of the optimal rotation</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hooke</span>, </span><span class=\"param\"><span class=\"n\">ret_rot</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">n_newton</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">samples</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">quaternion</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.SellingAnisotropicDiffusion", "modulename": "agd.Eikonal.HFM_CUDA.SellingAnisotropicDiffusion", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.SellingAnisotropicDiffusion.anisotropic_diffusion_scheme", "modulename": "agd.Eikonal.HFM_CUDA.SellingAnisotropicDiffusion", "qualname": "anisotropic_diffusion_scheme", "kind": "function", "doc": "<p>First stage of solving D_t u = div( D grad u ), with Neumann b.c.\nInput : </p>\n\n<ul>\n<li>D : positive definite diffusion tensors. Format : (n1,...,nd,d*(d+1)/2)</li>\n<li>ced (optional) : a dictionary with keys\n<ul>\n<li>alpha, gamma (real) : weickerts coherence enhancing diffusion parameters</li>\n<li>cond_max,cond_amplification_threshold (real, optional) : additional parameters</li>\n<li>retD (bool, optional) : wether to return the diffusion tensors </li>\n</ul></li>\n</ul>\n\n<pre><code>    If ced is present, then D is regarded as a structure tensor, and modified \n    according to Weickert's coherence enhancing diffusion principle\n</code></pre>\n\n<p></p>\n\n<ul>\n<li>dx (optional): grid scale</li>\n</ul>\n\n<p>Output : </p>\n\n<ul>\n<li>dt_max : the largest stable time step for the scheme</li>\n<li>scheme_data : data to be used in anisotropic_diffusion_steps </li>\n<li>D (optional) : the diffusion tensors, returned if ced['retD']=true</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">D</span>, </span><span class=\"param\"><span class=\"n\">dx</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">ced</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">periodic</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">256</span>, </span><span class=\"param\"><span class=\"n\">traits</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.SellingAnisotropicDiffusion.anisotropic_diffusion_steps", "modulename": "agd.Eikonal.HFM_CUDA.SellingAnisotropicDiffusion", "qualname": "anisotropic_diffusion_steps", "kind": "function", "doc": "<p>Solving D_t u = div( D grad u ), with Neumann b.c.\nInput : </p>\n\n<ul>\n<li>u : initial data</li>\n<li>dt : time step</li>\n<li>ndt : number of time steps</li>\n<li>scheme_data : output of anisotropic_diffusion_scheme</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">u</span>,</span><span class=\"param\">\t<span class=\"n\">dt</span>,</span><span class=\"param\">\t<span class=\"n\">ndt</span>,</span><span class=\"param\">\t<span class=\"n\">scheme_data</span>,</span><span class=\"param\">\t<span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">1024</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite_u</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.ShapeFromShading", "modulename": "agd.Eikonal.HFM_CUDA.ShapeFromShading", "kind": "module", "doc": "<p>This module solves the shape from shading PDE, with a non-vertical light source. \nThe PDE reads \n(alpha u_x + beta u_y + gamma) / sqrt(1+u_x^2+u_y^2) = rhs\nwhere alpha, beta, gamma are parameters related to the sun direction.</p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.ShapeFromShading.EvalScheme", "modulename": "agd.Eikonal.HFM_CUDA.ShapeFromShading", "qualname": "EvalScheme", "kind": "function", "doc": "<p>Evaluates the (piecewise) quadratic equation defining the numerical scheme.\nInputs :</p>\n\n<ul>\n<li>uc : plays the role of \u03bb</li>\n<li>params : alpha,beta,gamma,h (grid scale)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cp</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">params</span>, </span><span class=\"param\"><span class=\"n\">uc</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.ShapeFromShading.Solve", "modulename": "agd.Eikonal.HFM_CUDA.ShapeFromShading", "qualname": "Solve", "kind": "function", "doc": "<p>Iterative solver for the shape from shading equation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rhs</span>, </span><span class=\"param\"><span class=\"n\">mask</span>, </span><span class=\"param\"><span class=\"n\">u0</span>, </span><span class=\"param\"><span class=\"n\">params</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">300</span>, </span><span class=\"param\"><span class=\"n\">traits</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.VoronoiDecomposition", "modulename": "agd.Eikonal.HFM_CUDA.VoronoiDecomposition", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.VoronoiDecomposition.Reconstruct", "modulename": "agd.Eikonal.HFM_CUDA.VoronoiDecomposition", "qualname": "Reconstruct", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">coefs</span>, </span><span class=\"param\"><span class=\"n\">offsets</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.VoronoiDecomposition.VoronoiDecomposition", "modulename": "agd.Eikonal.HFM_CUDA.VoronoiDecomposition", "qualname": "VoronoiDecomposition", "kind": "function", "doc": "<p>Returns the Voronoi decomposition of a family of quadratic forms. </p>\n\n<ul>\n<li>m : the (symmetric) matrices of the quadratic forms to decompose.</li>\n<li>offset_t : the type of offsets to be returned. </li>\n<li>flattened : wether the input matrices are flattened</li>\n<li>retry64_tol (optional) : retries decomposition using 64bit floats if this error \nis exceeded relative to matrix trace. (Set retry64_tol = 0 to use double precision.)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">m</span>,</span><span class=\"param\">\toffset_t=&lt;class &#x27;numpy.int32&#x27;&gt;,</span><span class=\"param\">\t<span class=\"n\">flattened</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">blockDim</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">traits</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">steps</span><span class=\"o\">=</span><span class=\"s1\">&#39;Both&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">retry64_tol</span><span class=\"o\">=</span><span class=\"mf\">2e-05</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "modulename": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.cupy_module_helper.hfm_debug_macro", "modulename": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "qualname": "hfm_debug_macro", "kind": "variable", "doc": "<p></p>\n", "default_value": "False"}, {"fullname": "agd.Eikonal.HFM_CUDA.cupy_module_helper.getmtime_max", "modulename": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "qualname": "getmtime_max", "kind": "function", "doc": "<p>Lists all the files in the given directory, and returns the last time one of them\nwas modified. Information needed when compiling cupy modules, because they are cached.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">directory</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.cupy_module_helper.GetModule", "modulename": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "qualname": "GetModule", "kind": "function", "doc": "<p>Returns a cupy raw module</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source</span>, </span><span class=\"param\"><span class=\"n\">cuoptions</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.cupy_module_helper.SetModuleConstant", "modulename": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "qualname": "SetModuleConstant", "kind": "function", "doc": "<p>Sets a global constant in a cupy cuda module.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">module</span>, </span><span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">dtype</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.cupy_module_helper.np2cuda_dtype", "modulename": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "qualname": "np2cuda_dtype", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&lt;class &#x27;numpy.int8&#x27;&gt;: &#x27;char&#x27;, &lt;class &#x27;numpy.uint8&#x27;&gt;: &#x27;unsigned char&#x27;, &lt;class &#x27;numpy.int16&#x27;&gt;: &#x27;short&#x27;, &lt;class &#x27;numpy.int32&#x27;&gt;: &#x27;int&#x27;, &lt;class &#x27;numpy.int64&#x27;&gt;: &#x27;long long&#x27;, &lt;class &#x27;numpy.float32&#x27;&gt;: &#x27;float&#x27;, &lt;class &#x27;numpy.float64&#x27;&gt;: &#x27;double&#x27;}"}, {"fullname": "agd.Eikonal.HFM_CUDA.cupy_module_helper.traits_header", "modulename": "agd.Eikonal.HFM_CUDA.cupy_module_helper", "qualname": "traits_header", "kind": "function", "doc": "<p>Returns the source (mostly a preamble) for the gpu kernel code \nfor the given traits.</p>\n\n<ul>\n<li>join (optional): return a multiline string, rather than a list of strings</li>\n<li>size_of_shape: insert traits for the size of each shape.</li>\n<li>log2_size: insert a trait for the ceil of the base 2 logarithm of previous size.</li>\n<li>integral_max: declare max of integral typedefs</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">traits</span>,</span><span class=\"param\">\t<span class=\"n\">join</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">size_of_shape</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">log2_size</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">integral_max</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.graph_reverse", "modulename": "agd.Eikonal.HFM_CUDA.graph_reverse", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.graph_reverse.graph_reverse", "modulename": "agd.Eikonal.HFM_CUDA.graph_reverse", "qualname": "graph_reverse", "kind": "function", "doc": "<p>Inverses a weighted graph. </p>\n\n<ul>\n<li>invalid_index : special value to be ignored in fwd (defaults to Int_Max)</li>\n<li>nrev : expected max number of neighbors in reversed graph</li>\n<li>irev_t\nOutput : \n<ul>\n<li>rev, rev_weight. !! Warning : likely not contiguous arrays. !!</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fwd</span>, </span><span class=\"param\"><span class=\"n\">fwd_weight</span>, </span><span class=\"param\"><span class=\"n\">invalid_index</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">nrev</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">blockDim</span><span class=\"o\">=</span><span class=\"mi\">1024</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.inf_convolution", "modulename": "agd.Eikonal.HFM_CUDA.inf_convolution", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.inf_convolution.dtype_sup", "modulename": "agd.Eikonal.HFM_CUDA.inf_convolution", "qualname": "dtype_sup", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dtype</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.inf_convolution.dtype_inf", "modulename": "agd.Eikonal.HFM_CUDA.inf_convolution", "qualname": "dtype_inf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dtype</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.inf_convolution.distance_kernel", "modulename": "agd.Eikonal.HFM_CUDA.inf_convolution", "qualname": "distance_kernel", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">ndim</span>, </span><span class=\"param\">dtype=&lt;class &#x27;numpy.float32&#x27;&gt;, </span><span class=\"param\"><span class=\"nb\">ord</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">mult</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.inf_convolution.inf_convolution", "modulename": "agd.Eikonal.HFM_CUDA.inf_convolution", "qualname": "inf_convolution", "kind": "function", "doc": "<p>Perform an inf convolution of an input with a given kernel, on the GPU.</p>\n\n<ul>\n<li>arr : the input array</li>\n<li>kernel : the convolution kernel. A centered kernel will be used.</li>\n<li>niter (optional) : number of iterations of the convolution.</li>\n<li>periodic (optional, bool or tuple of bool): axes using periodic boundary conditions.</li>\n<li>mix_is_min : if false, use sup_convolution instead</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">kernel</span>,</span><span class=\"param\">\t<span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">periodic</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">upper_saturation</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lower_saturation</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">mix_is_min</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">1024</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.kernel_traits", "modulename": "agd.Eikonal.HFM_CUDA.kernel_traits", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.kernel_traits.default_traits", "modulename": "agd.Eikonal.HFM_CUDA.kernel_traits", "qualname": "default_traits", "kind": "function", "doc": "<p>Default traits of the GPU implementation of an HFM model.\n(self is an instance of the class Interface from file interface.py)\nSide effect : sets the default FIM front width. (None : AGSI is fine.)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.kernel_traits.voronoi_decompdim", "modulename": "agd.Eikonal.HFM_CUDA.kernel_traits", "qualname": "voronoi_decompdim", "kind": "function", "doc": "<p>Number of offsets in Voronoi's decomposition of a symmetric positive definite matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ndim</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.kernel_traits.nscheme", "modulename": "agd.Eikonal.HFM_CUDA.kernel_traits", "qualname": "nscheme", "kind": "function", "doc": "<p>Provides the structure of the finite difference scheme used.\n(number of symmmetric offsets, foward offsets, max or min of a number of schemes)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.HFM_CUDA.misc", "modulename": "agd.Eikonal.HFM_CUDA.misc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.HFM_CUDA.misc.integral_largest_nextlargest", "modulename": "agd.Eikonal.HFM_CUDA.misc", "qualname": "integral_largest_nextlargest", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dtype</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.LibraryCall", "modulename": "agd.Eikonal.LibraryCall", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.LibraryCall.SetInput", "modulename": "agd.Eikonal.LibraryCall", "qualname": "SetInput", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hfm</span>, </span><span class=\"param\"><span class=\"n\">params</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.LibraryCall.GetOutput", "modulename": "agd.Eikonal.LibraryCall", "qualname": "GetOutput", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hfm</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.LibraryCall.ListToNDArray", "modulename": "agd.Eikonal.LibraryCall", "qualname": "ListToNDArray", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">params</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.LibraryCall.RunDispatch", "modulename": "agd.Eikonal.LibraryCall", "qualname": "RunDispatch", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">params</span>, </span><span class=\"param\"><span class=\"n\">bin_dir</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.LibraryCall.binary_dir", "modulename": "agd.Eikonal.LibraryCall", "qualname": "binary_dir", "kind": "variable", "doc": "<p></p>\n", "default_value": "{}"}, {"fullname": "agd.Eikonal.LibraryCall.GetBinaryDir", "modulename": "agd.Eikonal.LibraryCall", "qualname": "GetBinaryDir", "kind": "function", "doc": "<p>This function is used due to the special way the HamiltonFastMarching library is used:</p>\n\n<ul>\n<li>either as a bunch of command line executables, whose name begins with FileHFM.</li>\n<li>or as a python library, named HFMpy</li>\n</ul>\n\n<p>The function will look for a file named \"FileHFM_binary_dir.txt\" (or a global variable named FileHFM_binary_dir)</p>\n\n<ul>\n<li>if it exists, the first line is read\n<ul>\n<li>if the first line is None -> use the HFMpy library</li>\n<li>otherwise, check that the first line is a valid directory -> should contain the FileHFM executables</li>\n</ul></li>\n<li>if file cannot be read -> use the HFMpy library</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">execName</span>, </span><span class=\"param\"><span class=\"n\">libName</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail", "modulename": "agd.Eikonal.run_detail", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.run_detail.GetGeodesics", "modulename": "agd.Eikonal.run_detail", "qualname": "GetGeodesics", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">output</span>, </span><span class=\"param\"><span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.Cache", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.run_detail.Cache.__init__", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">needsflow</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "agd.Eikonal.run_detail.Cache.contents", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.contents", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.run_detail.Cache.verbosity", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.verbosity", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.run_detail.Cache.requested", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.requested", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.run_detail.Cache.needsflow", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.needsflow", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.run_detail.Cache.dummy", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.dummy", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Eikonal.run_detail.Cache.empty", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.empty", "kind": "function", "doc": "<p>Wether the cache lacks data needed to bypass computation</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.Cache.PreProcess", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.PreProcess", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">hfmIn_raw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.Cache.PostProcess", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.PostProcess", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">hfmOut_raw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.Cache.geodesicFlow", "modulename": "agd.Eikonal.run_detail", "qualname": "Cache.geodesicFlow", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">hfmIn</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.RunRaw", "modulename": "agd.Eikonal.run_detail", "qualname": "RunRaw", "kind": "function", "doc": "<p>Raw call to the HFM library</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hfmIn</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.RunSmart", "modulename": "agd.Eikonal.run_detail", "qualname": "RunSmart", "kind": "function", "doc": "<p>Calls the HFM library, a CPU eikonal solver written in C++,\nwith pre-processing and post-processing of data.</p>\n\n<p>Main input : </p>\n\n<ul>\n<li>hfmIn, a dictionary like structure, containing the eikonal solver data.</li>\n</ul>\n\n<p>The C++ library embeds some help information, which can be accessed using the \nfollowing key:value pairs in hfmIn.</p>\n\n<ul>\n<li>'verbosity' : set to 1 or 2 to display information on run, including the defaulted keys.\nset to 0 to silence the run.</li>\n<li>'keyHelp' : set as a string of keys separated by spaces, to print help on these.\nexample 'keyHelp':\"seeds tips\"</li>\n</ul>\n\n<p>Optional input:</p>\n\n<ul>\n<li>co_output (optional) : used for reverse automatic differentiation.</li>\n<li>cache (optional) : store some intermediate results to bypass computations at a later stage. </li>\n<li>returns (optional) : early aborts the run (debug purposes). ('in_raw','out_raw','out')</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hfmIn</span>, </span><span class=\"param\"><span class=\"n\">co_output</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cache</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">returns</span><span class=\"o\">=</span><span class=\"s1\">&#39;out&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.setkey_safe", "modulename": "agd.Eikonal.run_detail", "qualname": "setkey_safe", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dico</span>, </span><span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">value</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.flow_variation", "modulename": "agd.Eikonal.run_detail", "qualname": "flow_variation", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">flow</span>, </span><span class=\"param\"><span class=\"n\">metric</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.PreProcess", "modulename": "agd.Eikonal.run_detail", "qualname": "PreProcess", "kind": "function", "doc": "<p>copies key,val from refined to raw, with adequate treatment</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">refined_in</span>, </span><span class=\"param\"><span class=\"n\">raw_out</span>, </span><span class=\"param\"><span class=\"n\">cache</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.PostProcess", "modulename": "agd.Eikonal.run_detail", "qualname": "PostProcess", "kind": "function", "doc": "<p>copies key,val from raw to refined, with adequate treatment</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">raw_in</span>, </span><span class=\"param\"><span class=\"n\">refined_out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Eikonal.run_detail.CastOffsets", "modulename": "agd.Eikonal.run_detail", "qualname": "CastOffsets", "kind": "function", "doc": "<p>Offsets are exported with their coefficients bundled together in a double.\nThis function unpacks them.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raw_offsets</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode", "modulename": "agd.ExportedCode", "kind": "module", "doc": "<p>This is not really a package, but a collection of code samples automatically extracted \nfrom the illustrative notebooks of the AGD library:\n<a href=\"https://github.com/Mirebeau/AdaptiveGridDiscretizations\">https://github.com/Mirebeau/AdaptiveGridDiscretizations</a></p>\n\n<p>These code samples use in several notebooks. Yet they are too specific and narrow focused \nto be integrated in the base of AGD library.</p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_Algo", "modulename": "agd.ExportedCode.Notebooks_Algo", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.Meissner", "modulename": "agd.ExportedCode.Notebooks_Algo.Meissner", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.Meissner.norm_infinity", "modulename": "agd.ExportedCode.Notebooks_Algo.Meissner", "qualname": "norm_infinity", "kind": "function", "doc": "<p>L-Infinity norm (largest absolute value)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.Meissner.LinearConstraint_AD", "modulename": "agd.ExportedCode.Notebooks_Algo.Meissner", "qualname": "LinearConstraint_AD", "kind": "function", "doc": "<p>Takes a linear constraint f>=0, \nencoded as an ad.Sparse variable, \nand turns it into a scipy compatible constraint.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.Meissner.QuadraticObjective_AD", "modulename": "agd.ExportedCode.Notebooks_Algo.Meissner", "qualname": "QuadraticObjective_AD", "kind": "function", "doc": "<p>Takes a quadratic objective function, \nencoded as an ad.Sparse2 variable,\nand returns fun, jac and hessian methods.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.Meissner.NonlinearObjective", "modulename": "agd.ExportedCode.Notebooks_Algo.Meissner", "qualname": "NonlinearObjective", "kind": "function", "doc": "<p>Returns methods computing the value, gradient and hessian \nof a given objective function f</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">fargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.Meissner.NonlinearConstraint", "modulename": "agd.ExportedCode.Notebooks_Algo.Meissner", "qualname": "NonlinearConstraint", "kind": "function", "doc": "<p>Represents the constraint : np.bincount(indices,weights) &gt;= 0,\nwhere (indices, weights) = f(x,*fargs)\n(Indices may be repeated, and the associated values must be summed.)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">fargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.Meissner.geodesate", "modulename": "agd.ExportedCode.Notebooks_Algo.Meissner", "qualname": "geodesate", "kind": "function", "doc": "<p>Generate a point set on a sphere, by projecting a regularly refined triangulation.\n(This implementation is stupid and inefficient, but will be enough for here.)\nInput : </p>\n\n<ul>\n<li>points, triangles : a triangulation of the sphere.</li>\n<li>nosym : keep only a single representative among opposite points\nOutput : the points of a refined triangulation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span>, </span><span class=\"param\"><span class=\"n\">triangles</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">nosym</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.Meissner.ico_points", "modulename": "agd.ExportedCode.Notebooks_Algo.Meissner", "qualname": "ico_points", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([[ 0.        ,  0.        , -0.95105652],\n       [ 0.        ,  0.        ,  0.95105652],\n       [-0.85065081,  0.        , -0.4253254 ],\n       [ 0.85065081,  0.        ,  0.4253254 ],\n       [ 0.68819096, -0.5       , -0.4253254 ],\n       [ 0.68819096,  0.5       , -0.4253254 ],\n       [-0.68819096, -0.5       ,  0.4253254 ],\n       [-0.68819096,  0.5       ,  0.4253254 ],\n       [-0.26286556, -0.80901699, -0.4253254 ],\n       [-0.26286556,  0.80901699, -0.4253254 ],\n       [ 0.26286556, -0.80901699,  0.4253254 ],\n       [ 0.26286556,  0.80901699,  0.4253254 ]])"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.Meissner.ico_triangles", "modulename": "agd.ExportedCode.Notebooks_Algo.Meissner", "qualname": "ico_triangles", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([[ 1, 11,  7],\n       [ 1,  7,  6],\n       [ 1,  6, 10],\n       [ 1, 10,  3],\n       [ 1,  3, 11],\n       [ 4,  8,  0],\n       [ 5,  4,  0],\n       [ 9,  5,  0],\n       [ 2,  9,  0],\n       [ 8,  2,  0],\n       [11,  9,  7],\n       [ 7,  2,  6],\n       [ 6,  8, 10],\n       [10,  4,  3],\n       [ 3,  5, 11],\n       [ 4, 10,  8],\n       [ 5,  3,  4],\n       [ 9, 11,  5],\n       [ 2,  7,  9],\n       [ 8,  6,  2]])"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.Meissner.sphere_sampling", "modulename": "agd.ExportedCode.Notebooks_Algo.Meissner", "qualname": "sphere_sampling", "kind": "function", "doc": "<p>A rather regular sapling of the sphere, obtained by refining an icosahedron mesh.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">nosym</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.Meissner.to_mathematica", "modulename": "agd.ExportedCode.Notebooks_Algo.Meissner", "qualname": "to_mathematica", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Z</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.norm", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "norm", "kind": "function", "doc": "<p>Returns L^p norm of array, seen as a vector, w.r.t. weights.\nDefined as : (sum_i x[i]^p)^(1/p)</p>\n\n<p>Remark : not a matrix operator norm</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>ord : exponent p</li>\n<li>axis : int or None, axis along which to compute the norm. </li>\n<li>keepdims : wether to keep singleton dimensions.</li>\n<li>averaged : wether to introduce a normalization factor, so that norm(ones(...))=1</li>\n</ul>\n\n<p>Compatible with automatic differentiation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"nb\">ord</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">keepdims</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">averaged</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.rotation_from_quaternion", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "rotation_from_quaternion", "kind": "function", "doc": "<p>Produces the rotation associated with a unit quaternion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">q</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.quaternion_from_rotation", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "quaternion_from_rotation", "kind": "function", "doc": "<p>Produces the unit quaternion, with positive real part, associated with a rotation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">r</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.quaternion_from_euclidean", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "quaternion_from_euclidean", "kind": "function", "doc": "<p>Produces a point in the unit sphere by projecting a point in the equator plane.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.euclidean_from_quaternion", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "euclidean_from_quaternion", "kind": "function", "doc": "<p>Produces a point in the equator plane from a point in the unit sphere.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">q</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.euclidean_from_rotation", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "euclidean_from_rotation", "kind": "function", "doc": "<p>Produces an euclidean point from a rotation, \nselecting in the intermediate step the quaternion \nin the same hemisphere as qRef. (Defaults to southern.)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">qRef</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.rotation_from_euclidean", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "rotation_from_euclidean", "kind": "function", "doc": "<p>Produces a rotation from an euclidean point. \nAlso returns the intermediate quaternion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.antisym", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "antisym", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.exp_antisym", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "exp_antisym", "kind": "function", "doc": "<p>Matrix exponential of antisym(a,b,c).\nNote : (a,b,c) is the axis of rotation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.advance", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "advance", "kind": "function", "doc": "<p>Move from a state to another by applying a control during a unit time</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">state</span>, </span><span class=\"param\"><span class=\"n\">control</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models.make_hamiltonian", "modulename": "agd.ExportedCode.Notebooks_Algo.RollingBall_Models", "qualname": "make_hamiltonian", "kind": "function", "doc": "<p>Produces the hamiltonian function associated to a sub-Riemannian model, \ndefined by its controls and the advance function</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">controls</span>, </span><span class=\"param\"><span class=\"n\">advance</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">advance</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SeismicNorm", "modulename": "agd.ExportedCode.Notebooks_Algo.SeismicNorm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SeismicNorm.proj_orthorombic", "modulename": "agd.ExportedCode.Notebooks_Algo.SeismicNorm", "qualname": "proj_orthorombic", "kind": "function", "doc": "<p>Project onto the vector space of Hooke tensors corresponding to orthorombic materials in their frame of reference</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SeismicNorm.frame_score", "modulename": "agd.ExportedCode.Notebooks_Algo.SeismicNorm", "qualname": "frame_score", "kind": "function", "doc": "<p>Score for wether c coincides with its projection in the frame defined by r</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">proj</span>, </span><span class=\"param\"><span class=\"n\">r</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SeismicNorm.proj_hooke2", "modulename": "agd.ExportedCode.Notebooks_Algo.SeismicNorm", "qualname": "proj_hooke2", "kind": "function", "doc": "<p>Project onto the vector space of Hooke tensors with (2,1) block diagonal structure</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SeismicNorm.proj_tetragonal", "modulename": "agd.ExportedCode.Notebooks_Algo.SeismicNorm", "qualname": "proj_tetragonal", "kind": "function", "doc": "<p>Tetragonal Hooke tensors share the coefficients c11=c22, c13=c23, c44=c55</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SeismicNorm.proj_hexagonal", "modulename": "agd.ExportedCode.Notebooks_Algo.SeismicNorm", "qualname": "proj_hexagonal", "kind": "function", "doc": "<p>Hexagonal Hooke tensors are tetragonal, with the additional property that c66=(c11-c12)/2</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SeismicNorm.rotation_from_ball", "modulename": "agd.ExportedCode.Notebooks_Algo.SeismicNorm", "qualname": "rotation_from_ball", "kind": "function", "doc": "<p>Produces a rotation matrix from an element of the unit ball\nB_3 -> S_3 (lower half) -> SO_3, via quaternions\nB_1 -> SO_2, via rotation of angle pi*x</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SeismicNorm.ball_samples", "modulename": "agd.ExportedCode.Notebooks_Algo.SeismicNorm", "qualname": "ball_samples", "kind": "function", "doc": "<p>Produce samples of the unit ball of dimension vdim.\nApprox c(vdim) * dens^vdim elements.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vdim</span>, </span><span class=\"param\"><span class=\"n\">dens</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SeismicNorm.newton_extremize", "modulename": "agd.ExportedCode.Notebooks_Algo.SeismicNorm", "qualname": "newton_extremize", "kind": "function", "doc": "<p>Runs niter steps of Newton's method for extremizing f. \n(A.k.a, solve grad(f) = 0)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">niter</span>, </span><span class=\"param\"><span class=\"n\">max_cond</span><span class=\"o\">=</span><span class=\"mf\">10000000000.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SeismicNorm.hooke_frame", "modulename": "agd.ExportedCode.Notebooks_Algo.SeismicNorm", "qualname": "hooke_frame", "kind": "function", "doc": "<p>Optimize the frame score, via a Newton method, with a large number of initial seeds.\nReturn the best rotation and associated score.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">proj</span>, </span><span class=\"param\"><span class=\"n\">dens</span><span class=\"o\">=</span><span class=\"mi\">8</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SternBrocot", "modulename": "agd.ExportedCode.Notebooks_Algo.SternBrocot", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SternBrocot.MakeStencil", "modulename": "agd.ExportedCode.Notebooks_Algo.SternBrocot", "qualname": "MakeStencil", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">refine_pred</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SternBrocot.PlotStencil", "modulename": "agd.ExportedCode.Notebooks_Algo.SternBrocot", "qualname": "PlotStencil", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">stencil</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SternBrocot.aX0", "modulename": "agd.ExportedCode.Notebooks_Algo.SternBrocot", "qualname": "aX0", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([-1.        , -0.95918367, -0.91836735, -0.87755102, -0.83673469,\n       -0.79591837, -0.75510204, -0.71428571, -0.67346939, -0.63265306,\n       -0.59183673, -0.55102041, -0.51020408, -0.46938776, -0.42857143,\n       -0.3877551 , -0.34693878, -0.30612245, -0.26530612, -0.2244898 ,\n       -0.18367347, -0.14285714, -0.10204082, -0.06122449, -0.02040816,\n        0.02040816,  0.06122449,  0.10204082,  0.14285714,  0.18367347,\n        0.2244898 ,  0.26530612,  0.30612245,  0.34693878,  0.3877551 ,\n        0.42857143,  0.46938776,  0.51020408,  0.55102041,  0.59183673,\n        0.63265306,  0.67346939,  0.71428571,  0.75510204,  0.79591837,\n        0.83673469,  0.87755102,  0.91836735,  0.95918367,  1.        ])"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SternBrocot.aX1", "modulename": "agd.ExportedCode.Notebooks_Algo.SternBrocot", "qualname": "aX1", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([-1.        , -0.95918367, -0.91836735, -0.87755102, -0.83673469,\n       -0.79591837, -0.75510204, -0.71428571, -0.67346939, -0.63265306,\n       -0.59183673, -0.55102041, -0.51020408, -0.46938776, -0.42857143,\n       -0.3877551 , -0.34693878, -0.30612245, -0.26530612, -0.2244898 ,\n       -0.18367347, -0.14285714, -0.10204082, -0.06122449, -0.02040816,\n        0.02040816,  0.06122449,  0.10204082,  0.14285714,  0.18367347,\n        0.2244898 ,  0.26530612,  0.30612245,  0.34693878,  0.3877551 ,\n        0.42857143,  0.46938776,  0.51020408,  0.55102041,  0.59183673,\n        0.63265306,  0.67346939,  0.71428571,  0.75510204,  0.79591837,\n        0.83673469,  0.87755102,  0.91836735,  0.95918367,  1.        ])"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SternBrocot.X", "modulename": "agd.ExportedCode.Notebooks_Algo.SternBrocot", "qualname": "X", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([[[-1.        , -1.        , -1.        , ..., -1.        ,\n         -1.        , -1.        ],\n        [-0.95918367, -0.95918367, -0.95918367, ..., -0.95918367,\n         -0.95918367, -0.95918367],\n        [-0.91836735, -0.91836735, -0.91836735, ..., -0.91836735,\n         -0.91836735, -0.91836735],\n        ...,\n        [ 0.91836735,  0.91836735,  0.91836735, ...,  0.91836735,\n          0.91836735,  0.91836735],\n        [ 0.95918367,  0.95918367,  0.95918367, ...,  0.95918367,\n          0.95918367,  0.95918367],\n        [ 1.        ,  1.        ,  1.        , ...,  1.        ,\n          1.        ,  1.        ]],\n\n       [[-1.        , -0.95918367, -0.91836735, ...,  0.91836735,\n          0.95918367,  1.        ],\n        [-1.        , -0.95918367, -0.91836735, ...,  0.91836735,\n          0.95918367,  1.        ],\n        [-1.        , -0.95918367, -0.91836735, ...,  0.91836735,\n          0.95918367,  1.        ],\n        ...,\n        [-1.        , -0.95918367, -0.91836735, ...,  0.91836735,\n          0.95918367,  1.        ],\n        [-1.        , -0.95918367, -0.91836735, ...,  0.91836735,\n          0.95918367,  1.        ],\n        [-1.        , -0.95918367, -0.91836735, ...,  0.91836735,\n          0.95918367,  1.        ]]])"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.SternBrocot.ball_and_stencil", "modulename": "agd.ExportedCode.Notebooks_Algo.SternBrocot", "qualname": "ball_and_stencil", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">metric</span>, </span><span class=\"param\"><span class=\"n\">level</span>, </span><span class=\"param\"><span class=\"n\">name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "modulename": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.TensorSelling.allclose", "modulename": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "qualname": "allclose", "kind": "function", "doc": "<p>Returns True if two arrays are element-wise equal within a tolerance.</p>\n\n<p>The tolerance values are positive, typically very small numbers.  The\nrelative difference (<code>rtol</code> * abs(<code>b</code>)) and the absolute difference\n<code>atol</code> are added together to compare against the absolute difference\nbetween <code>a</code> and <code>b</code>.</p>\n\n<p>NaNs are treated as equal if they are in the same place and if\n<code>equal_nan=True</code>.  Infs are treated as equal if they are in the same\nplace and of the same sign in both arrays.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>a, b : array_like\n    Input arrays to compare.\nrtol : float\n    The relative tolerance parameter (see Notes).\natol : float\n    The absolute tolerance parameter (see Notes).\nequal_nan : bool\n    Whether to compare NaN's as equal.  If True, NaN's in <code>a</code> will be\n    considered equal to NaN's in <code>b</code> in the output array.</p>\n\n<pre><code>*New in version 1.10.0.*\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>allclose : bool\n    Returns True if the two arrays are equal within the given\n    tolerance; False otherwise.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>isclose, all, any, equal</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>If the following equation is element-wise True, then allclose returns\nTrue.</p>\n\n<p>absolute(<code>a</code> - <code>b</code>) &lt;= (<code>atol</code> + <code>rtol</code> * absolute(<code>b</code>))</p>\n\n<p>The above equation is not symmetric in <code>a</code> and <code>b</code>, so that\n<code>allclose(a, b)</code> might be different from <code>allclose(b, a)</code> in\nsome rare cases.</p>\n\n<p>The comparison of <code>a</code> and <code>b</code> uses standard broadcasting, which\nmeans that <code>a</code> and <code>b</code> need not have the same shape in order for\n<code>allclose(a, b)</code> to evaluate to True.  The same is true for\n<code>equal</code> but not <code>array_equal</code>.</p>\n\n<p><code>allclose</code> is not defined for non-numeric data types.\n<code>bool</code> is considered a numeric data-type for this purpose.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">allclose</span><span class=\"p\">([</span><span class=\"mf\">1e10</span><span class=\"p\">,</span><span class=\"mf\">1e-7</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">1.00001e10</span><span class=\"p\">,</span><span class=\"mf\">1e-8</span><span class=\"p\">])</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">allclose</span><span class=\"p\">([</span><span class=\"mf\">1e10</span><span class=\"p\">,</span><span class=\"mf\">1e-8</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">1.00001e10</span><span class=\"p\">,</span><span class=\"mf\">1e-9</span><span class=\"p\">])</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">allclose</span><span class=\"p\">([</span><span class=\"mf\">1e10</span><span class=\"p\">,</span><span class=\"mf\">1e-8</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">1.0001e10</span><span class=\"p\">,</span><span class=\"mf\">1e-9</span><span class=\"p\">])</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">allclose</span><span class=\"p\">([</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nan</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nan</span><span class=\"p\">])</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">allclose</span><span class=\"p\">([</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nan</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nan</span><span class=\"p\">],</span> <span class=\"n\">equal_nan</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">rtol</span><span class=\"o\">=</span><span class=\"mf\">1e-05</span>, </span><span class=\"param\"><span class=\"n\">atol</span><span class=\"o\">=</span><span class=\"mf\">1e-08</span>, </span><span class=\"param\"><span class=\"n\">equal_nan</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.TensorSelling.MakeRandomTensor", "modulename": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "qualname": "MakeRandomTensor", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dim</span>, </span><span class=\"param\"><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">()</span>, </span><span class=\"param\"><span class=\"n\">relax</span><span class=\"o\">=</span><span class=\"mf\">0.01</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_Algo.TensorSelling.Reconstruct", "modulename": "agd.ExportedCode.Notebooks_Algo.TensorSelling", "qualname": "Reconstruct", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">coefs</span>, </span><span class=\"param\"><span class=\"n\">offsets</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM", "modulename": "agd.ExportedCode.Notebooks_FMM", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.route_min", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "route_min", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">params</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.metric", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "metric", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">params</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.Spherical", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "Spherical", "kind": "function", "doc": "<p>Spherical embedding: \u03b8 is longitude, \u03d5 is latitude from equator toward pole</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">\u03b8</span>, </span><span class=\"param\"><span class=\"n\">\u03c6</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.IntrinsicMetric", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "IntrinsicMetric", "kind": "function", "doc": "<p>Riemannian metric for a manifold embedded in Euclidean space</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Embedding</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.bump", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "bump", "kind": "function", "doc": "<p>Gaussian-like bump (not normalized)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.Currents", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "Currents", "kind": "function", "doc": "<p>Some arbitrary vector field (water currents)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">\u03b8</span>, </span><span class=\"param\"><span class=\"n\">\u03c6</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.BoatRouting.ArrivalTime", "modulename": "agd.ExportedCode.Notebooks_FMM.BoatRouting", "qualname": "ArrivalTime", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hfmIn</span>, </span><span class=\"param\"><span class=\"n\">params</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.DubinsState", "modulename": "agd.ExportedCode.Notebooks_FMM.DubinsState", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.DubinsState.control_source", "modulename": "agd.ExportedCode.Notebooks_FMM.DubinsState", "qualname": "control_source", "kind": "function", "doc": "<p>Returns the optimal control, or the source of the optimal jump, at each point reached \nby the front.\nInput : </p>\n\n<ul>\n<li>activeNeighs : produced by the eikonal solver, with option 'exportActiveNeighs':True</li>\n<li>ncontrols : number of controls of the model (needed in case of several states)</li>\n<li>control default : when no control is used (jump to another state, or stationnary point)</li>\n<li>jump default : when no jump is done (following a control vector, or stationnary point)\nOutput : </li>\n<li>control : the index of the control used</li>\n<li>source (only if several states) : the index of the source state of the jump</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">activeNeighs</span>, </span><span class=\"param\"><span class=\"n\">ncontrols</span>, </span><span class=\"param\"><span class=\"n\">control_default</span><span class=\"o\">=</span><span class=\"n\">nan</span>, </span><span class=\"param\"><span class=\"n\">source_default</span><span class=\"o\">=</span><span class=\"n\">nan</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants", "modulename": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants.\u03c0", "modulename": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants", "qualname": "\u03c0", "kind": "variable", "doc": "<p></p>\n", "default_value": "3.141592653589793"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants.elastica_control", "modulename": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants", "qualname": "elastica_control", "kind": "function", "doc": "<p>Control for the elastica model (two dimensional projection).\nBoundary point of the disk of radius 1/2 and center (1/2,0).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">\u03c6</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants.elastica_controls", "modulename": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants", "qualname": "elastica_controls", "kind": "function", "doc": "<p>Controls for the elastica model, regularly sampled.</p>\n\n<ul>\n<li>I : number of controls</li>\n<li>\u03d5min, \u03d5max : smallest and largest control</li>\n<li>pad : add a zero control.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">I</span>, </span><span class=\"param\"><span class=\"n\">\u03c6min</span><span class=\"o\">=-</span><span class=\"mf\">1.5707963267948966</span>, </span><span class=\"param\"><span class=\"n\">\u03c6max</span><span class=\"o\">=</span><span class=\"mf\">1.5707963267948966</span>, </span><span class=\"param\"><span class=\"n\">pad</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants.with_prior", "modulename": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants", "qualname": "with_prior", "kind": "function", "doc": "<p>Adjusts the control vectors to account for the following priors : </p>\n\n<ul>\n<li>\u03be the typical turning radius, </li>\n<li>\u03ba the reference curvature.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">\u03be</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">\u03ba</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants.embed", "modulename": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants", "qualname": "embed", "kind": "function", "doc": "<p>Embed a two dimensional control (\u03b1,\u03b2) in R^2xR as (\u03b1 n(\u03b8),\u03b2)\nwhere n(\u03b8) = (cos \u03b8, sin \u03b8)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">\u03b8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants.fejer_weights_", "modulename": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants", "qualname": "fejer_weights_", "kind": "variable", "doc": "<p></p>\n", "default_value": "[[], [2.0], [1.0, 1.0], [0.444444, 1.11111, 0.444444], [0.264298, 0.735702, 0.735702, 0.264298], [0.167781, 0.525552, 0.613333, 0.525552, 0.167781], [0.118661, 0.377778, 0.503561, 0.503561, 0.377778, 0.118661], [0.0867162, 0.287831, 0.398242, 0.454422, 0.398242, 0.287831, 0.0867162], [0.0669829, 0.222988, 0.324153, 0.385877, 0.385877, 0.324153, 0.222988, 0.0669829], [0.0527366, 0.179189, 0.264037, 0.330845, 0.346384, 0.330845, 0.264037, 0.179189, 0.0527366]]"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants.fejer_weights", "modulename": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants", "qualname": "fejer_weights", "kind": "function", "doc": "<p>Returns the Fejer weights, for computing a cosine weighted integral.\nIf I>=10, returns an approximation based on the midpoint rule.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">I</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants.elastica_terms", "modulename": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants", "qualname": "elastica_terms", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">I</span>, </span><span class=\"param\"><span class=\"n\">\u03c6min</span><span class=\"o\">=-</span><span class=\"mf\">1.5707963267948966</span>, </span><span class=\"param\"><span class=\"n\">\u03c6max</span><span class=\"o\">=</span><span class=\"mf\">1.5707963267948966</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants.in_place_rotation_controls", "modulename": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants", "qualname": "in_place_rotation_controls", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants.state_transition_base_cost", "modulename": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants", "qualname": "state_transition_base_cost", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([[0, 1],\n       [1, 0]])"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants.embed4", "modulename": "agd.ExportedCode.Notebooks_FMM.ElasticaVariants", "qualname": "embed4", "kind": "function", "doc": "<p>Embed a two dimensional control (\u03b1,\u03b2) in R^2 x R x R as (\u03b1 n(\u03b8),\u03b1 \u03ba, \u03b2)\nwhere n(\u03b8) = (cos \u03b8, sin \u03b8)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">\u03b8</span>, </span><span class=\"param\"><span class=\"n\">\u03ba</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.PoincareCost", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "PoincareCost", "kind": "function", "doc": "<p>Cost function defining the Poincare half plane model of the hyperbolic plane.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">q</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.PoincareDistance", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "PoincareDistance", "kind": "function", "doc": "<p>Distance between two points of the half plane model of the hyperbolic plane.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">q</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.diagCoef", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "diagCoef", "kind": "variable", "doc": "<p></p>\n", "default_value": "(0.25, 1)"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.diff", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "diff", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">\u03b1</span><span class=\"o\">=</span><span class=\"mf\">0.5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.RiemannMetric", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "RiemannMetric", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">diag</span>, </span><span class=\"param\"><span class=\"n\">diff</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.RiemannExact", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "RiemannExact", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">diag</span>, </span><span class=\"param\"><span class=\"n\">diff</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.M", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "M", "kind": "variable", "doc": "<p></p>\n", "default_value": "((1.25, 0.5), (0.5, 2.0))"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.v", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "v", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">\u03b3</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.RanderMetric", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "RanderMetric", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">\u03b3</span><span class=\"o\">=</span><span class=\"mf\">0.8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.RanderSolution", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "RanderSolution", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">\u03b3</span><span class=\"o\">=</span><span class=\"mf\">0.8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.ConformalMap", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "ConformalMap", "kind": "function", "doc": "<p>Implements the mapping x -> (1/2) * x^2, where x is seen as a complex variable.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.ConformalApply", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "ConformalApply", "kind": "function", "doc": "<p>Applies a conformal change of coordinates to a norm.\ndecomp : decompose the Jacobian into a scaling and rotation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">norm</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">decomp</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_FMM.HighAccuracy.MappedNormValues", "modulename": "agd.ExportedCode.Notebooks_FMM.HighAccuracy", "qualname": "MappedNormValues", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">norm</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">seed</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv", "modulename": "agd.ExportedCode.Notebooks_NonDiv", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D", "modulename": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D.norm", "modulename": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D", "qualname": "norm", "kind": "function", "doc": "<p>Returns L^p norm of array, seen as a vector, w.r.t. weights.\nDefined as : (sum_i x[i]^p)^(1/p)</p>\n\n<p>Remark : not a matrix operator norm</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>ord : exponent p</li>\n<li>axis : int or None, axis along which to compute the norm. </li>\n<li>keepdims : wether to keep singleton dimensions.</li>\n<li>averaged : wether to introduce a normalization factor, so that norm(ones(...))=1</li>\n</ul>\n\n<p>Compatible with automatic differentiation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"nb\">ord</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">keepdims</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">averaged</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D.streamplot_ij", "modulename": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D", "qualname": "streamplot_ij", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">Y</span>, </span><span class=\"param\"><span class=\"n\">VX</span>, </span><span class=\"param\"><span class=\"n\">VY</span>, </span><span class=\"param\"><span class=\"n\">subsampling</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">varargs</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D.SchemeCentered", "modulename": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D", "qualname": "SchemeCentered", "kind": "function", "doc": "<p>Discretization of a linear non-divergence form second order PDE\ncst + mult u + <omega,grad u>- tr(diff hess(u)) = 0\nSecond order accurate, centered yet monotone finite differences are used for <omega,grad u></p>\n\n<ul>\n<li>bc : boundary conditions. </li>\n<li>ret_hmax : return the largest grid scale for which monotony holds</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">cst</span>, </span><span class=\"param\"><span class=\"n\">mult</span>, </span><span class=\"param\"><span class=\"n\">omega</span>, </span><span class=\"param\"><span class=\"n\">diff</span>, </span><span class=\"param\"><span class=\"n\">bc</span>, </span><span class=\"param\"><span class=\"n\">ret_hmax</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D.SchemeUpwind", "modulename": "agd.ExportedCode.Notebooks_NonDiv.LinearMonotoneSchemes2D", "qualname": "SchemeUpwind", "kind": "function", "doc": "<p>Discretization of a linear non-divergence form second order PDE\ncst + mult u + <omega,grad u>- tr(diff hess(u)) = 0\nFirst order accurate, upwind finite differences are used for <omega,grad u></p>\n\n<ul>\n<li>bc : boundary conditions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">cst</span>, </span><span class=\"param\"><span class=\"n\">mult</span>, </span><span class=\"param\"><span class=\"n\">omega</span>, </span><span class=\"param\"><span class=\"n\">diff</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.newton_root", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "newton_root", "kind": "function", "doc": "<p>Newton's method, for finding a root of a given function.\nf : function to be solved\nx0 : initial guess for the root\nstop : stopping criterion, presented as either</p>\n\n<ul>\n<li>keyword \"Default\" for using the stop_default class</li>\n<li>a dict for using the stop_class with specified initialization arguments</li>\n<li>a callable, <br />\nrelax : added to the jacobian before inversion\ndamping : criterion for step reduction\nad : is either </li>\n<li>keyword \"Sparse\" for using Sparse AD (Default)</li>\n<li>keyword \"Dense\" for using Dense AD</li>\n<li>a shape_bound given as a tuple, for Dense AD with few independent variables</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">f</span>,</span><span class=\"param\">\t<span class=\"n\">x0</span>,</span><span class=\"param\">\t<span class=\"n\">fargs</span><span class=\"o\">=</span><span class=\"p\">()</span>,</span><span class=\"param\">\t<span class=\"n\">stop</span><span class=\"o\">=</span><span class=\"s1\">&#39;Default&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">relax</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">damping</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ad</span><span class=\"o\">=</span><span class=\"s1\">&#39;Sparse&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">solver</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">in_place</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.stop", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "stop", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;class &#x27;agd.AutomaticDifferentiation.Optimization.stop_default&#x27;&gt;"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.damping", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "damping", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;class &#x27;agd.AutomaticDifferentiation.Optimization.damping_default&#x27;&gt;"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.norm", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "norm", "kind": "function", "doc": "<p>Returns L^p norm of array, seen as a vector, w.r.t. weights.\nDefined as : (sum_i x[i]^p)^(1/p)</p>\n\n<p>Remark : not a matrix operator norm</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>ord : exponent p</li>\n<li>axis : int or None, axis along which to compute the norm. </li>\n<li>keepdims : wether to keep singleton dimensions.</li>\n<li>averaged : wether to introduce a normalization factor, so that norm(ones(...))=1</li>\n</ul>\n\n<p>Compatible with automatic differentiation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"nb\">ord</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">keepdims</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">averaged</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeNonMonotone", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeNonMonotone", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.MALBR_H", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "MALBR_H", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d2u</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeMALBR", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeMALBR", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">SB</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.InvalidMALBR", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "InvalidMALBR", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">SB</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeMALBR_OptInner", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeMALBR_OptInner", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">SB</span>, </span><span class=\"param\"><span class=\"n\">bc</span>, </span><span class=\"param\"><span class=\"n\">oracle</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeMALBR_Opt", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeMALBR_Opt", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">SB</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.ConstrainedMaximize", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "ConstrainedMaximize", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Q</span>, </span><span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeUniform", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeUniform", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">SB</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeUniform_OptInner", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeUniform_OptInner", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">SB</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">bc</span>, </span><span class=\"param\"><span class=\"n\">oracle</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.SchemeUniform_Opt", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "SchemeUniform_Opt", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">SB</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.Hessian_ad", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "Hessian_ad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere.MongeAmpere_ad", "modulename": "agd.ExportedCode.Notebooks_NonDiv.MongeAmpere", "qualname": "MongeAmpere_ad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D.Gradient", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D", "qualname": "Gradient", "kind": "function", "doc": "<p>Approximates grad u(x), using finite differences along the axes of A.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">bc</span>, </span><span class=\"param\"><span class=\"n\">decomp</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D.SchemeCentered", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D", "qualname": "SchemeCentered", "kind": "function", "doc": "<p>Discretization of - Tr(A(x) hess u(x)) + F(grad u(x)) - rhs,\nwith Dirichlet boundary conditions. The scheme is second order,\nand degenerate elliptic under suitable assumptions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">F</span>, </span><span class=\"param\"><span class=\"n\">rhs</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D.SchemeCentered_Quad", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D", "qualname": "SchemeCentered_Quad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">omega</span>, </span><span class=\"param\"><span class=\"n\">D</span>, </span><span class=\"param\"><span class=\"n\">rhs</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D.SchemeUpwind", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneFirst2D", "qualname": "SchemeUpwind", "kind": "function", "doc": "<p>Discretization of -Tr(A(x) hess u(x)) + \\| grad u(x) - omega(x) \\|_D(x)^2 - rhs,\nwith Dirichlet boundary conditions, using upwind finite differences for the first order part.\nThe scheme is degenerate elliptic if A and D are positive definite.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">omega</span>, </span><span class=\"param\"><span class=\"n\">D</span>, </span><span class=\"param\"><span class=\"n\">rhs</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.SchemeNonMonotone", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "SchemeNonMonotone", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">\u03b1</span>, </span><span class=\"param\"><span class=\"n\">\u03b2</span>, </span><span class=\"param\"><span class=\"n\">bc</span>, </span><span class=\"param\"><span class=\"n\">sqrt_relax</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.SchemeSampling", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "SchemeSampling", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">diffs</span>, </span><span class=\"param\"><span class=\"n\">\u03b2</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.Diff", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "Diff", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">\u03b1</span>, </span><span class=\"param\"><span class=\"n\">\u03b8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.SchemeSampling_OptInner", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "SchemeSampling_OptInner", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">diffs</span>, </span><span class=\"param\"><span class=\"n\">bc</span>, </span><span class=\"param\"><span class=\"n\">oracle</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.SchemeSampling_Opt", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "SchemeSampling_Opt", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">diffs</span>, </span><span class=\"param\"><span class=\"n\">\u03b2</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.MakeD", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "MakeD", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">\u03b1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.NextAngleAndSuperbase", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "NextAngleAndSuperbase", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">\u03b8</span>, </span><span class=\"param\"><span class=\"n\">sb</span>, </span><span class=\"param\"><span class=\"n\">D</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.AnglesAndSuperbases", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "AnglesAndSuperbases", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">D</span>, </span><span class=\"param\"><span class=\"n\">maxiter</span><span class=\"o\">=</span><span class=\"mi\">200</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.MinimizeTrace", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "MinimizeTrace", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">\u03b1</span>, </span><span class=\"param\"><span class=\"n\">bc</span>, </span><span class=\"param\"><span class=\"n\">sqrt_relax</span><span class=\"o\">=</span><span class=\"mf\">1e-16</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.SchemeConsistent", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "SchemeConsistent", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">\u03b1</span>, </span><span class=\"param\"><span class=\"n\">\u03b2</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.MinimizeTrace_Opt", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "MinimizeTrace_Opt", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">\u03b1</span>, </span><span class=\"param\"><span class=\"n\">bc</span>, </span><span class=\"param\"><span class=\"n\">oracle</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.SchemeConsistent_Opt", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "SchemeConsistent_Opt", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">\u03b1</span>, </span><span class=\"param\"><span class=\"n\">\u03b2</span>, </span><span class=\"param\"><span class=\"n\">bc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D.Pucci_ad", "modulename": "agd.ExportedCode.Notebooks_NonDiv.NonlinearMonotoneSecond2D", "qualname": "Pucci_ad", "kind": "function", "doc": "<p>Computes alpha*lambda_max(D^2 u) + lambda_min(D^2 u), \nat the given set of points, by automatic differentiation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">\u03b1</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.EvalScheme", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "EvalScheme", "kind": "function", "doc": "<p>Evaluates the (piecewise) quadratic equation defining the numerical scheme.\nInputs :</p>\n\n<ul>\n<li>uc : plays the role of \u03bb</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cp</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">uc</span>, </span><span class=\"param\"><span class=\"n\">params</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.LocalSolve", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "LocalSolve", "kind": "function", "doc": "<p>Solve the (piecewise) quadratic equation defining the numerical scheme.\nOutput: solution \u03bb.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cp</span>, </span><span class=\"param\"><span class=\"n\">vx</span>, </span><span class=\"param\"><span class=\"n\">vy</span>, </span><span class=\"param\"><span class=\"n\">wx</span>, </span><span class=\"param\"><span class=\"n\">wy</span>, </span><span class=\"param\"><span class=\"n\">params</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.JacobiIteration", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "JacobiIteration", "kind": "function", "doc": "<p>One Jacobi iteration, returning the pointwise solution \u03bb to the numerical scheme.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">Omega</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">params</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.OneBump", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "OneBump", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.ThreeBumps", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "ThreeBumps", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.Volcano", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "Volcano", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading.GenerateRHS", "modulename": "agd.ExportedCode.Notebooks_NonDiv.ShapeFromShading", "qualname": "GenerateRHS", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">height</span>, </span><span class=\"param\"><span class=\"n\">params</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.Time1D_NonDiv", "modulename": "agd.ExportedCode.Notebooks_NonDiv.Time1D_NonDiv", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ExportedCode.Notebooks_NonDiv.Time1D_NonDiv.accumulate", "modulename": "agd.ExportedCode.Notebooks_NonDiv.Time1D_NonDiv", "qualname": "accumulate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">iterable</span>, </span><span class=\"param\"><span class=\"n\">func</span>, </span><span class=\"param\"><span class=\"n\">initial</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences", "modulename": "agd.FiniteDifferences", "kind": "module", "doc": "<p>This module implements some finite differences operations, as well as related array \nreshaping and broadcasting operations. The main functions are the following, see the \nthe detailed help below.</p>\n\n<p>Elementary finite differences:</p>\n\n<ul>\n<li>DiffUpwind</li>\n<li>DiffCentered</li>\n<li>Diff2</li>\n</ul>\n\n<p>Array broadcasting:</p>\n\n<ul>\n<li>as_field</li>\n<li>common_field</li>\n</ul>\n\n<p>Block based array reshaping:</p>\n\n<ul>\n<li>block_expand</li>\n<li>block_squeeze</li>\n</ul>\n"}, {"fullname": "agd.FiniteDifferences.as_field", "modulename": "agd.FiniteDifferences", "qualname": "as_field", "kind": "function", "doc": "<p>Checks if the last dimensions of u match the given shape. \nIf not, u is extended with these additional dimensions.\nconditional : if False, reshaping is always done\ndepth (optional) : the depth of the geometrical tensor field (1: vectors, 2: matrices)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">shape</span>, </span><span class=\"param\"><span class=\"n\">conditional</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">depth</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.common_shape", "modulename": "agd.FiniteDifferences", "qualname": "common_shape", "kind": "function", "doc": "<p>Finds a common shape to the arrays for broadcasting</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arrays</span>, </span><span class=\"param\"><span class=\"n\">depths</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.common_field", "modulename": "agd.FiniteDifferences", "qualname": "common_field", "kind": "function", "doc": "<p>Adds trailing dimensions, and broadcasts the given arrays, for suitable interoperation.</p>\n\n<p>Inputs: </p>\n\n<ul>\n<li>arrays : a list [a_1,...,a_n], or iterable, of numeric arrays such that\na_i.shape = shape_i + shape, or a_i.shape = shape_i, for each 1&lt;=i&lt;=n.</li>\n<li>depths : defined as [len(shape_i) for 1&lt;=i&lt;=n]</li>\n<li>shape (optional) : the trailing shape.</li>\n</ul>\n\n<p>Output:</p>\n\n<ul>\n<li>the arrays, with added trailing and dimensions broadcasting so that\na_i.shape = shape_i + shape for each 1&lt;=i&lt;=n.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arrays</span>, </span><span class=\"param\"><span class=\"n\">depths</span>, </span><span class=\"param\"><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.round_up_ratio", "modulename": "agd.FiniteDifferences", "qualname": "round_up_ratio", "kind": "function", "doc": "<p>Returns the least multiple of den after num.\nnum and den must be integers, with den>0.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">num</span>, </span><span class=\"param\"><span class=\"n\">den</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.block_expand", "modulename": "agd.FiniteDifferences", "qualname": "block_expand", "kind": "function", "doc": "<p>Reshape an array so as to factor shape_i (the inner shape),\nand move these axes last.\nInputs : </p>\n\n<ul>\n<li>**kwargs : passed to np.pad\nOutput : </li>\n<li>padded and reshaped array</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">shape_i</span>, </span><span class=\"param\"><span class=\"n\">shape_o</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.block_squeeze", "modulename": "agd.FiniteDifferences", "qualname": "block_squeeze", "kind": "function", "doc": "<p>Inverse operation to block_expand.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">shape</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.block_neighbors", "modulename": "agd.FiniteDifferences", "qualname": "block_neighbors", "kind": "function", "doc": "<p>The first layer of neighbors to a block, along the top or bottom, ordered \nby increasing indices. Used for efficient data load when a implementing \ngradients, divergences, etc, with a compact scheme</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape_i</span>, </span><span class=\"param\"><span class=\"n\">top</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.BoundedSlices", "modulename": "agd.FiniteDifferences", "qualname": "BoundedSlices", "kind": "function", "doc": "<p>Returns the input slices with None replaced with the upper bound\nfrom the given shape</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">slices</span>, </span><span class=\"param\"><span class=\"n\">shape</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.OffsetToIndex", "modulename": "agd.FiniteDifferences", "qualname": "OffsetToIndex", "kind": "function", "doc": "<p>Returns the index corresponding to position + offset, \nand a boolean for wether it falls inside the domain.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span>, </span><span class=\"param\"><span class=\"n\">offset</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;clip&#39;</span>, </span><span class=\"param\"><span class=\"n\">uniform</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">where</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"bp\">Ellipsis</span><span class=\"p\">,)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.TakeAtOffset", "modulename": "agd.FiniteDifferences", "qualname": "TakeAtOffset", "kind": "function", "doc": "<ul>\n<li>padding: outside fill value. Set padding=None for periodic boundary conditions</li>\n<li>**kwargs : passed to OffsetToIndex</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offset</span>, </span><span class=\"param\"><span class=\"n\">padding</span><span class=\"o\">=</span><span class=\"n\">nan</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.AlignedSum", "modulename": "agd.FiniteDifferences", "qualname": "AlignedSum", "kind": "function", "doc": "<p>Returns sum along the direction offset, with specified multiples and weights.\nInput : </p>\n\n<ul>\n<li>kwargs : passed to TakeAtOffset</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offset</span>, </span><span class=\"param\"><span class=\"n\">multiples</span>, </span><span class=\"param\"><span class=\"n\">weights</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.Diff2", "modulename": "agd.FiniteDifferences", "qualname": "Diff2", "kind": "function", "doc": "<p>Approximates <offset, (d^2 u) offset> with specified accuracy order.\nWhen order=2, corresponds to the (negated) degenerate elliptic scheme\n$$\n        <e,(d^2 u) e> = (u(x+h<em>e)-2</em>u(x)+u(x-h*e))/h^2 + O(h^2),\n$$\nwhere e = offset and h=gridScale.\nInput : </p>\n\n<ul>\n<li>u : array of shape (n1,...,nd) where n1,...,nd are the domain dimensions</li>\n<li>offset : array with integer entries, of shape (d,k1,...,kr,n1,...,nd) or (d,k1,...,kr)\nwhere d is the number of dimensions in the domain, and k1,...,kr are arbitrary.</li>\n<li>gridscale (optional) : scale of the discretization grid used in the finite differences</li>\n<li>order (optional) : approximation order of the finite differences</li>\n<li>kwargs : passed to AlignedSum</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offset</span>, </span><span class=\"param\"><span class=\"n\">gridScale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.DiffUpwind", "modulename": "agd.FiniteDifferences", "qualname": "DiffUpwind", "kind": "function", "doc": "<p>Approximates <grad u, offset> with specified accuracy order.\nWhen order=1, corresponds the (negated) degenerate elliptic scheme\n$$\n         <grad u, e> = (u(x+h*e)-u(x))/h + O(h)\n$$\nwhere e = offset and h=gridScale.\nInput : </p>\n\n<ul>\n<li>u : array of shape (n1,...,nd) where n1,...,nd are the domain dimensions</li>\n<li>offset : array with integer entries, of shape (d,k1,...,kr,n1,...,nd) or (d,k1,...,kr)\nwhere d is the number of dimensions in the domain, and k1,...,kr are arbitrary.</li>\n<li>gridscale (optional) : scale of the discretization grid used in the finite differences</li>\n<li>order (optional) : approximation order of the finite differences</li>\n<li>kwargs : passed to AlignedSum</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offset</span>, </span><span class=\"param\"><span class=\"n\">gridScale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.DiffCentered", "modulename": "agd.FiniteDifferences", "qualname": "DiffCentered", "kind": "function", "doc": "<p>Approximates <d u, offset> with specified accuracy order.\nWhen order=2, corresponds to the centered finite difference\n$$\n         <grad u, e> = (u(x+h<em>e)-u(x-h</em>e))/(2h) + O(h^2)\n$$\nwhere e = offset and h=gridScale.\n        Input : </p>\n\n<ul>\n<li>u : array of shape (n1,...,nd) where n1,...,nd are the domain dimensions</li>\n<li>offset : array with integer entries, of shape (d,k1,...,kr,n1,...,nd) or (d,k1,...,kr)\nwhere d is the number of dimensions in the domain, and k1,...,kr are arbitrary.</li>\n<li>gridscale (optional) : scale of the discretization grid used in the finite differences</li>\n<li>order (optional) : approximation order of the finite differences</li>\n<li>kwargs : passed to AlignedSum</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offset</span>, </span><span class=\"param\"><span class=\"n\">gridScale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.DiffCross", "modulename": "agd.FiniteDifferences", "qualname": "DiffCross", "kind": "function", "doc": "<p>Approximates <offsets0, (d^2 u) offset1> with second order accuracy.\nCentered finite differences scheme, but lacking the degenerate ellipticity property.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offset0</span>, </span><span class=\"param\"><span class=\"n\">offset1</span>, </span><span class=\"param\"><span class=\"n\">gridScale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.AxesOffsets", "modulename": "agd.FiniteDifferences", "qualname": "AxesOffsets", "kind": "function", "doc": "<p>Returns the offsets corresponding to the axes.\n        Inputs : </p>\n\n<ul>\n<li>offsets (optional). Defaults to np.eye(dimension)</li>\n<li>dimension (optional). Defaults to u.ndim</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">offsets</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">dimension</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.DiffHessian", "modulename": "agd.FiniteDifferences", "qualname": "DiffHessian", "kind": "function", "doc": "<p>Approximates the matrix (<offsets[i], (d^2 u) offsets[j]&gt; )_{ij}, using AxesOffsets as offsets.\nCentered and cross finite differences are used, thus lacking the degenerate ellipticity property.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offsets</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">dimension</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.DiffGradient", "modulename": "agd.FiniteDifferences", "qualname": "DiffGradient", "kind": "function", "doc": "<p>Approximates the vector (<d u, offsets[i]&gt;)_i, using AxesOffsets as offsets\nCentered finite differences are used, thus lacking the degerate ellipticity property.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offsets</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">dimension</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.DiffEll", "modulename": "agd.FiniteDifferences", "qualname": "DiffEll", "kind": "function", "doc": "<p>Helper function for discretizing (<grad u,e> - \u03b1)^2, which appears in elliptic energies. Returns \n$$\n    [u(x)-u(x-h<em>e)-\u03b1h, u(x+h</em>e)-u(x)-\u03b1h]/(h sqrt(2))\n$$\nif order=2. Sum the squares to approximate (<grad u,e>-\u03b1)^2. Also accepts order=4.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">offset</span>, </span><span class=\"param\"><span class=\"n\">gridScale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">\u03b1</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.FiniteDifferences.UniformGridInterpolator1D", "modulename": "agd.FiniteDifferences", "qualname": "UniformGridInterpolator1D", "kind": "function", "doc": "<p>Interpolation on a uniform grid. mode is in ('clip','wrap', ('fill',fill_value) )</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bounds</span>, </span><span class=\"param\"><span class=\"n\">values</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;clip&#39;</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=-</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Interpolation", "modulename": "agd.Interpolation", "kind": "module", "doc": "<p>This file implements some spline interpolation methods, on uniform grids,\nin a manner compatible with automatic differentiation.</p>\n\n<p>If you do not need to differentiate the interpolated value w.r.t. the position,\n then using ndimage_map_coordinates is in likely to be more efficient numerically (but uses only\n float32 accuracy).</p>\n"}, {"fullname": "agd.Interpolation.origin_scale_shape", "modulename": "agd.Interpolation", "qualname": "origin_scale_shape", "kind": "function", "doc": "<p>This function is indended for extracting the origin, scale, and shape,\nof a uniform coordinate system provided as a meshgrid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">grid</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Interpolation.coordinates_on_grid", "modulename": "agd.Interpolation", "qualname": "coordinates_on_grid", "kind": "function", "doc": "<p>Rescale coordinates relatively to a uniform grid : (coordinates-origin)/scale</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">coordinates</span>, </span><span class=\"param\"><span class=\"n\">grid</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Interpolation.ndimage_map_coordinates", "modulename": "agd.Interpolation", "qualname": "ndimage_map_coordinates", "kind": "function", "doc": "<p>Wrapper over the ndimage.map_coordinates function, with the following helper tools : </p>\n\n<ul>\n<li>rescale the coordinates using a reference grid.</li>\n<li>dispatch to cupyx.scipy.ndimage.map_coordinates if needed.</li>\n<li>interpolate tensor data (geometry first)</li>\n<li>AD type supported on input</li>\n<li>AD type supported on coordinates (dispatch to reimplementation below)</li>\n</ul>\n\n<p>Additional input : </p>\n\n<ul>\n<li>grid (optional) : reference coordinate system, which must be uniform</li>\n<li><em>args,</em>*kwargs : passed to scipy.ndimage.map_coordinates (or cupyx equivalent)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"nb\">input</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">grid</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Interpolation.spline_base", "modulename": "agd.Interpolation", "qualname": "spline_base", "kind": "function", "doc": "<p>Basic spline functions, evaluated at x,x+1,..., over their support, where 0&lt;=x&lt;=1</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">3</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Interpolation.spline_weighted", "modulename": "agd.Interpolation", "qualname": "spline_weighted", "kind": "function", "doc": "<p>Evaluate splines at position x, weighted by coefficients coef, with reflected boundary conditions</p>\n\n<ul>\n<li>c : spline coefficients, array of shape (m1,...,mk,n1,...,nd)</li>\n<li>x : spline evaluation position, array of shape (d,p1,...,pl)</li>\n</ul>\n\n<p>Returns : </p>\n\n<ul>\n<li>weighted spline, array of shape (m1,...,mk,p1,...,pl)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">3</span>, </span><span class=\"param\"><span class=\"n\">overwrite_x</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">periodic</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Interpolation.spline_coefs", "modulename": "agd.Interpolation", "qualname": "spline_coefs", "kind": "function", "doc": "<p>Produces coefficients such that spline weighted better approximates the values of c. For odd \norder, the values at the grid nodes (integer coordinates) are exactly reproduced.</p>\n\n<p>Input : </p>\n\n<ul>\n<li>c : values of the function to be interpolated</li>\n<li>order (int, default=3) : spline interpolation order.</li>\n</ul>\n\n<p>Output : </p>\n\n<ul>\n<li>spline weights, assuming reflect boundary conditions, for use in spline_weighted</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">3</span>, </span><span class=\"param\"><span class=\"n\">depth</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">periodic</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Interpolation.map_coordinates", "modulename": "agd.Interpolation", "qualname": "map_coordinates", "kind": "function", "doc": "<p>Partial reimplementation of map_coordinates, which allows (input and) coordinates to be AD arrays.\nAppears to be much more accurate that ndimage.map_coordinates, which likely uses float32 internally</p>\n\n<ul>\n<li>grid : rescale the coordinates according to this grid</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"nb\">input</span>,</span><span class=\"param\">\t<span class=\"n\">coordinates</span>,</span><span class=\"param\">\t<span class=\"n\">output</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;constant&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">cval</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">prefilter</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">grid</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">periodic</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Interpolation.UniformGridInterpolation", "modulename": "agd.Interpolation", "qualname": "UniformGridInterpolation", "kind": "class", "doc": "<p>Interpolates values on a uniform grid, in arbitrary dimension, using splines of \na given order. Uses the reimplementation of map_coordinates, which allows evaluating at \nAD types for position.</p>\n"}, {"fullname": "agd.Interpolation.UniformGridInterpolation.__init__", "modulename": "agd.Interpolation", "qualname": "UniformGridInterpolation.__init__", "kind": "function", "doc": "<ul>\n<li>grid (ndarray) : must be a uniform grid. E.g. np.meshgrid(aX,aY,indexing='ij')\nwhere aX,aY have uniform spacing. Alternatively, provide only the axes.</li>\n<li>values (ndarray) : interpolated values.</li>\n<li>order (int, tuple of ints) : spline interpolation order, along each axis.</li>\n<li>periodic (bool, tuple of bool) : wether periodic interpolation, along each axis.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid</span>,</span><span class=\"param\">\t<span class=\"n\">values</span>,</span><span class=\"param\">\t<span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;reflect&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">check_grid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">periodic</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "agd.Interpolation.UniformGridInterpolation.order", "modulename": "agd.Interpolation", "qualname": "UniformGridInterpolation.order", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Interpolation.UniformGridInterpolation.periodic", "modulename": "agd.Interpolation", "qualname": "UniformGridInterpolation.periodic", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Interpolation.UniformGridInterpolation.coefs", "modulename": "agd.Interpolation", "qualname": "UniformGridInterpolation.coefs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.LinearPDE", "modulename": "agd.LinearPDE", "kind": "module", "doc": "<p>This module is DEPRECATED, but kept for compatibility.</p>\n"}, {"fullname": "agd.LinearPDE.OperatorMatrix", "modulename": "agd.LinearPDE", "qualname": "OperatorMatrix", "kind": "function", "doc": "<p>Constructs a linear operator sparse matrix, given as input </p>\n\n<ul>\n<li>an array <code>diff</code> of symmetric positive definite matrices, \nwith shape $(d,d,n_1,...,n_d)$ where $d$ is the domain dimension.</li>\n<li>an array <code>omega</code> of vectors (optionnal), with shape $(d,n_1,...,n_d)$.</li>\n<li>an array of scalars (optionnal), with shape $(n_1,...,n_d)$.</li>\n</ul>\n\n<p>additional parameters</p>\n\n<ul>\n<li>a grid scale </li>\n<li>boundary conditions, possibly axis by axis \n('Periodic', 'Reflected', 'Neumann', 'Dirichlet') </li>\n<li>divergence form or not</li>\n</ul>\n\n<p>The discretized operator is\n$$\n {-} \\mathrm{div}(D \\nabla u) + &lt; \\omega, \\nabla u> + mult*u,\n$$\ndenoting $D:=$<code>diff</code> and $\\omega:=$<code>omega</code>.</p>\n\n<p>Replace the first term with $\\mathrm{Tr}(D \\nabla^2 u)$ in the \nnon-divergence form case.</p>\n\n<p>Returns : a list of triplets, for building a coo matrix</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">diff</span>,</span><span class=\"param\">\t<span class=\"n\">omega</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">mult</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">gridScale</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">boundaryConditions</span><span class=\"o\">=</span><span class=\"s1\">&#39;Periodic&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">divergenceForm</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">intrinsicDrift</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel", "modulename": "agd.LinearParallel", "kind": "module", "doc": "<p>This module implements some basic linear algebra routines, with the following characteristics.</p>\n\n<ul>\n<li>The geometry comes first, a.k.a vector has shape (vdim, n1,...,nk) where vdim is the \nambient vector space dimension, and n1,...,nk are arbitrary. \nNote that <em>numpy uses the opposite convention</em>, putting vdim in last position.</li>\n<li>The routines are compatible with forward automatic differentiation, see module\nAutomaticDifferentiation.</li>\n</ul>\n"}, {"fullname": "agd.LinearParallel.identity", "modulename": "agd.LinearParallel", "qualname": "identity", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.rotation", "modulename": "agd.LinearParallel", "qualname": "rotation", "kind": "function", "doc": "<p>Dimension 2 : by a given angle.\nDimension 3 : by a given angle, along a given axis.\nThree dimensional rotation matrix, with given axis and angle.\nAdapted from <a href=\"https://stackoverflow.com/a/6802723\">https://stackoverflow.com/a/6802723</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">theta</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.dot_VV", "modulename": "agd.LinearParallel", "qualname": "dot_VV", "kind": "function", "doc": "<p>Dot product <v,w> of two vectors.\nInputs : </p>\n\n<ul>\n<li>v,w : arrays of shape (vdim, n1,...,nk), \nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">w</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.dot_AV", "modulename": "agd.LinearParallel", "qualname": "dot_AV", "kind": "function", "doc": "<p>Dot product a.v of a matrix and vector.\nInputs : </p>\n\n<ul>\n<li>a : array of shape (wdim,vdim, n1,...,nk)</li>\n<li>v : array of shape (vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.dot_VA", "modulename": "agd.LinearParallel", "qualname": "dot_VA", "kind": "function", "doc": "<p>Dot product v^T.a of a vector and matrix.\nInputs : </p>\n\n<ul>\n<li>v : array of shape (vdim, n1,...,nk)</li>\n<li>a : array of shape (vdim,wdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.dot_AA", "modulename": "agd.LinearParallel", "qualname": "dot_AA", "kind": "function", "doc": "<p>Dot product a.b of two matrices.\nInputs : </p>\n\n<ul>\n<li>a: array of shape (vdim,wdim, n1,...,nk),</li>\n<li>a: array of shape (wdim,xdim, n1,...,nk),</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.dot_VAV", "modulename": "agd.LinearParallel", "qualname": "dot_VAV", "kind": "function", "doc": "<p>Dot product <v,a.w> of two vectors and a matrix (usually symmetric).\nInputs (typical): </p>\n\n<ul>\n<li>v: array of shape (vdim, n1,...,nk),  </li>\n<li>a: array of shape (vdim,vdim, n1,...,nk),</li>\n<li>w: array of shape (vdim, n1,...,nk),</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">w</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.mult", "modulename": "agd.LinearParallel", "qualname": "mult", "kind": "function", "doc": "<p>Multiplication by scalar, of a vector or matrix</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.perp", "modulename": "agd.LinearParallel", "qualname": "perp", "kind": "function", "doc": "<p>Rotates a vector by pi/2, producing [v[1],v[0]]\nInputs: </p>\n\n<ul>\n<li>v: array of shape (2, n1,...,nk)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.cross", "modulename": "agd.LinearParallel", "qualname": "cross", "kind": "function", "doc": "<p>Cross product v x w of two vectors.\nInputs: </p>\n\n<ul>\n<li>v,w: arrays of shape (3, n1,...,nk)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">w</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.outer", "modulename": "agd.LinearParallel", "qualname": "outer", "kind": "function", "doc": "<p>Outer product v w^T of two vectors.\nInputs : </p>\n\n<ul>\n<li>v,w: arrays of shape (vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">w</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.outer_self", "modulename": "agd.LinearParallel", "qualname": "outer_self", "kind": "function", "doc": "<p>Outer product v v^T of a vector with itself.\nInputs : </p>\n\n<ul>\n<li>v: array of shape (vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.transpose", "modulename": "agd.LinearParallel", "qualname": "transpose", "kind": "function", "doc": "<p>Transpose a^T of a matrix.\nInput : </p>\n\n<ul>\n<li>a: array of shape (vdim,wdim, n1,...,nk),</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.trace", "modulename": "agd.LinearParallel", "qualname": "trace", "kind": "function", "doc": "<p>Trace tr(a) of a square matrix, a.k.a sum of the diagonal elements.\nInput : </p>\n\n<ul>\n<li>a: array of shape (vdim,vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.det", "modulename": "agd.LinearParallel", "qualname": "det", "kind": "function", "doc": "<p>Determinant of a square matrix.\nInput : </p>\n\n<ul>\n<li>a: array of shape (vdim,vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.inverse", "modulename": "agd.LinearParallel", "qualname": "inverse", "kind": "function", "doc": "<p>Inverse of a square matrix.\nInput : </p>\n\n<ul>\n<li>a: array of shape (vdim,vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension.</li>\n<li>avoid_np_linalg_inv: for unknown reasons, the np.linalg.inv routine can be very slow \nwhen applied to large arrays of many small matrices. (numpy 1.23.3, mac OS, M1 processor)\nUse an explicit inversion instead, via Cramer's formula, implemented for shape (2,2) and (3,3)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">avoid_np_linalg_inv</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.LinearParallel.solve_AV", "modulename": "agd.LinearParallel", "qualname": "solve_AV", "kind": "function", "doc": "<p>Solution to a linear system (preferably low dimensional).\nInput : </p>\n\n<ul>\n<li>a: array of shape (vdim,vdim, n1,...,nk),</li>\n<li>v: array of shape (vdim,vdim, n1,...,nk),\nwhere vdim is the ambient vector space dimension</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics", "modulename": "agd.Metrics", "kind": "module", "doc": "<p>The Metrics package defines a variety of norms on R^d, defined by appropriate parameters,\npossibly non-symmetric. The data of a such a norm, at each point of a domain, is referred \nto as a metric, for instance a Riemannian metric, and defines a path-length distance \nover the domain.</p>\n\n<p>Metrics are the fundamental input to (generalized) eikonal equations, which can be solved\nusing the provided Eikonal module.</p>\n\n<p>Main norm/metric classes:</p>\n\n<ul>\n<li>Isotropic : a multiple of the Euclidean norm on $R^d$.</li>\n<li>Diagonal : axis-dependent multiple of the Euclidean norm.</li>\n<li>Riemann : anisotropic norm on $R^d$ defined by a symmetric positice definite matrix of \nshape $(d,d)$. Used to define a Riemannian metric.</li>\n<li>Rander : non-symmetric anisotropic norm, defined as the sum of a Riemann norm and \nof a drift term.</li>\n<li>AsymQuad : non-symmetric anisotropic norm, defined by gluing two Riemann norms along \na hyperplane.</li>\n</ul>\n\n<p>Additional norm/metric classes are defined in the Seismic subpackage.</p>\n"}, {"fullname": "agd.Metrics.make_metric", "modulename": "agd.Metrics", "qualname": "make_metric", "kind": "function", "doc": "<p>Defines the metric F(x) = sqrt(a^2 x.m.x + sign(a)(w.x)_+^2) + w_rander.x,\nwith expected defauts for m,w,a,w_rander.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">w</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">w_rander</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">geometry_last</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic", "modulename": "agd.Metrics.Seismic", "kind": "module", "doc": "<p>The seismic package defines norms/metrics that characterize the first arrival time of\nelastic waves in anisotropic materials. It also provides helper functions for solving \nthe elastic wave equation itself.</p>\n\n<p>Main metric/norm classes:</p>\n\n<ul>\n<li>Hooke : norm defined by a Hooke tensor, corresponding to the fastest velocity.</li>\n<li>TTI : tilted transversally isotropic norm.</li>\n</ul>\n"}, {"fullname": "agd.Metrics.Seismic.hooke", "modulename": "agd.Metrics.Seismic.hooke", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke", "kind": "class", "doc": "<p>The <em>dual</em> norm defined by a Hooke tensor takes the form \n$$\nF^*(x) = \\max_{|y|\\leq 1} \\sqrt{\\sum_{ijkl} c_{ijkl} x_i y_j x_k y_l}\n$$\nwhere c is the Hooke tensor, and y ranges over the unit ball.\nThe primal norm is obtained implicitly, by solving an optimization problem.</p>\n\n<p>These norms characterize the arrival time of pressure waves in elasticity. \nThey are often encountered in seismic traveltime tomography.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>hooke : an array of shape (hdim,hdim,n1,...,nk) where hdim = vdim*(vdim+1)/2\nand vdim is the ambient space dimension. The array must be symmetric, and encodes the\nhooke tensor c in Voigt notation.</li>\n<li><em>args,</em>*kwargs (optional) : passed to ImplicitBase</li>\n</ul>\n", "bases": "agd.Metrics.Seismic.implicit_base.ImplicitBase"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.__init__", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hooke</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.hooke", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.hooke", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.is_definite", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.is_definite", "kind": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.vdim", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.vdim", "kind": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.shape", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.shape", "kind": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.model_HFM", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.model_HFM", "kind": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.flatten", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.flatten", "kind": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.expand", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.expand", "kind": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.with_cost", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.with_cost", "kind": "function", "doc": "<p>Produces a norm $N'$ obeying $N'(x) = N(cost*x)$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cost</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.extract_xz", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.extract_xz", "kind": "function", "doc": "<p>Extract a two dimensional Hooke tensor from a three dimensional one, \ncorresponding to a slice through the X and Z axes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_VTI_2", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_VTI_2", "kind": "function", "doc": "<p>X,Z slice of a Vertical Transverse Isotropic medium\nbased on Thomsen parameters</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">Vp</span>, </span><span class=\"param\"><span class=\"n\">Vs</span>, </span><span class=\"param\"><span class=\"n\">\u03b5</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_Ellipse", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_Ellipse", "kind": "function", "doc": "<p>Rank deficient Hooke tensor,\nequivalent, for pressure waves, to the Riemannian metric defined by $m ^ {-2}$.\nShear waves are infinitely slow.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_cast", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_cast", "kind": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">metric</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.to_depth4", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.to_depth4", "kind": "function", "doc": "<p>Produces the full Hooke tensor, of shape\n(vdim,vdim,vdim,vdim, n1,...,nk)\nwhere vdim is the ambient space dimension.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.rotate", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.rotate", "kind": "function", "doc": "<p>Rotation of the norm, by a given rotation matrix.\nThe new unit ball is the direct image of the previous one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">r</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.to_Mandel", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.to_Mandel", "kind": "function", "doc": "<p>Introduces the $\\sqrt 2$ and $2$ factors involved in Mandel's notation</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mf\">1.4142135623730951</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_Mandel", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_Mandel", "kind": "function", "doc": "<p>Removes the $\\sqrt 2$ and $2$ factors involved in Mandel's notation</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">mandel</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mf\">1.4142135623730951</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_orthorombic", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_orthorombic", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">c11</span>, </span><span class=\"param\"><span class=\"n\">c12</span>, </span><span class=\"param\"><span class=\"n\">c13</span>, </span><span class=\"param\"><span class=\"n\">c22</span>, </span><span class=\"param\"><span class=\"n\">c23</span>, </span><span class=\"param\"><span class=\"n\">c33</span>, </span><span class=\"param\"><span class=\"n\">c44</span>, </span><span class=\"param\"><span class=\"n\">c55</span>, </span><span class=\"param\"><span class=\"n\">c66</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_orthorombic2", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_orthorombic2", "kind": "function", "doc": "<p>Orthorombic medium with a different ordering of the first block coefficients</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">c11</span>, </span><span class=\"param\"><span class=\"n\">c21</span>, </span><span class=\"param\"><span class=\"n\">c22</span>, </span><span class=\"param\"><span class=\"n\">c31</span>, </span><span class=\"param\"><span class=\"n\">c32</span>, </span><span class=\"param\"><span class=\"n\">c33</span>, </span><span class=\"param\"><span class=\"n\">c44</span>, </span><span class=\"param\"><span class=\"n\">c55</span>, </span><span class=\"param\"><span class=\"n\">c66</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_tetragonal", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_tetragonal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">c11</span>, </span><span class=\"param\"><span class=\"n\">c12</span>, </span><span class=\"param\"><span class=\"n\">c13</span>, </span><span class=\"param\"><span class=\"n\">c33</span>, </span><span class=\"param\"><span class=\"n\">c44</span>, </span><span class=\"param\"><span class=\"n\">c66</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_hexagonal", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_hexagonal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">c11</span>, </span><span class=\"param\"><span class=\"n\">c12</span>, </span><span class=\"param\"><span class=\"n\">c13</span>, </span><span class=\"param\"><span class=\"n\">c33</span>, </span><span class=\"param\"><span class=\"n\">c44</span>, </span><span class=\"param\"><span class=\"n\">vdim</span><span class=\"o\">=</span><span class=\"mi\">3</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_ThomsenElastic", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_ThomsenElastic", "kind": "function", "doc": "<p>Hooke tensor (m/s)^2 and density (g/cm^3)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">tem</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.to_orthorombic", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.to_orthorombic", "kind": "function", "doc": "<p>Inverse function of from_orthorombic. No reconstruction check.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.to_orthorombic2", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.to_orthorombic2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.to_tetragonal", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.to_tetragonal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.to_hexagonal", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.to_hexagonal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.is_TTI", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.is_TTI", "kind": "function", "doc": "<p>Determine if the metric is in a TTI form.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.dot_A", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.dot_A", "kind": "function", "doc": "<p>Dot product associated with a Hooke tensor, which turns a strain tensor epsilon\ninto a stress tensor sigma.</p>\n\n<p>Input:</p>\n\n<ul>\n<li>m : the strain tensor.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">sym</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.dot_AA", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.dot_AA", "kind": "function", "doc": "<p>Inner product associated with a Hooke tensor, on the space of symmetric matrices.</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>m1 : first symmetric matrix</li>\n<li>m2 : second symmetric matrix. Defaults to m1.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">m1</span>, </span><span class=\"param\"><span class=\"n\">m2</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">sym</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.Selling", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.Selling", "kind": "function", "doc": "<p>Returns a decomposition of the hooke tensor in the mathematical form\n$$\nhooke = \\sum_i \\rho_i m_i  m_i^\\top,\n$$\nwhere $\\rho_i$ is a non-negative coefficient, $m_i$ is symmetric nonzero and has \ninteger entries, and $\\sum_i \\rho_i$ is maximal.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.apply_transform", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.apply_transform", "kind": "function", "doc": "<p>Applies the transformation, if any stored, to the hooke tensor. </p>\n\n<p>CAUTION : this feature is required for some applications to elasticity, \nbut is incompatible with the eikonal equation solver.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.from_Lame", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.from_Lame", "kind": "function", "doc": "<p>Constructs a Hooke tensor from the Lame coefficients, in dimension 2 or 3.\nPositive definite provided \u03bc&gt;0 and 2\u03bc+d\u03bb&gt;0</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">\u03bb</span>, </span><span class=\"param\"><span class=\"n\">\u03bc</span>, </span><span class=\"param\"><span class=\"n\">vdim</span><span class=\"o\">=</span><span class=\"mi\">2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.contract", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.contract", "kind": "function", "doc": "<p>Returns the contracted tensor $\\sum_{j,l}c_{ijkl} w_j w_l$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">w</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.waves", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.waves", "kind": "function", "doc": "<p>Returns the pulsation and direction of the waves with the given wave vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">\u03c1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.mica", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.mica", "kind": "variable", "doc": "<p></p>\n", "default_value": "(Hooke(array([[178. ,  42.4,  14.5,   0. ,   0. ,   0. ],\n       [ 42.4, 178. ,  14.5,   0. ,   0. ,   0. ],\n       [ 14.5,  14.5,  54.9,   0. ,   0. ,   0. ],\n       [  0. ,   0. ,   0. ,  12.2,   0. ,   0. ],\n       [  0. ,   0. ,   0. ,   0. ,  12.2,   0. ],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,  67.8]]), None, 6, (), 0.0), 2.79)"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.stishovite", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.stishovite", "kind": "variable", "doc": "<p></p>\n", "default_value": "(Hooke(array([[453, 211, 203,   0,   0,   0],\n       [211, 453, 203,   0,   0,   0],\n       [203, 203, 776,   0,   0,   0],\n       [  0,   0,   0, 252,   0,   0],\n       [  0,   0,   0,   0, 252,   0],\n       [  0,   0,   0,   0,   0, 302]]), None, 6, (), 0.0), 4.29)"}, {"fullname": "agd.Metrics.Seismic.hooke.Hooke.olivine", "modulename": "agd.Metrics.Seismic.hooke", "qualname": "Hooke.olivine", "kind": "variable", "doc": "<p></p>\n", "default_value": "(Hooke(array([[323.7,  66.4,  71.6,   0. ,   0. ,   0. ],\n       [ 66.4, 197.6,  75.6,   0. ,   0. ,   0. ],\n       [ 71.6,  75.6, 235.1,   0. ,   0. ,   0. ],\n       [  0. ,   0. ,   0. ,  64.6,   0. ,   0. ],\n       [  0. ,   0. ,   0. ,   0. ,  78.7,   0. ],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,  79. ]]), None, 6, (), 0.0), 3.311)"}, {"fullname": "agd.Metrics.Seismic.implicit_base", "modulename": "agd.Metrics.Seismic.implicit_base", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase", "kind": "class", "doc": "<p>Base class for a metric defined implicitly, \nin terms of a level set function for the unit ball\nof the dual metric, and of a linear transformation.</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>niter_sqp (int, optional): number of iterations for Sequential Quadratic Programming</li>\n<li>relax_sqp (tuple,optional): relaxation parameter for the first iterations of SQP</li>\n<li>qconv_sqp (real, optional): such that hessian+quasi_sqp<em>grad^T grad &gt; 0. Used when \nthe constraint is a quasi-convex function, but exp(qconv_sqp</em>f) is strongly convex</li>\n</ul>\n", "bases": "agd.Metrics.base.Base"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.__init__", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">inverse_transformation</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">niter_sqp</span><span class=\"o\">=</span><span class=\"mi\">6</span>,</span><span class=\"param\">\t<span class=\"n\">relax_sqp</span><span class=\"o\">=</span><span class=\"p\">()</span>,</span><span class=\"param\">\t<span class=\"n\">qconv_sqp</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span>)</span>"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.inverse_transformation", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.inverse_transformation", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.niter_sqp", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.niter_sqp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.relax_sqp", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.relax_sqp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.qconv_sqp", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.qconv_sqp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.norm", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.norm", "kind": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.gradient", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.gradient", "kind": "function", "doc": "<p>Gradient of the <code>norm</code> defined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.with_cost", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.with_cost", "kind": "function", "doc": "<p>Produces a norm $N'$ obeying $N'(x) = N(cost*x)$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cost</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.inv_transform", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.inv_transform", "kind": "function", "doc": "<p>Affine transformation of the norm. \nThe new unit ball is the inverse image of the previous one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.is_topographic", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.is_topographic", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.implicit_base.ImplicitBase.flatten_transform", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "ImplicitBase.flatten_transform", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">topographic</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.implicit_base.sequential_quadratic", "modulename": "agd.Metrics.Seismic.implicit_base", "qualname": "sequential_quadratic", "kind": "function", "doc": "<p>Maximizes <x,v> subject to the constraint f(x,*params)&lt;=0, \nusing sequential quadratic programming.\nx : initial guess.\nrelax : relaxation parameters to be used in a preliminary path following phase.\nparams : to be passed to evaluated function. Special treatment if ad types.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">niter</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">params</span><span class=\"o\">=</span><span class=\"p\">()</span>, </span><span class=\"param\"><span class=\"n\">relax</span><span class=\"o\">=</span><span class=\"p\">()</span>, </span><span class=\"param\"><span class=\"n\">qconv</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data", "modulename": "agd.Metrics.Seismic.thomsen_data", "kind": "module", "doc": "<p>We reproduce in this file list of VTI examples taken from \"Weak elastic anisotropy\" (Thomsen, 1986), \nUnits are : </p>\n\n<ul>\n<li>Vp,Vs : m/s</li>\n<li>'\u03b5','\u03b7','\u03b4','\u03b3' : dimensionless. (Originally, \u03b7 is listed as \u03b4^star.)</li>\n<li>\u03c1 : g/cm^3</li>\n</ul>\n\n<p>We also provide conversion utilities</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial", "kind": "class", "doc": "<p>HexagonalMaterial(c11, c12, c13, c33, c44)</p>\n", "bases": "builtins.tuple"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial.__init__", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial.__init__", "kind": "function", "doc": "<p>Create new instance of HexagonalMaterial(c11, c12, c13, c33, c44)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c11</span>, </span><span class=\"param\"><span class=\"n\">c12</span>, </span><span class=\"param\"><span class=\"n\">c13</span>, </span><span class=\"param\"><span class=\"n\">c33</span>, </span><span class=\"param\"><span class=\"n\">c44</span></span>)</span>"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial.c11", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial.c11", "kind": "variable", "doc": "<p>Alias for field number 0</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial.c12", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial.c12", "kind": "variable", "doc": "<p>Alias for field number 1</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial.c13", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial.c13", "kind": "variable", "doc": "<p>Alias for field number 2</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial.c33", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial.c33", "kind": "variable", "doc": "<p>Alias for field number 3</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.HexagonalMaterial.c44", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "HexagonalMaterial.c44", "kind": "variable", "doc": "<p>Alias for field number 4</p>\n"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.get_\u03b4", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "get_\u03b4", "kind": "function", "doc": "<p>Reconstructs Thomsen parameter \u03b4, based on the other parameters, \nand the formula in the Thomsen paper.\n(Note : some of the published ThomsenData appears to be inconsistent in this regard.)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Vp</span>, </span><span class=\"param\"><span class=\"n\">Vs</span>, </span><span class=\"param\"><span class=\"n\">\u03b5</span>, </span><span class=\"param\"><span class=\"n\">\u03b7</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.TEM_data", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "TEM_data", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;class &#x27;agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial_data&#x27;&gt;"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial", "kind": "class", "doc": "<p>ThomsenElasticMaterial_data(Vp, Vs, \u03b5, \u03b7, \u03b4, \u03b3, \u03c1)</p>\n", "bases": "ThomsenElasticMaterial_data"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial.__init__", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial.__init__", "kind": "function", "doc": "<p>Create new instance of ThomsenElasticMaterial_data(Vp, Vs, \u03b5, \u03b7, \u03b4, \u03b3, \u03c1)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Vp</span>, </span><span class=\"param\"><span class=\"n\">Vs</span>, </span><span class=\"param\"><span class=\"n\">\u03b5</span>, </span><span class=\"param\"><span class=\"n\">\u03b7</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span>, </span><span class=\"param\"><span class=\"n\">\u03b3</span>, </span><span class=\"param\"><span class=\"n\">\u03c1</span></span>)</span>"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial.units", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial.units", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial.from_hexagonal", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial.from_hexagonal", "kind": "function", "doc": "<p>Produces the Thomsen parameters, from the coefficients 'hex' of \na Hooke tensor with hexagonal symmetry, and the density '\u03c1'.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"nb\">hex</span>, </span><span class=\"param\"><span class=\"n\">\u03c1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial.to_hexagonal", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenElasticMaterial.to_hexagonal", "kind": "function", "doc": "<p>Returns the coefficients of the reduced Hooke tensor, with hexagonal symmetry, and the density.\nUnits. Reduced hooke tensor : (m/s)^2, density : g/cm^3</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.TGM_data", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "TGM_data", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;class &#x27;agd.Metrics.Seismic.thomsen_data.ThomsenGeometricMaterial_data&#x27;&gt;"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenGeometricMaterial", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenGeometricMaterial", "kind": "class", "doc": "<p>ThomsenGeometricMaterial_data(Vp, Vs, \u03b5, \u03b4)</p>\n", "bases": "ThomsenGeometricMaterial_data"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenGeometricMaterial.__init__", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenGeometricMaterial.__init__", "kind": "function", "doc": "<p>Create new instance of ThomsenGeometricMaterial_data(Vp, Vs, \u03b5, \u03b4)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Vp</span>, </span><span class=\"param\"><span class=\"n\">Vs</span>, </span><span class=\"param\"><span class=\"n\">\u03b5</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span>)</span>"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenGeometricMaterial.units", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenGeometricMaterial.units", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenGeometricMaterial.from_c", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenGeometricMaterial.from_c", "kind": "function", "doc": "<p>Thomsen coefficients transformation (c11,c13,c33,c44) -> (Vp,Vs,\u03b5,\u03b4)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">c11</span>, </span><span class=\"param\"><span class=\"n\">c13</span>, </span><span class=\"param\"><span class=\"n\">c33</span>, </span><span class=\"param\"><span class=\"n\">c44</span>, </span><span class=\"param\"><span class=\"n\">\u03c1</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenGeometricMaterial.to_c", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenGeometricMaterial.to_c", "kind": "function", "doc": "<p>Thomsen coefficients transformation (Vp,Vs,\u03b5,\u03b4) -> (c11,c13,c33,c44)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenGeometricMaterial.from_Elastic", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenGeometricMaterial.from_Elastic", "kind": "function", "doc": "<p>Extracts the geometric coefficients (relevant for the pressure wave velocity)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">thomsenElasticMaterial</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.is_definite", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "is_definite", "kind": "function", "doc": "<p>Wether the coefficients define a positive definite hooke tensor, hence a convex inner sheet.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c11</span>, </span><span class=\"param\"><span class=\"n\">c13</span>, </span><span class=\"param\"><span class=\"n\">c33</span>, </span><span class=\"param\"><span class=\"n\">c44</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.is_separable", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "is_separable", "kind": "function", "doc": "<p>Wether the inner and outer sheets are well separated</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c11</span>, </span><span class=\"param\"><span class=\"n\">c13</span>, </span><span class=\"param\"><span class=\"n\">c33</span>, </span><span class=\"param\"><span class=\"n\">c44</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.is_second_sheet_convex", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "is_second_sheet_convex", "kind": "function", "doc": "<p>Wether the second sheet defined by the coefficients is convex.\nFormula obtained using formal computing software. \nNo proof, but checked on Thomsen's data and some examples by hand.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">c11</span>, </span><span class=\"param\"><span class=\"n\">c13</span>, </span><span class=\"param\"><span class=\"n\">c33</span>, </span><span class=\"param\"><span class=\"n\">c44</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.TEM", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "TEM", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;class &#x27;agd.Metrics.Seismic.thomsen_data.ThomsenElasticMaterial&#x27;&gt;"}, {"fullname": "agd.Metrics.Seismic.thomsen_data.ThomsenData", "modulename": "agd.Metrics.Seismic.thomsen_data", "qualname": "ThomsenData", "kind": "variable", "doc": "<p></p>\n", "default_value": "OrderedDict({&#x27;Taylor sandstone&#x27;: ThomsenElasticMaterial(Vp=3368, Vs=1829, \u03b5=0.11, \u03b7=-0.127, \u03b4=-0.035, \u03b3=0.255, \u03c1=2.5), &#x27;Mesaverde (4903) mudshale&#x27;: ThomsenElasticMaterial(Vp=4529, Vs=2703, \u03b5=0.034, \u03b7=0.25, \u03b4=0.211, \u03b3=0.046, \u03c1=2.52), &#x27;Mesaverde (4912) immature sandstone&#x27;: ThomsenElasticMaterial(Vp=4476, Vs=2814, \u03b5=0.097, \u03b7=0.051, \u03b4=0.091, \u03b3=0.051, \u03c1=2.5), &#x27;Mesaverde (4946) immature sandstone&#x27;: ThomsenElasticMaterial(Vp=4099, Vs=2346, \u03b5=0.077, \u03b7=-0.039, \u03b4=0.01, \u03b3=0.066, \u03c1=2.45), &#x27;Mesaverde (5469.5) silty sandstone&#x27;: ThomsenElasticMaterial(Vp=4972, Vs=2899, \u03b5=0.056, \u03b7=-0.041, \u03b4=-0.003, \u03b3=0.067, \u03c1=2.63), &#x27;Mesaverde (5481.3) immature sandstone&#x27;: ThomsenElasticMaterial(Vp=4349, Vs=2571, \u03b5=0.091, \u03b7=0.134, \u03b4=0.148, \u03b3=0.105, \u03c1=2.46), &#x27;Mesaverde (5501) clayshale&#x27;: ThomsenElasticMaterial(Vp=3928, Vs=2055, \u03b5=0.334, \u03b7=0.818, \u03b4=0.73, \u03b3=0.575, \u03c1=2.59), &#x27;Mesaverde (5555.5) immature sandstone&#x27;: ThomsenElasticMaterial(Vp=4539, Vs=2706, \u03b5=0.06, \u03b7=0.147, \u03b4=0.143, \u03b3=0.045, \u03c1=2.48), &#x27;Mesaverde (5566.3) laminated siltstone&#x27;: ThomsenElasticMaterial(Vp=4449, Vs=2585, \u03b5=0.091, \u03b7=0.688, \u03b4=0.565, \u03b3=0.046, \u03c1=2.57), &#x27;Mesaverde (5837.5) immature sandstone&#x27;: ThomsenElasticMaterial(Vp=4672, Vs=2833, \u03b5=0.023, \u03b7=-0.013, \u03b4=0.002, \u03b3=0.013, \u03c1=2.47), &#x27;Mesaverde (5858.6) clayshale&#x27;: ThomsenElasticMaterial(Vp=3794, Vs=2074, \u03b5=0.189, \u03b7=0.154, \u03b4=0.204, \u03b3=0.175, \u03c1=2.56), &#x27;Mesaverde (6423.6) calcareous sandstone&#x27;: ThomsenElasticMaterial(Vp=5460, Vs=3219, \u03b5=0.0, \u03b7=-0.345, \u03b4=-0.264, \u03b3=-0.007, \u03c1=2.69), &#x27;Mesaverde (6455.1) immature sandstone&#x27;: ThomsenElasticMaterial(Vp=4418, Vs=2587, \u03b5=0.053, \u03b7=0.173, \u03b4=0.158, \u03b3=0.133, \u03c1=2.45), &#x27;Mesaverde (6542.6) immature sandstone&#x27;: ThomsenElasticMaterial(Vp=4405, Vs=2542, \u03b5=0.08, \u03b7=-0.057, \u03b4=-0.003, \u03b3=0.093, \u03c1=2.51), &#x27;Mesaverde (6563.7) mudshale&#x27;: ThomsenElasticMaterial(Vp=5073, Vs=2998, \u03b5=0.01, \u03b7=0.009, \u03b4=0.012, \u03b3=-0.005, \u03c1=2.68), &#x27;Mesaverde (7888.4) sandstone&#x27;: ThomsenElasticMaterial(Vp=4869, Vs=2911, \u03b5=0.033, \u03b7=0.03, \u03b4=0.04, \u03b3=-0.019, \u03c1=2500), &#x27;Mesaverde (7939.5) mudshale&#x27;: ThomsenElasticMaterial(Vp=4296, Vs=2471, \u03b5=0.081, \u03b7=0.118, \u03b4=0.129, \u03b3=0.048, \u03c1=2.66), &#x27;Mesaverde shale (350)&#x27;: ThomsenElasticMaterial(Vp=3383, Vs=2438, \u03b5=0.065, \u03b7=-0.003, \u03b4=0.059, \u03b3=0.071, \u03c1=2.35), &#x27;Mesaverde sandstone (1582)&#x27;: ThomsenElasticMaterial(Vp=3688, Vs=2774, \u03b5=0.081, \u03b7=0.01, \u03b4=0.057, \u03b3=0.0, \u03c1=2.73), &#x27;Mesaverde shale (1599)&#x27;: ThomsenElasticMaterial(Vp=3901, Vs=2682, \u03b5=0.137, \u03b7=-0.078, \u03b4=-0.012, \u03b3=0.026, \u03c1=2.64), &#x27;Mesaverde sandstone (1958)&#x27;: ThomsenElasticMaterial(Vp=4237, Vs=3018, \u03b5=0.036, \u03b7=-0.037, \u03b4=-0.039, \u03b3=0.03, \u03c1=2.69), &#x27;Mesaverde shale (1968)&#x27;: ThomsenElasticMaterial(Vp=4846, Vs=3170, \u03b5=0.063, \u03b7=-0.031, \u03b4=0.008, \u03b3=0.028, \u03c1=2.69), &#x27;Mesaverde sandstone (3512)&#x27;: ThomsenElasticMaterial(Vp=4633, Vs=3231, \u03b5=-0.026, \u03b7=-0.004, \u03b4=-0.033, \u03b3=0.035, \u03c1=2.71), &#x27;Mesaverde shale (3511)&#x27;: ThomsenElasticMaterial(Vp=4359, Vs=3048, \u03b5=0.172, \u03b7=-0.088, \u03b4=0.0, \u03b3=0.157, \u03c1=2.81), &#x27;Mesaverde sandstone (3805)&#x27;: ThomsenElasticMaterial(Vp=3962, Vs=2926, \u03b5=0.055, \u03b7=-0.066, \u03b4=-0.089, \u03b3=0.041, \u03c1=2.87), &#x27;Mesaverde shale (3883)&#x27;: ThomsenElasticMaterial(Vp=3749, Vs=2621, \u03b5=0.128, \u03b7=-0.025, \u03b4=0.078, \u03b3=0.1, \u03c1=2.92), &#x27;Dog Creek shale&#x27;: ThomsenElasticMaterial(Vp=1875, Vs=826, \u03b5=0.225, \u03b7=-0.02, \u03b4=0.1, \u03b3=0.345, \u03c1=2.0), &#x27;Wills Point shale - 1&#x27;: ThomsenElasticMaterial(Vp=1058, Vs=387, \u03b5=0.215, \u03b7=0.359, \u03b4=0.315, \u03b3=0.28, \u03c1=1.8), &#x27;Wills Point shale - 2&#x27;: ThomsenElasticMaterial(Vp=4130, Vs=2380, \u03b5=0.085, \u03b7=0.104, \u03b4=0.12, \u03b3=0.185, \u03c1=2640), &#x27;Cotton Valley shale&#x27;: ThomsenElasticMaterial(Vp=4721, Vs=2890, \u03b5=0.135, \u03b7=0.172, \u03b4=0.205, \u03b3=0.18, \u03c1=2.64), &#x27;Pierre shale - 1&#x27;: ThomsenElasticMaterial(Vp=2074, Vs=869, \u03b5=0.11, \u03b7=0.058, \u03b4=0.09, \u03b3=0.165, \u03c1=2.25), &#x27;Pierre shale - 2&#x27;: ThomsenElasticMaterial(Vp=2106, Vs=887, \u03b5=0.195, \u03b7=0.128, \u03b4=0.175, \u03b3=0.3, \u03c1=2.25), &#x27;Pierre shale - 3&#x27;: ThomsenElasticMaterial(Vp=2202, Vs=969, \u03b5=0.015, \u03b7=0.085, \u03b4=0.06, \u03b3=0.03, \u03c1=2.25), &#x27;shale (5000) - 1&#x27;: ThomsenElasticMaterial(Vp=3048, Vs=1490, \u03b5=0.255, \u03b7=-0.27, \u03b4=-0.05, \u03b3=0.48, \u03c1=2.42), &#x27;shale (5000) - 2&#x27;: ThomsenElasticMaterial(Vp=3377, Vs=1490, \u03b5=0.2, \u03b7=-0.282, \u03b4=-0.075, \u03b3=0.51, \u03c1=2.42), &#x27;Oil Shale&#x27;: ThomsenElasticMaterial(Vp=4231, Vs=2539, \u03b5=0.2, \u03b7=0.0, \u03b4=0.1, \u03b3=0.145, \u03c1=2.37), &#x27;Green River shale - 1&#x27;: ThomsenElasticMaterial(Vp=4167, Vs=2432, \u03b5=0.04, \u03b7=-0.013, \u03b4=0.01, \u03b3=0.145, \u03c1=2.37), &#x27;Green River shale - 2&#x27;: ThomsenElasticMaterial(Vp=4404, Vs=2582, \u03b5=0.025, \u03b7=0.056, \u03b4=0.055, \u03b3=0.02, \u03c1=2.31), &#x27;Berea sandstone - 1&#x27;: ThomsenElasticMaterial(Vp=4206, Vs=2664, \u03b5=0.002, \u03b7=0.023, \u03b4=0.02, \u03b3=0.005, \u03c1=2.14), &#x27;Berea sandstone - 2&#x27;: ThomsenElasticMaterial(Vp=3810, Vs=2368, \u03b5=0.03, \u03b7=0.037, \u03b4=0.045, \u03b3=0.03, \u03c1=2.16), &#x27;Green River shale - 3&#x27;: ThomsenElasticMaterial(Vp=3292, Vs=1768, \u03b5=0.195, \u03b7=-0.45, \u03b4=-0.22, \u03b3=0.18, \u03c1=2.075), &#x27;Lance sandstone&#x27;: ThomsenElasticMaterial(Vp=5029, Vs=2987, \u03b5=-0.005, \u03b7=-0.032, \u03b4=-0.015, \u03b3=0.005, \u03c1=2.43), &#x27;Ft. Union siltstone&#x27;: ThomsenElasticMaterial(Vp=4877, Vs=2941, \u03b5=0.045, \u03b7=-0.071, \u03b4=-0.045, \u03b3=0.04, \u03c1=2.6), &#x27;Timber Mtn tuff&#x27;: ThomsenElasticMaterial(Vp=4846, Vs=1856, \u03b5=0.02, \u03b7=-0.003, \u03b4=-0.03, \u03b3=0.105, \u03c1=2.33), &#x27;Muscovite crystal&#x27;: ThomsenElasticMaterial(Vp=4420, Vs=2091, \u03b5=1.12, \u03b7=-1.23, \u03b4=-0.235, \u03b3=2.28, \u03c1=2.79), &#x27;Quartz crystal (hexag. approx.)&#x27;: ThomsenElasticMaterial(Vp=6096, Vs=4481, \u03b5=-0.096, \u03b7=0.169, \u03b4=0.273, \u03b3=-0.159, \u03c1=2.65), &#x27;Calcite crystal (hexag. approx.)&#x27;: ThomsenElasticMaterial(Vp=5334, Vs=3353, \u03b5=0.369, \u03b7=0.127, \u03b4=0.579, \u03b3=0.169, \u03c1=2.71), &#x27;Biotite crystal&#x27;: ThomsenElasticMaterial(Vp=4054, Vs=1341, \u03b5=1.222, \u03b7=-1.437, \u03b4=-0.388, \u03b3=6.12, \u03c1=3.05), &#x27;Apatite crystal&#x27;: ThomsenElasticMaterial(Vp=6340, Vs=4389, \u03b5=0.097, \u03b7=0.257, \u03b4=0.586, \u03b3=0.079, \u03c1=3.218), &#x27;Ice I crystal&#x27;: ThomsenElasticMaterial(Vp=3627, Vs=1676, \u03b5=-0.038, \u03b7=-0.1, \u03b4=-0.164, \u03b3=0.031, \u03c1=1.064), &#x27;Aluminium-lucite composite&#x27;: ThomsenElasticMaterial(Vp=2868, Vs=1350, \u03b5=0.97, \u03b7=-0.89, \u03b4=-0.09, \u03b3=1.3, \u03c1=1.86), &#x27;Sandstone-shale&#x27;: ThomsenElasticMaterial(Vp=3009, Vs=1654, \u03b5=0.013, \u03b7=-0.01, \u03b4=-0.001, \u03b3=0.035, \u03c1=2.34), &#x27;SS-anisotropic shale&#x27;: ThomsenElasticMaterial(Vp=3009, Vs=1654, \u03b5=0.059, \u03b7=-0.042, \u03b4=-0.001, \u03b3=0.163, \u03c1=2.34), &#x27;Limestone-shale&#x27;: ThomsenElasticMaterial(Vp=3306, Vs=1819, \u03b5=0.134, \u03b7=-0.094, \u03b4=0.0, \u03b3=0.156, \u03c1=2.44), &#x27;LS-anisotropic shale&#x27;: ThomsenElasticMaterial(Vp=3306, Vs=1819, \u03b5=0.169, \u03b7=-0.123, \u03b4=0.0, \u03b3=0.271, \u03c1=2.44), &#x27;Anisotropic shale&#x27;: ThomsenElasticMaterial(Vp=2745, Vs=1508, \u03b5=0.103, \u03b7=-0.073, \u03b4=-0.001, \u03b3=0.345, \u03c1=2.34), &#x27;Gas sand-water sand&#x27;: ThomsenElasticMaterial(Vp=1409, Vs=780, \u03b5=0.022, \u03b7=-0.002, \u03b4=0.018, \u03b3=0.004, \u03c1=2.03), &#x27;Gypsum-weathered material&#x27;: ThomsenElasticMaterial(Vp=1911, Vs=795, \u03b5=1.161, \u03b7=-1.075, \u03b4=-0.14, \u03b3=2.781, \u03c1=2.35)})"}, {"fullname": "agd.Metrics.Seismic.tti", "modulename": "agd.Metrics.Seismic.tti", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.tti.TTI", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI", "kind": "class", "doc": "<p>A family of reduced models, known as Tilted Transversally Anisotropic,\nand arising in seismic tomography.</p>\n\n<p>The <em>dual</em> unit ball is defined by an equation of the form\n$$\nl(X^2+Y^2,Z^2) + (1/2)*q(X^2+Y^2,Z^2) = 1,\n$$\nwhere $l$ is linear and $q$ is quadratic, where $X,Y,Z$ are the coefficients \nof the input vector, usually altered by a linear transformation.\nIn two dimensions, ignore the $Y^2$ term.</p>\n\n<p>The primal norm is obtained implicitly, by solving an optimization problem.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>linear : an array of shape (2,n1,...,nk) encoding the linear part l</li>\n<li>quadratic : an array of shape (2,2,n1,...,nk) encoding the quadratic part q</li>\n<li>vdim (optional) : the ambient space dimension</li>\n<li><em>args,</em>*kwargs (optional) : passed to implicit_base</li>\n</ul>\n", "bases": "agd.Metrics.Seismic.implicit_base.ImplicitBase"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.__init__", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">linear</span>, </span><span class=\"param\"><span class=\"n\">quadratic</span>, </span><span class=\"param\"><span class=\"n\">vdim</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.linear", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.linear", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.quadratic", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.quadratic", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.vdim", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.vdim", "kind": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.shape", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.shape", "kind": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.cost_bound", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.cost_bound", "kind": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.from_cast", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.from_cast", "kind": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">metric</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.model_HFM", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.model_HFM", "kind": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.extract_xz", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.extract_xz", "kind": "function", "doc": "<p>Extract a two dimensional Hooke tensor from a three dimensional one, \ncorresponding to a slice through the X and Z axes.\nAxes transformation information (rotation) is discarded.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.flatten", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.flatten", "kind": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">transposed_transformation</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">cp_get</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.expand", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.expand", "kind": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.from_hexagonal", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.from_hexagonal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">c11</span>, </span><span class=\"param\"><span class=\"n\">_</span>, </span><span class=\"param\"><span class=\"n\">c13</span>, </span><span class=\"param\"><span class=\"n\">c33</span>, </span><span class=\"param\"><span class=\"n\">c44</span>, </span><span class=\"param\"><span class=\"n\">vdim</span><span class=\"o\">=</span><span class=\"mi\">3</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.from_ThomsenElastic", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.from_ThomsenElastic", "kind": "function", "doc": "<p>Produces a norm from the given Thomsem elasticity parameters.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">tem</span>, </span><span class=\"param\"><span class=\"n\">vdim</span><span class=\"o\">=</span><span class=\"mi\">3</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.from_ThomsenGeometric", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.from_ThomsenGeometric", "kind": "function", "doc": "<p>Produces a norm from the given Thomsen geometric paramters.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">tgm</span>, </span><span class=\"param\"><span class=\"n\">vdim</span><span class=\"o\">=</span><span class=\"mi\">3</span>, </span><span class=\"param\"><span class=\"n\">normalize_Vp</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.\u03b1_bounds", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.\u03b1_bounds", "kind": "function", "doc": "<p>The TTI norm can be written as an enveloppe of ellipses, with eigenvalues \n(1-\u03b1,\u03b1) / \u03bc(\u03b1) or (1-\u03b1,1-\u03b1,\u03b1)/\u03bc(\u03b1), where \u03b1 is within the bounds given by this function.\nNote : another way to obtain the envelope is to use the Riemann_envelope method.</p>\n\n<p>Returns : \u03b1a,\u03b1b,mix_is_min</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.\u03bc", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.\u03bc", "kind": "function", "doc": "<p>See the method \u03b1_bounds.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">\u03b1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.Isotropic_approx", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.Isotropic_approx", "kind": "function", "doc": "<p>Isotropic approximation of the TTI norm.\nReturns : (cmin,cmax). These costs correspond to the interior and exterior approximations.\nAssumption : the linear transformation must be a rotation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.Riemann_approx", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.Riemann_approx", "kind": "function", "doc": "<p>Riemannian approximations of the TTI norm, homothetic to each other, and expectedly good.\nReturns : </p>\n\n<ul>\n<li>Mmin,Mmax. Some interior and exterior approximating Riemannian metrics.</li>\n<li>Mavg, if avg=True. A good approximating Riemannian metric, neither interior nor exterior.</li>\n<li>kwargs : passed to Riemann.dual (typical : avoid_np_linalg_inv=True, for speed)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">avg</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.Riemann_envelope", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.Riemann_envelope", "kind": "function", "doc": "<p>Approximation of a TTI norm using an envelope of Riemannian norms.</p>\n\n<ul>\n<li>nmix : number of ellipses used for the approximation.</li>\n<li>gpu : same implementation as on the GPU (changes almost nothing)\nreturns</li>\n<li>riems : a list of nmix Riemannian norms.</li>\n<li>mix_is_min : wether to take the minimum or the maximum of the Riemannian norms.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">nmix</span>, </span><span class=\"param\"><span class=\"n\">gpu</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.mica", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.mica", "kind": "variable", "doc": "<p></p>\n", "default_value": "(TTI(array([190.2,  67.1]), array([[-4343.2 , -9208.15],\n       [-9208.15, -1339.56]]), 3, None, 6, (), 0.0), 2.79)"}, {"fullname": "agd.Metrics.Seismic.tti.TTI.stishovite2", "modulename": "agd.Metrics.Seismic.tti", "qualname": "TTI.stishovite2", "kind": "variable", "doc": "<p></p>\n", "default_value": "(TTI(array([ 705, 1028]), array([[-228312., -208007.],\n       [-208007., -391104.]]), 2, None, 6, (), 0.0), 4.29)"}, {"fullname": "agd.Metrics.asym_iso", "modulename": "agd.Metrics.asym_iso", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.asym_iso.AsymIso", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso", "kind": "class", "doc": "<p>A special case of AsymQuad metric taking the form\n$\nF(x) = \\sqrt{a^2 |x|^2+sign(a) max(0,<w,x>)^2}\n$\nwhere $a$ is a field of scalars, and w a vector field.\nMember fields and __init__ arguments : </p>\n\n<ul>\n<li>a : an array of shape (n1,..,nk)</li>\n<li>w : an array of shape (vdim,n1,...,nk)</li>\n</ul>\n", "bases": "agd.Metrics.base.Base"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.__init__", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">w</span></span>)</span>"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.norm", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.norm", "kind": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.gradient", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.gradient", "kind": "function", "doc": "<p>Gradient of the <code>norm</code> defined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.dual", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.dual", "kind": "function", "doc": "<p>Dual <code>norm</code>, mathematically defined by \n$N^*(x) = max\\{ &lt; x, y> ; N(y)\\leq 1 \\}$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.vdim", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.vdim", "kind": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.shape", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.shape", "kind": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.is_definite", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.is_definite", "kind": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.anisotropy", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.anisotropy", "kind": "function", "doc": "<p>Anisotropy ratio of the <code>norm</code> denoted $N$.\nDefined as \n$$\n        \\max_{|u| = |v| = 1} \\frac {N(u)}{N(v)}.\n$$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.cost_bound", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.cost_bound", "kind": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.rotate", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.rotate", "kind": "function", "doc": "<p>Rotation of the norm, by a given rotation matrix.\nThe new unit ball is the direct image of the previous one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">r</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.with_cost", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.with_cost", "kind": "function", "doc": "<p>Produces a norm $N'$ obeying $N'(x) = N(cost*x)$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cost</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.with_costs", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.with_costs", "kind": "function", "doc": "<p>Produces a norm $N'$ defined by \n$$\nN'(x) = N(costs * x)\n$$\nwhere the multiplication is elementwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">costs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.model_HFM", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.model_HFM", "kind": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.from_cast", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.from_cast", "kind": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">metric</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_iso.AsymIso.make_proj_dual", "modulename": "agd.Metrics.asym_iso", "qualname": "AsymIso.make_proj_dual", "kind": "function", "doc": "<p>kwargs : passed to Riemann.make_proj_dual</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad", "modulename": "agd.Metrics.asym_quad", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad", "kind": "class", "doc": "<p>An asymmetric quadratic norm takes the form \n$\nF(x) = \\sqrt{&lt; x, m x &gt; + max(0,&lt; w, x &gt;)^2},\n$\nwhere $m$ is a given symmetric positive definite tensor, \nand w is a given vector.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>m : an array of shape (vdim,vdim,n1,..,nk) where vdim is the ambient space dimension.\nThe array must be symmetric, a.k.a m[i,j] = m[j,i] for all 0 &lt;= i &lt; j &lt; vdim.</li>\n<li>w : an array of shape (vdim,n1,...,nk)</li>\n</ul>\n", "bases": "agd.Metrics.base.Base"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.__init__", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">w</span></span>)</span>"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.norm", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.norm", "kind": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.gradient", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.gradient", "kind": "function", "doc": "<p>Gradient of the <code>norm</code> defined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.dual", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.dual", "kind": "function", "doc": "<p>Dual <code>norm</code>, mathematically defined by \n$N^*(x) = max\\{ &lt; x, y> ; N(y)\\leq 1 \\}$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.vdim", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.vdim", "kind": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.shape", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.shape", "kind": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.is_definite", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.is_definite", "kind": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.anisotropy", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.anisotropy", "kind": "function", "doc": "<p>Anisotropy ratio of the <code>norm</code> denoted $N$.\nDefined as \n$$\n        \\max_{|u| = |v| = 1} \\frac {N(u)}{N(v)}.\n$$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.cost_bound", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.cost_bound", "kind": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.inv_transform", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.inv_transform", "kind": "function", "doc": "<p>Affine transformation of the norm. \nThe new unit ball is the inverse image of the previous one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.with_costs", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.with_costs", "kind": "function", "doc": "<p>Produces a norm $N'$ defined by \n$$\nN'(x) = N(costs * x)\n$$\nwhere the multiplication is elementwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">costs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.flatten", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.flatten", "kind": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">solve_w</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.expand", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.expand", "kind": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.model_HFM", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.model_HFM", "kind": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.needle", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.needle", "kind": "function", "doc": "<p>Defines a needle like metric</p>\n\n<ul>\n<li>u : reference direction. Denote U = u/|u|, and V the orthogonal unit vector.</li>\n<li>cost_forward =  norm(U)</li>\n<li>cost_orthogonal = norm(V) = norm(-V)</li>\n<li>cost_reverse = norm(-U). (Defaults to cost_orthogonal)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">cost_forward</span>, </span><span class=\"param\"><span class=\"n\">cost_orthogonal</span>, </span><span class=\"param\"><span class=\"n\">cost_reverse</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.from_cast", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.from_cast", "kind": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">metric</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_quad.AsymQuad.make_proj_dual", "modulename": "agd.Metrics.asym_quad", "qualname": "AsymQuad.make_proj_dual", "kind": "function", "doc": "<p>kwargs : passed to Riemann.make_proj_dual</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_rander", "modulename": "agd.Metrics.asym_rander", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.asym_rander.AsymRander", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander", "kind": "class", "doc": "<p>Asymmetric Rander norms take the form\n$$\nF(x) = \\sqrt{<x,m x> + max(0,<u,x>)^2 + max(0,<v,x>)^2} + <w,x>\n$$\nwhere m is a given symmetric positive definite tensor, and \n$u,v,w$ are given vectors. The vector $w$ must be small enough, so that $F(x)&gt;0$ \nfor all $x\\neq 0$.</p>\n\n<p>Asymmetric Rander norms generalize both Rander norms and Asymmetric quadratic norms.\nThey were proposed by Da Chen in the context of image processing applications.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>m : an array of shape (vdim,vdim,n1,..,nk) where vdim is the ambient space dimension.\nThe array must be symmetric, a.k.a m[i,j] = m[j,i] for all 0&lt;=i<j<vdim.</li>\n<li>u,v,w : an array of shape (vdim,n1,...,nk)</li>\n</ul>\n", "bases": "agd.Metrics.base.Base"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.__init__", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">w</span></span>)</span>"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.norm", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.norm", "kind": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.vdim", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.vdim", "kind": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.shape", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.shape", "kind": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.flatten", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.flatten", "kind": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.model_HFM", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.model_HFM", "kind": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.from_cast", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.from_cast", "kind": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">metric</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.asym_rander.AsymRander.make_proj_dual", "modulename": "agd.Metrics.asym_rander", "qualname": "AsymRander.make_proj_dual", "kind": "function", "doc": "<p>Orthogonal projection onto the dual unit ball.</p>\n\n<ul>\n<li>**kwargs : passed to AsymQuad.make_proj_dual</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base", "modulename": "agd.Metrics.base", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.base.Base", "modulename": "agd.Metrics.base", "qualname": "Base", "kind": "class", "doc": "<p>Base class for a metric, in other words a family of norms.</p>\n"}, {"fullname": "agd.Metrics.base.Base.norm", "modulename": "agd.Metrics.base", "qualname": "Base.norm", "kind": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.gradient", "modulename": "agd.Metrics.base", "qualname": "Base.gradient", "kind": "function", "doc": "<p>Gradient of the <code>norm</code> defined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.dual", "modulename": "agd.Metrics.base", "qualname": "Base.dual", "kind": "function", "doc": "<p>Dual <code>norm</code>, mathematically defined by \n$N^*(x) = max\\{ &lt; x, y> ; N(y)\\leq 1 \\}$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.vdim", "modulename": "agd.Metrics.base", "qualname": "Base.vdim", "kind": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.base.Base.shape", "modulename": "agd.Metrics.base", "qualname": "Base.shape", "kind": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.base.Base.disassociate", "modulename": "agd.Metrics.base", "qualname": "Base.disassociate", "kind": "function", "doc": "<p>Hide the automatic differentiation (AD) information of the member fields.\nSee AutomaticDifferentiation.disassociate</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.is_definite", "modulename": "agd.Metrics.base", "qualname": "Base.is_definite", "kind": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.anisotropy", "modulename": "agd.Metrics.base", "qualname": "Base.anisotropy", "kind": "function", "doc": "<p>Anisotropy ratio of the <code>norm</code> denoted $N$.\nDefined as \n$$\n        \\max_{|u| = |v| = 1} \\frac {N(u)}{N(v)}.\n$$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.anisotropy_bound", "modulename": "agd.Metrics.base", "qualname": "Base.anisotropy_bound", "kind": "function", "doc": "<p>An upper bound on the <code>anisotropy</code> of the norm.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.cost_bound", "modulename": "agd.Metrics.base", "qualname": "Base.cost_bound", "kind": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.cos_asym", "modulename": "agd.Metrics.base", "qualname": "Base.cos_asym", "kind": "function", "doc": "<p>Generalized asymmetric cosine defined by the norm $N$, of the angle between two vectors $u,v$. \nDefined as \n$\\cos^a_N(u,v) := &lt; \\nabla N(u), v> / N(v)$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.cos", "modulename": "agd.Metrics.base", "qualname": "Base.cos", "kind": "function", "doc": "<p>Generalized cosine defined by the norm $N$. Expression\n$\\cos_N(u,v) := \\min( \\cos^a_N (u,v), \\cos^a_N(v,u))$,\nwhere $\\cos^a_N=$<code>cos_asym</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.angle", "modulename": "agd.Metrics.base", "qualname": "Base.angle", "kind": "function", "doc": "<p>Generalized unoriented angle defined by the norm,\ndefined as $\\measuredangle_N(u,v) := \\arccos(\\cos_N(u,v))$.\nSee <code>cos</code> member functions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.inv_transform", "modulename": "agd.Metrics.base", "qualname": "Base.inv_transform", "kind": "function", "doc": "<p>Affine transformation of the norm. \nThe new unit ball is the inverse image of the previous one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.transform", "modulename": "agd.Metrics.base", "qualname": "Base.transform", "kind": "function", "doc": "<p>Affine transformation of the norm.\nThe new unit ball is the direct image of the previous one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.rotate", "modulename": "agd.Metrics.base", "qualname": "Base.rotate", "kind": "function", "doc": "<p>Rotation of the norm, by a given rotation matrix.\nThe new unit ball is the direct image of the previous one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">r</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.rotate_by", "modulename": "agd.Metrics.base", "qualname": "Base.rotate_by", "kind": "function", "doc": "<p>Rotation of the norm, based on rotation parameters : angle (and axis in 3D).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.with_costs", "modulename": "agd.Metrics.base", "qualname": "Base.with_costs", "kind": "function", "doc": "<p>Produces a norm $N'$ defined by \n$$\nN'(x) = N(costs * x)\n$$\nwhere the multiplication is elementwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">costs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.with_speeds", "modulename": "agd.Metrics.base", "qualname": "Base.with_speeds", "kind": "function", "doc": "<p>Produces a norm $N'$ obeying \n$$\nN'(x) = N(x/speeds)\n$$ \nwhere the division is elementwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">speeds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.with_cost", "modulename": "agd.Metrics.base", "qualname": "Base.with_cost", "kind": "function", "doc": "<p>Produces a norm $N'$ obeying $N'(x) = N(cost*x)$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cost</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.with_speed", "modulename": "agd.Metrics.base", "qualname": "Base.with_speed", "kind": "function", "doc": "<p>Produces a norm $N'$ obeying $N'(x) = N(x/speed)$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">speed</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.flatten", "modulename": "agd.Metrics.base", "qualname": "Base.flatten", "kind": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.expand", "modulename": "agd.Metrics.base", "qualname": "Base.expand", "kind": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.to_HFM", "modulename": "agd.Metrics.base", "qualname": "Base.to_HFM", "kind": "function", "doc": "<p>Formats a metric for the HFM library. \nThis may include flattening some symmetric matrices, \nconcatenating with vector fields, and moving the first axis last.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.model_HFM", "modulename": "agd.Metrics.base", "qualname": "Base.model_HFM", "kind": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.from_HFM", "modulename": "agd.Metrics.base", "qualname": "Base.from_HFM", "kind": "function", "doc": "<p>Inverse of the to_HFM member function.\nTurns a suitable array into a metric.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.from_generator", "modulename": "agd.Metrics.base", "qualname": "Base.from_generator", "kind": "function", "doc": "<p>Produce a metric from a suitable generator expression.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">gen</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.from_cast", "modulename": "agd.Metrics.base", "qualname": "Base.from_cast", "kind": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">metric</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.array_float_caster", "modulename": "agd.Metrics.base", "qualname": "Base.array_float_caster", "kind": "variable", "doc": "<p>Returns a caster function, which can be used to turn lists, etc, into\narrays with the suitable floating point type, from the suitable library \n(numpy or cupy), depending on the member fields.</p>\n"}, {"fullname": "agd.Metrics.base.Base.norm2", "modulename": "agd.Metrics.base", "qualname": "Base.norm2", "kind": "function", "doc": "<p>Half square of the <code>norm</code>, defined by $F(v) := \\frac 1 2 N(v)^2$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.gradient2", "modulename": "agd.Metrics.base", "qualname": "Base.gradient2", "kind": "function", "doc": "<p>Gradient of <code>norm2</code>the half squared norm.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.set_interpolation", "modulename": "agd.Metrics.base", "qualname": "Base.set_interpolation", "kind": "function", "doc": "<p>Sets interpolation_data, required to specialize the norm \nat a given position.</p>\n\n<p>Inputs:</p>\n\n<ul>\n<li>grid. Coordinate system (required on first call).</li>\n<li>order (optional,default=1). Interpolation order. First order always preserves positivity. </li>\n<li>kwargs. Passed to UniformGridInterpolation (includes order)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">grid</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.at", "modulename": "agd.Metrics.base", "qualname": "Base.at", "kind": "function", "doc": "<p>Interpolates the metric to a given position, on a grid given beforehand.</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li>x. Place where interpolation is needed.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.make_proj_dual", "modulename": "agd.Metrics.base", "qualname": "Base.make_proj_dual", "kind": "function", "doc": "<p>Returns the orthogonal projection operator onto the unit ball of the dual metric.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.make_proj", "modulename": "agd.Metrics.base", "qualname": "Base.make_proj", "kind": "function", "doc": "<p>Returns the orthogonal projection operator onto the unit ball.</p>\n\n<ul>\n<li>**kwargs : passed to self.make_proj_dual</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.base.Base.make_prox", "modulename": "agd.Metrics.base", "qualname": "Base.make_prox", "kind": "function", "doc": "<p>Returns the proximal operator associated with the metric.\nargmin_x (1/2) |x-y|^2 + \u03c4 F(y)</p>\n\n<ul>\n<li>**kwargs : passed to self.make_proj_dual</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal", "modulename": "agd.Metrics.diagonal", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.diagonal.Diagonal", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal", "kind": "class", "doc": "<p>A Diagonal norm takes the form \n$$\nF(x) = \\sqrt{\\sum_{0\\leq i &lt; d} c_i x_i^2 },\n$$\nwhere $(c_i)_{0\\leq i &lt; d}$, are given positive scalars</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>costs : the array of $(c_i)_{0\\leq i &lt; d}$ positive numbers. Required shape : $(d,n_1,..,n_k)$ where $d=$<code>vdim</code> is the ambient space dimension.</li>\n</ul>\n", "bases": "agd.Metrics.base.Base"}, {"fullname": "agd.Metrics.diagonal.Diagonal.__init__", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">costs</span></span>)</span>"}, {"fullname": "agd.Metrics.diagonal.Diagonal.costs", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.costs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.diagonal.Diagonal.from_speed", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.from_speed", "kind": "function", "doc": "<p>Produces a metric whose costs equal 1/speeds</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">speeds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.dual", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.dual", "kind": "function", "doc": "<p>Dual <code>norm</code>, mathematically defined by \n$N^*(x) = max\\{ &lt; x, y> ; N(y)\\leq 1 \\}$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.with_costs", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.with_costs", "kind": "function", "doc": "<p>Produces a norm $N'$ defined by \n$$\nN'(x) = N(costs * x)\n$$\nwhere the multiplication is elementwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">costs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.norm", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.norm", "kind": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.is_definite", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.is_definite", "kind": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.anisotropy", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.anisotropy", "kind": "function", "doc": "<p>Anisotropy ratio of the <code>norm</code> denoted $N$.\nDefined as \n$$\n        \\max_{|u| = |v| = 1} \\frac {N(u)}{N(v)}.\n$$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.cost_bound", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.cost_bound", "kind": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.vdim", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.vdim", "kind": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.diagonal.Diagonal.shape", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.shape", "kind": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.diagonal.Diagonal.flatten", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.flatten", "kind": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.expand", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.expand", "kind": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.model_HFM", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.model_HFM", "kind": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.from_cast", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.from_cast", "kind": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">metric</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.diagonal.Diagonal.make_proj_dual", "modulename": "agd.Metrics.diagonal", "qualname": "Diagonal.make_proj_dual", "kind": "function", "doc": "<p>Returns the orthogonal projection onto the unit ball.</p>\n\n<ul>\n<li>newton_maxiter : number of iterations for the inner subproblem</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">newton_maxiter</span><span class=\"o\">=</span><span class=\"mi\">7</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic", "modulename": "agd.Metrics.isotropic", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.isotropic.Isotropic", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic", "kind": "class", "doc": "<p>An Isotropic norm takes the form \n$$\nF(x) = cost * \\sqrt{&lt; x,x>},\n$$\nwhere cost is a given positive scalar.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>cost : an array of arbirary shape (n1,..,nk).</li>\n<li>vdim (optional) : the ambient space dimension</li>\n</ul>\n", "bases": "agd.Metrics.base.Base"}, {"fullname": "agd.Metrics.isotropic.Isotropic.__init__", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cost</span>, </span><span class=\"param\"><span class=\"n\">vdim</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "agd.Metrics.isotropic.Isotropic.cost", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.cost", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.isotropic.Isotropic.from_speed", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.from_speed", "kind": "function", "doc": "<p>Produces a metric whose cost equals 1/speed.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">speed</span>, </span><span class=\"param\"><span class=\"n\">vdim</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.dual", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.dual", "kind": "function", "doc": "<p>Dual <code>norm</code>, mathematically defined by \n$N^*(x) = max\\{ &lt; x, y> ; N(y)\\leq 1 \\}$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.norm", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.norm", "kind": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.gradient", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.gradient", "kind": "function", "doc": "<p>Gradient of the <code>norm</code> defined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.is_definite", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.is_definite", "kind": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.anisotropy", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.anisotropy", "kind": "function", "doc": "<p>Anisotropy ratio of the <code>norm</code> denoted $N$.\nDefined as \n$$\n        \\max_{|u| = |v| = 1} \\frac {N(u)}{N(v)}.\n$$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.cost_bound", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.cost_bound", "kind": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.vdim", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.vdim", "kind": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.isotropic.Isotropic.shape", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.shape", "kind": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.isotropic.Isotropic.rotate", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.rotate", "kind": "function", "doc": "<p>Rotation of the norm, by a given rotation matrix.\nThe new unit ball is the direct image of the previous one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.with_cost", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.with_cost", "kind": "function", "doc": "<p>Produces a norm $N'$ obeying $N'(x) = N(cost*x)$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cost</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.with_costs", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.with_costs", "kind": "function", "doc": "<p>Produces a norm $N'$ defined by \n$$\nN'(x) = N(costs * x)\n$$\nwhere the multiplication is elementwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">costs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.flatten", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.flatten", "kind": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.expand", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.expand", "kind": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.to_HFM", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.to_HFM", "kind": "function", "doc": "<p>Formats a metric for the HFM library. \nThis may include flattening some symmetric matrices, \nconcatenating with vector fields, and moving the first axis last.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.from_HFM", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.from_HFM", "kind": "function", "doc": "<p>Inverse of the to_HFM member function.\nTurns a suitable array into a metric.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.model_HFM", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.model_HFM", "kind": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.from_cast", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.from_cast", "kind": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">metric</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.isotropic.Isotropic.make_proj_dual", "modulename": "agd.Metrics.isotropic", "qualname": "Isotropic.make_proj_dual", "kind": "function", "doc": "<p>Returns the projection operator onto the unit ball of the dual metric</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.misc", "modulename": "agd.Metrics.misc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.misc.flatten_symmetric_matrix", "modulename": "agd.Metrics.misc", "qualname": "flatten_symmetric_matrix", "kind": "function", "doc": "<p>Input : a square (symmetric) matrix.\nOutput : a vector containing the lower triangular entries</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.misc.expand_symmetric_matrix", "modulename": "agd.Metrics.misc", "qualname": "expand_symmetric_matrix", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">d</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">extra_length</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander", "modulename": "agd.Metrics.rander", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.rander.Rander", "modulename": "agd.Metrics.rander", "qualname": "Rander", "kind": "class", "doc": "<p>A Rander norm takes the form \n$$\nF(x) = \\sqrt{&lt; x,m.x>} + &lt; w,x>,\n$$\nwhere m is a given symmetric positive definite tensor, \nand w is a given vector subject to the consition $&lt; w,m^{-1} w> &lt; 1$.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>m : an array of shape (vdim,vdim,n1,..,nk) where vdim is the ambient space dimension.\nThe array must be symmetric, a.k.a m[i,j] = m[j,i] for all $0\\leq i&lt; j&lt; vdim$.</li>\n<li>w : an array of shape (vdim,n1,...,nk)</li>\n</ul>\n", "bases": "agd.Metrics.base.Base"}, {"fullname": "agd.Metrics.rander.Rander.__init__", "modulename": "agd.Metrics.rander", "qualname": "Rander.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">w</span></span>)</span>"}, {"fullname": "agd.Metrics.rander.Rander.norm", "modulename": "agd.Metrics.rander", "qualname": "Rander.norm", "kind": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.dual", "modulename": "agd.Metrics.rander", "qualname": "Rander.dual", "kind": "function", "doc": "<p>Dual <code>norm</code>, mathematically defined by \n$N^*(x) = max\\{ &lt; x, y> ; N(y)\\leq 1 \\}$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.vdim", "modulename": "agd.Metrics.rander", "qualname": "Rander.vdim", "kind": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.rander.Rander.shape", "modulename": "agd.Metrics.rander", "qualname": "Rander.shape", "kind": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.rander.Rander.is_definite", "modulename": "agd.Metrics.rander", "qualname": "Rander.is_definite", "kind": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.anisotropy_bound", "modulename": "agd.Metrics.rander", "qualname": "Rander.anisotropy_bound", "kind": "function", "doc": "<p>An upper bound on the <code>anisotropy</code> of the norm.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.cost_bound", "modulename": "agd.Metrics.rander", "qualname": "Rander.cost_bound", "kind": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.inv_transform", "modulename": "agd.Metrics.rander", "qualname": "Rander.inv_transform", "kind": "function", "doc": "<p>Affine transformation of the norm. \nThe new unit ball is the inverse image of the previous one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.with_costs", "modulename": "agd.Metrics.rander", "qualname": "Rander.with_costs", "kind": "function", "doc": "<p>Produces a norm $N'$ defined by \n$$\nN'(x) = N(costs * x)\n$$\nwhere the multiplication is elementwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">costs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.flatten", "modulename": "agd.Metrics.rander", "qualname": "Rander.flatten", "kind": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">inverse_m</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.expand", "modulename": "agd.Metrics.rander", "qualname": "Rander.expand", "kind": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.model_HFM", "modulename": "agd.Metrics.rander", "qualname": "Rander.model_HFM", "kind": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.from_cast", "modulename": "agd.Metrics.rander", "qualname": "Rander.from_cast", "kind": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">metric</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.from_Zermelo", "modulename": "agd.Metrics.rander", "qualname": "Rander.from_Zermelo", "kind": "function", "doc": "<p>Zermelo's navigation problem consists in computing a minimal path for \nwhose velocity is unit w.r.t. a Riemannian metric, and which is subject \nto a drift. The accessible velocities take the form \n        $x+drift$ where $&lt; x,m.x> \\leq 1$\nThis function reformulates it as a shortest path problem \nin a Rander manifold.</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li>metric : Symmetric positive definite matrix (Riemannian metric)</li>\n<li>drift : Vector field, obeying $&lt; drift,metric.drift> &lt; 1$ (Drift)</li>\n</ul>\n\n<p>Outputs : </p>\n\n<ul>\n<li>the Rander metric.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">metric</span>, </span><span class=\"param\"><span class=\"n\">drift</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.to_Zermelo", "modulename": "agd.Metrics.rander", "qualname": "Rander.to_Zermelo", "kind": "function", "doc": "<p>Input : Parameters of a Rander metric.</p>\n\n<p>Output : Parameters of the corresponding Zermelo problem, of motion on a \nRiemannian manifold with a drift.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.to_Varadhan", "modulename": "agd.Metrics.rander", "qualname": "Rander.to_Varadhan", "kind": "function", "doc": "<p>The Rander eikonal equation can be reformulated in an (approximate)\nlinear form, using a logarithmic transformation\n        $u + 2 eps &lt; omega,grad u> - eps**2 Tr(D hess u)$.\nThen -eps log(u) solves the Rander eikonal equation, \nup to a small additional diffusive term.</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li>m and w, parameters of the Rander metric</li>\n<li>eps (optionnal), relaxation parameter</li>\n</ul>\n\n<p>Outputs : </p>\n\n<ul>\n<li>$D$ and $2 * omega$, parameters of the linear PDE. \n($D * eps^2$ and $2 * omega * eps$ if eps is specified)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eps</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.Varadhan_from_Zermelo", "modulename": "agd.Metrics.rander", "qualname": "Rander.Varadhan_from_Zermelo", "kind": "function", "doc": "<p>Zermelo's navigation problem can be turned into a Rander shortest path problem,\nwhich itself can be (approximately) expressed in linear form using the logarithmic\ntransformation. This function composes the above two steps.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">metric</span>, </span><span class=\"param\"><span class=\"n\">drift</span>, </span><span class=\"param\"><span class=\"n\">eps</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.rander.Rander.make_proj_dual", "modulename": "agd.Metrics.rander", "qualname": "Rander.make_proj_dual", "kind": "function", "doc": "<p>kwargs : passed to Riemann.make_proj_dual</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann", "modulename": "agd.Metrics.riemann", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.riemann.Riemann", "modulename": "agd.Metrics.riemann", "qualname": "Riemann", "kind": "class", "doc": "<p>A Riemann norm takes the form \n$$\nF(x) = \\sqrt{&lt; x,m x>}, \n$$\nwhere m is a given symmetric positive definite tensor.</p>\n\n<p>Member fields and __init__ arguments : </p>\n\n<ul>\n<li>m : an array of shape $(d,d,n_1,..,n_k)$ where d=<code>vdim</code> is the ambient space dimension.\nThe array must be symmetric, a.k.a m[i,j] = m[j,i] for all $0\\leq i &lt; j &lt; d$.</li>\n</ul>\n", "bases": "agd.Metrics.base.Base"}, {"fullname": "agd.Metrics.riemann.Riemann.__init__", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span>)</span>"}, {"fullname": "agd.Metrics.riemann.Riemann.m", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.m", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.Metrics.riemann.Riemann.norm", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.norm", "kind": "function", "doc": "<p>Norm or quasi-norm defined by the class, often denoted $N$ in mathematical \nformulas. Unless incorrect data is provided, this member function obeys, \nfor all vectors $u,v\\in R^d$ and all $\\alpha \\geq 0$</p>\n\n<ul>\n<li>$N(u+v) \\leq N(u)+N(v)$</li>\n<li>$N(\\alpha u) = \\alpha N(u)$</li>\n<li>$N(u)\\geq 0$ with equality iff $u=0$.</li>\n</ul>\n\n<p>Broadcasting will occur depending on the shape of $v$ and of the class data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.gradient", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.gradient", "kind": "function", "doc": "<p>Gradient of the <code>norm</code> defined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.dual", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.dual", "kind": "function", "doc": "<p>kwargs : passed to lp.inverse (typical : avoid_np_linalg_inv=True, for speed)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.vdim", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.vdim", "kind": "variable", "doc": "<p>The ambient vector space dimension, often denoted $d$ in mathematical formulas.</p>\n"}, {"fullname": "agd.Metrics.riemann.Riemann.shape", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.shape", "kind": "variable", "doc": "<p>Dimensions of the underlying domain.\nExpected to be the empty tuple, or a tuple of length <code>vdim</code>.</p>\n"}, {"fullname": "agd.Metrics.riemann.Riemann.eigvals", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.eigvals", "kind": "function", "doc": "<p>Eigenvalues of self.m</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.is_definite", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.is_definite", "kind": "function", "doc": "<p>Attempts to check wether the data defines a mathematically valid <code>norm</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.anisotropy", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.anisotropy", "kind": "function", "doc": "<p>Anisotropy ratio of the <code>norm</code> denoted $N$.\nDefined as \n$$\n        \\max_{|u| = |v| = 1} \\frac {N(u)}{N(v)}.\n$$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.cost_bound", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.cost_bound", "kind": "function", "doc": "<p>Upper bound on $N(u)$, for any unit vector $u$, where $N$ is the <code>norm</code> \ndefined by the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.inv_transform", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.inv_transform", "kind": "function", "doc": "<p>Affine transformation of the norm. \nThe new unit ball is the inverse image of the previous one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.with_costs", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.with_costs", "kind": "function", "doc": "<p>Produces a norm $N'$ defined by \n$$\nN'(x) = N(costs * x)\n$$\nwhere the multiplication is elementwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">costs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.flatten", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.flatten", "kind": "function", "doc": "<p>Flattens and concatenate the member fields into a single array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.expand", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.expand", "kind": "function", "doc": "<p>Inverse of the flatten member function. \nTurns a suitable array into a metric.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.model_HFM", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.model_HFM", "kind": "function", "doc": "<p>The name of the 'model' for parameter, as input to the HFM library.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.needle", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.needle", "kind": "function", "doc": "<p>Defines a Riemannian metric, with </p>\n\n<ul>\n<li>eigenvector u</li>\n<li>eigenvalue cost_parallel**2 in the eigenspace spanned by u</li>\n<li>eigenvalue cost_orthogonal**2 in the eigenspace orthogonal with u</li>\n</ul>\n\n<p>The metric is </p>\n\n<ul>\n<li>needle-like if cost_parallel &lt; cost_orthogonal</li>\n<li>plate-like otherwise</li>\n</ul>\n\n<p>Optional argument:</p>\n\n<ul>\n<li>ret_u : wether to return the (normalized) vector u</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">cost_parallel</span>, </span><span class=\"param\"><span class=\"n\">cost_orthogonal</span>, </span><span class=\"param\"><span class=\"n\">ret_u</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.from_diagonal", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.from_diagonal", "kind": "function", "doc": "<p>Produces a Riemann norm whose tensors have the given diagonal.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">diag</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.from_cast", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.from_cast", "kind": "function", "doc": "<p>Produces a metric by casting another metric of a compatible type.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">metric</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.from_mapped_eigenvalues", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.from_mapped_eigenvalues", "kind": "function", "doc": "<p>Defines a Riemannian metric which has the same eigenvectors as the provided \nmatrix, but (possibly) distinct eigenvalues obtained by the provided mapping.</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li>matrix: a symmetric matrix, with shape (dim,dim,...)</li>\n<li>mapping: a function, taking as input an array of shape (dim,...),\nand returning a similarly shaped array. \nCalled with the eigenvalues of matrix, sorted from smallest to largest.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">matrix</span>, </span><span class=\"param\"><span class=\"n\">mapping</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Metrics.riemann.Riemann.make_proj_dual", "modulename": "agd.Metrics.riemann", "qualname": "Riemann.make_proj_dual", "kind": "function", "doc": "<p>kwargs : passed to Diagonal.make_proj</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE", "modulename": "agd.ODE", "kind": "module", "doc": "<p>The ODE package provides basic functionality for generating ODEs, and solving them.</p>\n\n<p>Main submodules:</p>\n\n<ul>\n<li>hamiltonian : defines classes of hamiltonians with various mathematical structures,\n(separable, quadratic, associated with a metric, ...)</li>\n<li>hamiltonian_base : contains the base class for the hamiltonians, and some symplectic \nODE solvers.</li>\n<li>backtrack : tools intended for path backtracking in time dependent optimal control</li>\n</ul>\n"}, {"fullname": "agd.ODE.backtrack", "modulename": "agd.ODE.backtrack", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.backtrack.odeint_array", "modulename": "agd.ODE.backtrack", "qualname": "odeint_array", "kind": "function", "doc": "<p>Solve an ODE where the vector field is interpolated from an array.\nThe vector field is linearly interpolated, and the Euler midpoint scheme is used.</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li>f : generator of the vector fields to be interpolated, len(next(f))=vdim</li>\n<li>y : initial value of the solution, len(y) = vdim </li>\n<li>t : time steps</li>\n<li>grid : interpolation grid for the vector field f</li>\n<li>t_delay : number of time steps to drop initially </li>\n<li>t_substeps : number of substeps</li>\n<li>order : passed to odeint_array</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">grid</span>, </span><span class=\"param\"><span class=\"n\">t_delay</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">t_substeps</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.backtrack.RecurseRewind", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind", "kind": "class", "doc": "<p>This class is designed to iterate a function, and then roll back the iterations, \nwith a limited memory usage. For that purpose appropriate keypoints are stored,\n in a multilevel manner.\n__init__ args: </p>\n\n<ul>\n<li>next : method to compute the next step.</li>\n<li>initial : initial value</li>\n<li>params : passed to next, in addition to current value</li>\n<li>base : base $b$ used to internally represent the iteration counter, which balances \na tradeoff between memory usage and computational cost. Iterating $O(b^n)$ times\n and then rewinding these iterations, has a storage cost of $O(n*b)$ and a \n computational cost of $O(n * b^n)$ function evaluations.</li>\n</ul>\n\n<p>members:</p>\n\n<ul>\n<li>reversed : wether __next__ should advance or rewind the iterations</li>\n</ul>\n"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.__init__", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"nb\">next</span>, </span><span class=\"param\"><span class=\"n\">initial</span>, </span><span class=\"param\"><span class=\"n\">params</span><span class=\"o\">=</span><span class=\"p\">()</span>, </span><span class=\"param\"><span class=\"n\">base</span><span class=\"o\">=</span><span class=\"mi\">5</span></span>)</span>"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.next", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.next", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.params", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.params", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.reversed", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.reversed", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.advance", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.advance", "kind": "function", "doc": "<p>Compute next iterate of f, and update keypoints</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.rewind", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.rewind", "kind": "function", "doc": "<p>Compute previous iterate of f, and update keypoints</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.moveto", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.moveto", "kind": "function", "doc": "<p>Compute prescribed iterate of f, and update keypoints</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.index", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.index", "kind": "variable", "doc": "<p>The index of the current iteration</p>\n"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.value", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.value", "kind": "variable", "doc": "<p>The value of the current iteration</p>\n"}, {"fullname": "agd.ODE.backtrack.RecurseRewind.base", "modulename": "agd.ODE.backtrack", "qualname": "RecurseRewind.base", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian", "modulename": "agd.ODE.hamiltonian", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian.MetricHamiltonian", "modulename": "agd.ODE.hamiltonian", "qualname": "MetricHamiltonian", "kind": "class", "doc": "<p>Hamiltonian defined by an interpolated metric, which is dualized and interpolated.\n$$\n        H(q,p) = \\frac 1 2 F^*_q(p)^2\n$$\n__init__ arguments :</p>\n\n<ul>\n<li>metric : dual defines the hamiltonian</li>\n<li>**kwargs : passed to metric.dual().set_interpolation</li>\n</ul>\n", "bases": "agd.ODE.hamiltonian_base.HamiltonianBase"}, {"fullname": "agd.ODE.hamiltonian.MetricHamiltonian.__init__", "modulename": "agd.ODE.hamiltonian", "qualname": "MetricHamiltonian.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">metric</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "agd.ODE.hamiltonian.MetricHamiltonian.H", "modulename": "agd.ODE.hamiltonian", "qualname": "MetricHamiltonian.H", "kind": "function", "doc": "<p>Evaluates the Hamiltonian, at a given position and impulsion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.MetricHamiltonian.DqH", "modulename": "agd.ODE.hamiltonian", "qualname": "MetricHamiltonian.DqH", "kind": "function", "doc": "<p>Differentiates the Hamiltonian, w.r.t. position.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.MetricHamiltonian.DpH", "modulename": "agd.ODE.hamiltonian", "qualname": "MetricHamiltonian.DpH", "kind": "function", "doc": "<p>Differentiates the Hamiltonian, w.r.t. impulsion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.GenericHamiltonian", "modulename": "agd.ODE.hamiltonian", "qualname": "GenericHamiltonian", "kind": "class", "doc": "<p>Hamiltonian defined by a arbitrary function $f$ of two variables, \nthe position $q$ and impulsion $p$, denoted\n$$\n        H(q,p)\n$$</p>\n\n<p>__init__ arguments : </p>\n\n<ul>\n<li>H : the hamiltonian, must take two arguments.</li>\n<li>shape_free (optional) : shape of position and momentum variables, used for autodiff</li>\n<li>disassociate_ad (optional) : hide AD information when calling $f$. (Use to avoid \nconflicts if the definition of $f$ itself involves automatic differentiation.)</li>\n<li>**kwargs : passed to HamiltonianBase</li>\n</ul>\n", "bases": "agd.ODE.hamiltonian_base.HamiltonianBase"}, {"fullname": "agd.ODE.hamiltonian.GenericHamiltonian.__init__", "modulename": "agd.ODE.hamiltonian", "qualname": "GenericHamiltonian.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">H</span>, </span><span class=\"param\"><span class=\"n\">shape_free</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">disassociate_ad</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "agd.ODE.hamiltonian.GenericHamiltonian.H", "modulename": "agd.ODE.hamiltonian", "qualname": "GenericHamiltonian.H", "kind": "function", "doc": "<p>Evaluates the Hamiltonian, at a given position and impulsion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.GenericHamiltonian.shape_free", "modulename": "agd.ODE.hamiltonian", "qualname": "GenericHamiltonian.shape_free", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian.GenericHamiltonian.disassociate_ad", "modulename": "agd.ODE.hamiltonian", "qualname": "GenericHamiltonian.disassociate_ad", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian.GenericHamiltonian.DqH", "modulename": "agd.ODE.hamiltonian", "qualname": "GenericHamiltonian.DqH", "kind": "function", "doc": "<p>Differentiates the Hamiltonian, w.r.t. position.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.GenericHamiltonian.DpH", "modulename": "agd.ODE.hamiltonian", "qualname": "GenericHamiltonian.DpH", "kind": "function", "doc": "<p>Differentiates the Hamiltonian, w.r.t. impulsion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonianBase", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonianBase", "kind": "class", "doc": "<p>Base class for separable Hamiltonians, with generic form : H(q,p) = H_Q(q) + H_P(p).</p>\n", "bases": "agd.ODE.hamiltonian_base.HamiltonianBase"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonianBase.DqH", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonianBase.DqH", "kind": "function", "doc": "<p>Differentiates the Hamiltonian, w.r.t. position.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">_</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonianBase.DpH", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonianBase.DpH", "kind": "function", "doc": "<p>Differentiates the Hamiltonian, w.r.t. impulsion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">_</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonianBase.Impl_p", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonianBase.Impl_p", "kind": "function", "doc": "<p>Time step for the impulsion p (implicit=explicit for a separable scheme</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonianBase.Impl_q", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonianBase.Impl_q", "kind": "function", "doc": "<p>Time step for the position q (implicit=explicit for a separable scheme)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonianBase.Impl2_p", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonianBase.Impl2_p", "kind": "function", "doc": "<p>Merge two implicit time steps for the impulsion p, with a damping step in between.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4_before</span>, </span><span class=\"param\"><span class=\"n\">\u03b4_total</span>, </span><span class=\"param\"><span class=\"n\">\u03b4_after</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonian", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonian", "kind": "class", "doc": "<p>Separable Hamiltonian defined by a pair of functions, differentiated with AD.\n$$\n        H(q,p) = H_Q(q) + H_P(p).\n$$\n__init__ arguments : </p>\n\n<ul>\n<li>Hq,Hp : the two functions $H_Q,H_P$, of a single argument, defining the hamiltonian</li>\n<li>shape_free (optional) : shape of position and momentum variables, used for autodiff</li>\n</ul>\n", "bases": "SeparableHamiltonianBase"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonian.__init__", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonian.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Hq</span>, </span><span class=\"param\"><span class=\"n\">Hp</span>, </span><span class=\"param\"><span class=\"n\">shape_free</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonian.Hq", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonian.Hq", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonian.Hp", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonian.Hp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonian.shape_free", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonian.shape_free", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian.SeparableHamiltonian.H", "modulename": "agd.ODE.hamiltonian", "qualname": "SeparableHamiltonian.H", "kind": "function", "doc": "<p>Evaluates the Hamiltonian, at a given position and impulsion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonianBase", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonianBase", "kind": "class", "doc": "<p>Base class for separable quadratic Hamiltonians. \nImplements the perturbed Hamiltonians which are preserved by the symplectic schemes.</p>\n", "bases": "SeparableHamiltonianBase"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonianBase.__init__", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonianBase.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape_free</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonianBase.shape_free", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonianBase.shape_free", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonianBase.flat", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonianBase.flat", "kind": "function", "doc": "<p>Flattens the vector x, for e.g. product with a sparse matrix</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonianBase.HEuler_p", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonianBase.HEuler_p", "kind": "function", "doc": "<p>Modified Hamiltonian, preserved by the symplectic Euler_p scheme</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonianBase.HVerlet_p", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonianBase.HVerlet_p", "kind": "function", "doc": "<p>Modified Hamiltonian, preserved by the Verlet_p symplectic scheme</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonianBase.HRuth4_p", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonianBase.HRuth4_p", "kind": "function", "doc": "<p>Modified Hamiltonian, preserved by the Ruth4_p symplectic scheme</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonianBase.H_p", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonianBase.H_p", "kind": "function", "doc": "<p>Modified Hamiltonian, preserved by the Euler_p, Verlet_p, or Ruth4_p \nsymplectic scheme, depending on the order parameter. (See method Sympl_p.)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span>, </span><span class=\"param\"><span class=\"n\">order</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonianBase.H", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonianBase.H", "kind": "function", "doc": "<p>Evaluates the Hamiltonian, at a given position and impulsion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonianBase.Impl2_p", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonianBase.Impl2_p", "kind": "function", "doc": "<p>Merge two implicit time steps for the impulsion p, with a damping step in between.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4_before</span>, </span><span class=\"param\"><span class=\"n\">\u03b4_total</span>, </span><span class=\"param\"><span class=\"n\">\u03b4_after</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonianBase.seismogram_with_backprop", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonianBase.seismogram_with_backprop", "kind": "function", "doc": "<p>Computes niter time steps of a symplectic scheme, collects the values at given indices along\nthe way (the seismogram), and allows to backpropagate the results.</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li>qh_ind,ph_ind : indices at which to collect the values of q and p, \nin the flattened arrays. IMPORTANT : no duplicate values in either qh_ind or ph_ind.</li>\n<li>kwargs : passed to Sympl_p</li>\n</ul>\n\n<p>Outputs : </p>\n\n<ul>\n<li>(qf,pf) : final values of q and p</li>\n<li>(qh,ph) : history of q and p. The prescribed indices are extracted along the way, and \nconcatenated into a \"simogram\". Last iteration is not included, use qf,pf.</li>\n<li>backprop : callable, which given (qf_coef,pf_coef) and (qh_coef,ph_coef), the gradient of\nsome objective(s) functional w.r.t the outputs, backpropagates the results to obtain the\ngradients w.r.t the Hamiltonian parameters. \nqf_coef.shape == (*qf.shape,size_ad), and likewise pf,qh,ph.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span>, </span><span class=\"param\"><span class=\"n\">niter</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">qh_ind</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ph_ind</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian", "kind": "class", "doc": "<p>Quadratic Hamiltonian, defined by a pair of linear operators.\n(Expected to be symmetric semi-definite.)\n$$\n        H(q,p) = \\frac 1 2 (&lt; q, M_Q q &gt; + &lt; p, M_P p &gt;).\n$$</p>\n\n<p>__init__ arguments : </p>\n\n<ul>\n<li>Mq,Mp : positive semi-definite matrices $M_Q,M_P$, typically given in sparse form.\nAlternatively, define Mq,Mp as functions, and use the set_spmat\nto automatically generate the sparse matrices using automatic differentiation.</li>\n</ul>\n", "bases": "QuadraticHamiltonianBase"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian.__init__", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Mq</span>, </span><span class=\"param\"><span class=\"n\">Mp</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian.Mq", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian.Mq", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian.Mp", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian.Mp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian.dMp_has", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian.dMp_has", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian.dMq_has", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian.dMq_has", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian.rev_reset", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian.rev_reset", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian.Expl_q", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian.Expl_q", "kind": "function", "doc": "<p>Explicit time step for the position q.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian.Expl_p", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian.Expl_p", "kind": "function", "doc": "<p>Explicit time step for the impulsion p.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian.QuadraticHamiltonian.set_spmat", "modulename": "agd.ODE.hamiltonian", "qualname": "QuadraticHamiltonian.set_spmat", "kind": "function", "doc": "<p>Replaces Mq,Mp with suitable sparse matrices, generated by spmat,\nif they are callables.</p>\n\n<ul>\n<li>x : Correctly shaped input for calling Mq,Mp.</li>\n<li>rev_ad (optional) : where to accumulate reverse autodiff.\nSee Eikonal.HFM_CUDA.AnisotropicWave.AcousticHamiltonian_Sparse for an example</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">rev_ad</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base", "modulename": "agd.ODE.hamiltonian_base", "kind": "module", "doc": "<p>This module implements some basic functionality for solving ODEs derived from a \nHamiltonian in a manner compatible with automatic differentiation.\n(Flow computation, symplectic schemes, etc)</p>\n\n<p>Recall that Hamilton's equations read \n$$\n\\frac {dq}{dt} = \\frac {\\partial H}{\\partial p},\n\\quad\n\\frac {dp}{dt} = - \\frac {\\partial H}{\\partial q}.\n$$</p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.fixedpoint", "modulename": "agd.ODE.hamiltonian_base", "qualname": "fixedpoint", "kind": "function", "doc": "<p>Iterates the function f on the data x until a fixed point is found, \nup to prescribed tolerance, or the maximum number of iterations is reached.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-09</span>, </span><span class=\"param\"><span class=\"n\">nitermax</span><span class=\"o\">=</span><span class=\"mi\">100</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.damp_None", "modulename": "agd.ODE.hamiltonian_base", "qualname": "damp_None", "kind": "variable", "doc": "<p></p>\n", "default_value": "0"}, {"fullname": "agd.ODE.hamiltonian_base.read_None", "modulename": "agd.ODE.hamiltonian_base", "qualname": "read_None", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">H</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.incr_None", "modulename": "agd.ODE.hamiltonian_base", "qualname": "incr_None", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">H</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase", "kind": "class", "doc": "<p>Base class for Hamiltonians.</p>\n\n<p>Default initialized fields : </p>\n\n<ul>\n<li>impl_solver : Fixed point solver to be used for the implicit time steps</li>\n<li>preserve_q, preserve_p : Wether updates modify q and p in place</li>\n<li>damp_q, damp_p : damping factor between scheme iterations</li>\n<li>read_q, read_p : called before each damping step, for reading q and p</li>\n<li>incr_q, incr_p : called after each damping step, as a source term for q and p</li>\n</ul>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.impl_solver", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.impl_solver", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.preserve_q", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.preserve_q", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.preserve_p", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.preserve_p", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.Impl2_p_merged", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.Impl2_p_merged", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.damp_q", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.damp_q", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.damp_p", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.damp_p", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.read_q", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.read_q", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.read_p", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.read_p", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.incr_q", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.incr_q", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.incr_p", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.incr_p", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.current_iter", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.current_iter", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.damp_q_nexp", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.damp_q_nexp", "kind": "function", "doc": "<p>exp(-\u03b4*damp_q)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.damp_p_nexp", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.damp_p_nexp", "kind": "function", "doc": "<p>exp(-\u03b4*damp_p)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.H", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.H", "kind": "function", "doc": "<p>Evaluates the Hamiltonian, at a given position and impulsion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.DqH", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.DqH", "kind": "function", "doc": "<p>Differentiates the Hamiltonian, w.r.t. position.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.DpH", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.DpH", "kind": "function", "doc": "<p>Differentiates the Hamiltonian, w.r.t. impulsion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.flow", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.flow", "kind": "function", "doc": "<p>Symplectic gradient of the Hamiltonian.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.flow_cat", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.flow_cat", "kind": "function", "doc": "<p>Symplectic gradient of the hamiltonian, intended for odeint. </p>\n\n<p>Input : </p>\n\n<ul>\n<li>qp : position q, impulsion p, flattened and concatenated.</li>\n<li>t : ignored parameter (compatibility with scipy.integrate.odeint)</li>\n<li>shape : how to reshape q and p for calling DpH and DqH, if needed</li>\n</ul>\n\n<p>Output :</p>\n\n<ul>\n<li>symplectic gradient, concatenated and flattened.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qp</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.integrate", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.integrate", "kind": "function", "doc": "<p>Solves Hamilton's equations by running the scheme niter times.</p>\n\n<p>Inputs : </p>\n\n<ul>\n<li>q,p : Initial position and impulsion.</li>\n<li>scheme : ODE integration scheme. (string or callable)</li>\n<li>niter,dt,T : number of steps, time step, and total time\n(exactly two among the three must be specified)</li>\n<li>path : wether to return the intermediate steps. \n(If a positive number, period of intermediate steps to return)</li>\n</ul>\n\n<p>Output : </p>\n\n<ul>\n<li>q,p if path is False. \nOtherwise np.stack([q0,...,qn],axis=-1),np.stack([p0,...,pn],axis=-1),[t0,..tn], \n      with n=niter, tn=T.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">scheme</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">dt</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">T</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.nonsymplectic_schemes", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.nonsymplectic_schemes", "kind": "function", "doc": "<p>Standard ODE integration schemes</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.Expl_q", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.Expl_q", "kind": "function", "doc": "<p>Explicit time step for the position q.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.Expl_p", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.Expl_p", "kind": "function", "doc": "<p>Explicit time step for the impulsion p.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.Damp_qp", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.Damp_qp", "kind": "function", "doc": "<p>Optional damping step, interleaved in between Verlet and Ruth4 steps, equivalent to : \np <em>= exp(-\u03b4</em>damp_p); q <em>= exp(-\u03b4</em>damp_q)\nPlease set damp_q and damp_p as appropriate.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.Impl_p", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.Impl_p", "kind": "function", "doc": "<p>Implicit time step for the impulsion p.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.Impl_q", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.Impl_q", "kind": "function", "doc": "<p>Implicit time step for the position q.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.Impl2_p", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.Impl2_p", "kind": "function", "doc": "<p>Merge two implicit time steps for the impulsion p, with a damping step in between.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4_before</span>, </span><span class=\"param\"><span class=\"n\">\u03b4_total</span>, </span><span class=\"param\"><span class=\"n\">\u03b4_after</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.Euler_p", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.Euler_p", "kind": "function", "doc": "<p>niter time steps of the symplectic Euler scheme, starting with impulsion p update.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.Euler_q", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.Euler_q", "kind": "function", "doc": "<p>niter time steps of the symplectic Euler scheme, starting with position q update.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.Verlet_p", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.Verlet_p", "kind": "function", "doc": "<p>niter time steps of the symplectic Verlet scheme.\nOptional damping steps interleaved.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.Ruth4_p", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.Ruth4_p", "kind": "function", "doc": "<p>niter time steps of the Ruth 1983 4th order symplectic scheme, as of Wikipedia.\nOptional damping steps interleaved.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.Sympl_p", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.Sympl_p", "kind": "function", "doc": "<p>niter steps of the Euler_p, Verlet_p or Ruth4_p symplectic scheme, \ndepending on the order parameter.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">\u03b4</span>, </span><span class=\"param\"><span class=\"n\">niter</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.symplectic_schemes", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.symplectic_schemes", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.hamiltonian_base.HamiltonianBase.seismogram", "modulename": "agd.ODE.hamiltonian_base", "qualname": "HamiltonianBase.seismogram", "kind": "function", "doc": "<p>Computes niter time steps of a symplectic scheme, collects the values at given indices along\nthe way (the seismogram), and allows to backpropagate the results.</p>\n\n<ul>\n<li>args,kwargs : passed to Sympl_p</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">qh_ind</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ph_ind</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.proximal", "modulename": "agd.ODE.proximal", "kind": "module", "doc": "<p>The proximal operator of a (usually convex) function $f$ is defined as \nprox_f(x0,\u03c4) := argmin_x |x-x0|^2/2 + \u03c4*f(x)\nwhich is equivalent to an implicit time step of size \u03c4 for the ODE\ndx/dt = - grad f(x).</p>\n\n<p>When f is a characteristic function, only taking the values 0 and +infty, \nprox_f is the projection onto the domain of f, independently of the value of \u03c4.</p>\n\n<p>This file provides implementations of a few proximal operators, \nand of the ADMM algorithm. A classical reference for proximal operators is : \n1.Combettes, P. L. &amp; Pesquet, J.-C. Proximal splitting methods in signal processing. \nin Fixed-point algorithms for inverse problems in science and engineering 185\u2013212 \n(Fixed-point algorithms for inverse problems in science and engineering, 2011).</p>\n"}, {"fullname": "agd.ODE.proximal.make_prox_dual", "modulename": "agd.ODE.proximal", "qualname": "make_prox_dual", "kind": "function", "doc": "<p>The proximal operator for f^*(x) = sup_y <x,y> - f(x).\n(Moreau formula)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">prox</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.proximal.chambolle_pock", "modulename": "agd.ODE.proximal", "qualname": "chambolle_pock", "kind": "function", "doc": "<p>The chambolle_pock primal-dual proximal algorithm, for solving : \ninf_x sup_y <K*x,y> + f(x) - g^*(y).\nThis algorithm is equivalent to the (linearized) ADMM, but provides explicit \ndual points, duality gap, and has a number of useful variants.\nInputs : </p>\n\n<ul>\n<li>impl_f : possibilities\n<ul>\n<li>a tuple (f,f_star,prox_f) implementing the function f, the \nLegendre-Fenchel dual f_star, and the proximal operator prox_f. (f and f_star \nare used to construct the primal and dual energies, which are involved in \nthe stopping criterion).</li>\n<li>an implementation of f, in which case E_rtol must provide E_primal_dual</li>\n</ul></li>\n</ul>\n\n<ul>\n<li>impl_gs : similar to impl_f above, but for the function g^*.</li>\n<li><p>K : possibilities</p>\n\n<ul>\n<li>a linear operator, called either as K(x) or K*x. </li>\n<li>the string 'Id'</li>\n</ul></li>\n<li><p>x : initial guess for the primal point</p></li>\n<li>y (optional, default : K(x)) : intial guess for the dual point</li>\n<li><p>KT (optional, default : K.T): transposed linear operator. </p></li>\n<li><p>E_rtol (optional) : possibilities\n    - (positive float) : algorithm stops when (E_primal-E_dual) &lt; E_rtol *abs(E_primal),\n    which is checked every 10 iterations.\n    - a tuple (callable, positive float) : the callable implements E_primal_dual(x,y) \n    (returns the pair of primal and dual energies). Same stopping criterion as above.\n    - (callable) : algorithm stops when E_rtol(niter,x,y) is True</p></li>\n<li><p>maxiter (optional) : maximum number of iterations</p></li>\n<li>\u03c1_overrelax (optional, use value in [0,2], typically 1.8): over-relaxed variant </li>\n<li>cvx_f : coercivity constant of f (used in ALG2 variant)</li>\n<li>callback (optional) : each iteration begins with callback(niter,x,y)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">impl_f</span>,</span><span class=\"param\">\t<span class=\"n\">impl_gs</span>,</span><span class=\"param\">\t<span class=\"n\">\u03c4_f</span>,</span><span class=\"param\">\t<span class=\"n\">\u03c4_gs</span>,</span><span class=\"param\">\t<span class=\"n\">K</span>,</span><span class=\"param\">\t<span class=\"n\">x</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">KT</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">E_rtol</span><span class=\"o\">=</span><span class=\"mf\">0.001</span>,</span><span class=\"param\">\t<span class=\"n\">maxiter</span><span class=\"o\">=</span><span class=\"mi\">1000</span>,</span><span class=\"param\">\t<span class=\"n\">\u03c1_overrelax</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cvx_f</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbosity</span><span class=\"o\">=</span><span class=\"mi\">2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.proximal.make_prox_multivar", "modulename": "agd.ODE.proximal", "qualname": "make_prox_multivar", "kind": "function", "doc": "<p>Defines Prox((x1,...,xn),\u03c4) := prox(x1,...,xn,\u03c4), \nor  Prox((x1,...,xn),\u03c4) := (prox1(x1,\u03c4),...,proxn(xn,\u03c4)).\nResult is cast to np.array(dtype=object)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">prox</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.proximal.impl_inmult", "modulename": "agd.ODE.proximal", "qualname": "impl_inmult", "kind": "function", "doc": "<p>Implements the Lengendre-Fenchel dual and proximal operator of F(x) := f(\u03bb*x)\nInput : </p>\n\n<ul>\n<li>impl : f,fs,prox_f</li>\n<li>\u03bb : a scalar\nOutput : </li>\n<li>F, Fs, prox_F where F(x) = f(\u03bb x)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">impl</span>, </span><span class=\"param\"><span class=\"n\">\u03bb</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.proximal.impl_exmult", "modulename": "agd.ODE.proximal", "qualname": "impl_exmult", "kind": "function", "doc": "<p>Implements the Lengendre-Fenchel dual and proximal operator of F(x) := \u03bb*f(x)\nInput : </p>\n\n<ul>\n<li>impl : f,fs,prox_f</li>\n<li>\u03bb : a scalar\nOutput : </li>\n<li>F, Fs, prox_F where F(x) = \u03bb f(x)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">impl</span>, </span><span class=\"param\"><span class=\"n\">\u03bb</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.ODE.proximal.impl_sub", "modulename": "agd.ODE.proximal", "qualname": "impl_sub", "kind": "function", "doc": "<p>Implements the Legendre-Fenchel dual and proximal operator of F(x) := F(x-x0)\nInput : </p>\n\n<ul>\n<li>impl : f,fs,prox_f</li>\n<li>x0 : the shift parameter\nOutput : </li>\n<li>F, Fs, prox_F where F(x) = f(x-x0)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">impl</span>, </span><span class=\"param\"><span class=\"n\">x0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting", "modulename": "agd.Plotting", "kind": "module", "doc": "<p>This module gathers a few helper functions for plotting data, that are used throughout the \nillustrative notebooks.</p>\n"}, {"fullname": "agd.Plotting.SetTitle3D", "modulename": "agd.Plotting", "qualname": "SetTitle3D", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">title</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting.savefig", "modulename": "agd.Plotting", "qualname": "savefig", "kind": "function", "doc": "<p>Save a figure:</p>\n\n<ul>\n<li>in a given directory, possibly set in the properties of the function. \nSilently fails if dirName is None</li>\n<li>with defaulted arguments, possibly set in the properties of the function</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fig</span>, </span><span class=\"param\"><span class=\"n\">fileName</span>, </span><span class=\"param\"><span class=\"n\">dirName</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting.open_local_or_web", "modulename": "agd.Plotting", "qualname": "open_local_or_web", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">func</span>,</span><span class=\"param\">\t<span class=\"n\">filepath</span>,</span><span class=\"param\">\t<span class=\"n\">local_prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;../&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">web_prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;https://mirebeau.github.io/AdaptiveGridDiscretizations&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">web_suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting.imread", "modulename": "agd.Plotting", "qualname": "imread", "kind": "function", "doc": "<p>Reads the image into a numpy array. Tries to find it locally and on the web.</p>\n\n<ul>\n<li><em>args,</em>*args : passed to open_local_or_web</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting.animation_curve", "modulename": "agd.Plotting", "qualname": "animation_curve", "kind": "function", "doc": "<p>Animates a sequence of curves Y[0],Y[1],... with X as horizontal axis</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">Y</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting.quiver", "modulename": "agd.Plotting", "qualname": "quiver", "kind": "function", "doc": "<p>Pyplot quiver with additional arg:</p>\n\n<ul>\n<li>subsampling (tuple or int). Subsample X,Y,U,V</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">Y</span>, </span><span class=\"param\"><span class=\"n\">U</span>, </span><span class=\"param\"><span class=\"n\">V</span>, </span><span class=\"param\"><span class=\"n\">subsampling</span><span class=\"o\">=</span><span class=\"p\">()</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting.Tissot", "modulename": "agd.Plotting", "qualname": "Tissot", "kind": "function", "doc": "<p>Display the collection of unit balls of a two dimensional metric, also known as the \nTissot indicatrix.\nInputs : </p>\n\n<ul>\n<li>metric : the metric to display</li>\n<li>X : the geometric domain</li>\n<li>n\u03b8 : number of angular directions</li>\n<li>subsampling (integer or pair of integers): only display a subset of the unit balls</li>\n<li>scale : scaling factor for the unit balls (if negative, then relative to auto scale)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">metric</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">n\u03b8</span><span class=\"o\">=</span><span class=\"mi\">100</span>, </span><span class=\"param\"><span class=\"n\">subsampling</span><span class=\"o\">=</span><span class=\"mi\">5</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=-</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting.imshow_ij", "modulename": "agd.Plotting", "qualname": "imshow_ij", "kind": "function", "doc": "<p>Show an image, using Cartesian array coordinates, \nas with the option indexing='ij' of np.mesgrid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting.arr2fig", "modulename": "agd.Plotting", "qualname": "arr2fig", "kind": "function", "doc": "<p>Create a figure displaying the given image, \nand nothing else. Uses Cartesian array coordinates.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">xsize</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting.fig2arr", "modulename": "agd.Plotting", "qualname": "fig2arr", "kind": "function", "doc": "<p>Save the figure as an array with the given shape, \nwhich must be proportional to its size. Uses Cartesian array coords.</p>\n\n<p>Approximate inverse of arr2fig.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fig</span>, </span><span class=\"param\"><span class=\"n\">shape</span>, </span><span class=\"param\"><span class=\"n\">noalpha</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting.pick_lines", "modulename": "agd.Plotting", "qualname": "pick_lines", "kind": "function", "doc": "<p>Interactively pick some (broken) lines.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"n\">inf</span>, </span><span class=\"param\"><span class=\"n\">broken</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">arrow</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting.pick_points", "modulename": "agd.Plotting", "qualname": "pick_points", "kind": "function", "doc": "<p>Interactively pick some point coordinates.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"n\">inf</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting.input_default", "modulename": "agd.Plotting", "qualname": "input_default", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">prompt</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">default</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Plotting.plotly_primal_dual_bodies", "modulename": "agd.Plotting", "qualname": "plotly_primal_dual_bodies", "kind": "function", "doc": "<p>Output : facet indices, facet measures.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">V</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Selling", "modulename": "agd.Selling", "kind": "module", "doc": "<p>This file implements Selling's algorithm in dimension $d \\in \\{2,3\\}$, which decomposes a \nsymmetric positive definite matrix $D$, of dimension $d\\leq 3$, in the form \n$$\n        D = \\sum_{0\\leq i &lt; I} a_i e_i e_i^\\top,\n$$\nwhere $a_i \\geq 0$ and $e_i\\in Z^d$ is a vector with integer coordinates, \nand where $I = d(d+2)/2$.</p>\n\n<p>Selling's decomposition is a central tool in the design of adaptive discretization schemes\nfor anisotropic partial differential equations, on Cartesian grids.</p>\n"}, {"fullname": "agd.Selling.samesize_int_t", "modulename": "agd.Selling", "qualname": "samesize_int_t", "kind": "function", "doc": "<p>Returns an integer type of the same size (32 or 64 bits) as a given float type</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">float_t</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Selling.iterMax2", "modulename": "agd.Selling", "qualname": "iterMax2", "kind": "variable", "doc": "<p></p>\n", "default_value": "100"}, {"fullname": "agd.Selling.iterMax3", "modulename": "agd.Selling", "qualname": "iterMax3", "kind": "variable", "doc": "<p></p>\n", "default_value": "100"}, {"fullname": "agd.Selling.ObtuseSuperbase", "modulename": "agd.Selling", "qualname": "ObtuseSuperbase", "kind": "function", "doc": "<p>Input : </p>\n\n<ul>\n<li>m : symmetric positive definite matrix, defined as an\narray of shape $(d,d, n_1,...,n_k)$.</li>\n<li>sb (optional) : initial guess for the obtuse superbase.</li>\n</ul>\n\n<p>Ouput : an m-obtuse superbase</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">sb</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Selling.Decomposition", "modulename": "agd.Selling", "qualname": "Decomposition", "kind": "function", "doc": "<p>Use Selling's algorithm to decompose a symmetric positive definite matrix.\nNote : results unspecified if matrices are not symmetric (includes optional AD part) \nor not positive definite.</p>\n\n<p>Input : </p>\n\n<ul>\n<li>m : symmetric positive definite matrix, defined as an\narray of shape $(d,d, n_1,...,n_k)$ where $d\\leq 3$.</li>\n<li>sb (optional) : superbase to use for the decomposition,\narray of shape $(d,d+1, n_1,...,n_k)$.\nOutput : the coefficients and offsets of the decomposition.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">sb</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Selling.GatherByOffset", "modulename": "agd.Selling", "qualname": "GatherByOffset", "kind": "function", "doc": "<p>Get the coefficient of each offset.\nThis function is essentially used to make nice plots of how the superbase coefficients\nand offsets vary as the decomposed tensor varies. Opposite offsets are regarded as identical.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">Coefs</span>, </span><span class=\"param\"><span class=\"n\">Offsets</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Selling.CanonicalSuperbase", "modulename": "agd.Selling", "qualname": "CanonicalSuperbase", "kind": "function", "doc": "<p>Returns a superbase with the same dimensions and array type as m.</p>\n\n<p>Output : </p>\n\n<ul>\n<li>m : array of shape $(d,d, n_1,...,n_k)$</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Selling.SuperbasesForConditioning", "modulename": "agd.Selling", "qualname": "SuperbasesForConditioning", "kind": "function", "doc": "<p>Returns a family of superbases. \nFor any positive definite matrix $M$ with condition number below the given bound,\none of these superbases will be $M$-obtuse.\n(Condition number is the ratio of the largest to the smallest eigenvalue.)</p>\n\n<p>Input : </p>\n\n<ul>\n<li>cond (scalar) : the bound on the condition number.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cond</span>, </span><span class=\"param\"><span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Sphere", "modulename": "agd.Sphere", "kind": "module", "doc": "<p>This module provides basic conversion utilities to manipulate low-dimensional spheres, \nand related objects : rotations, quaternions, Pauli matrices, etc</p>\n"}, {"fullname": "agd.Sphere.sphere_from_plane", "modulename": "agd.Sphere", "qualname": "sphere_from_plane", "kind": "function", "doc": "<p>Produces a point in the unit sphere by projecting a point in the equator plane.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Sphere.plane_from_sphere", "modulename": "agd.Sphere", "qualname": "plane_from_sphere", "kind": "function", "doc": "<p>Produces a point in the equator plane from a point in the unit sphere.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">q</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Sphere.rotation", "modulename": "agd.Sphere", "qualname": "rotation", "kind": "function", "doc": "<p>Dimension 2 : by a given angle.\nDimension 3 : by a given angle, along a given axis.\nThree dimensional rotation matrix, with given axis and angle.\nAdapted from <a href=\"https://stackoverflow.com/a/6802723\">https://stackoverflow.com/a/6802723</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">theta</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Sphere.rotation3_from_sphere3", "modulename": "agd.Sphere", "qualname": "rotation3_from_sphere3", "kind": "function", "doc": "<p>Produces the rotation associated with a unit quaternion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">q</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Sphere.sphere3_from_rotation3", "modulename": "agd.Sphere", "qualname": "sphere3_from_rotation3", "kind": "function", "doc": "<p>Produces the unit quaternion, with positive real part, associated with a rotation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">r</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Sphere.ball3_from_rotation3", "modulename": "agd.Sphere", "qualname": "ball3_from_rotation3", "kind": "function", "doc": "<p>Produces an euclidean point from a rotation, \nselecting in the intermediate step the quaternion \nin the same hemisphere as qRef. (Defaults to southern.)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">qRef</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Sphere.rotation3_from_ball3", "modulename": "agd.Sphere", "qualname": "rotation3_from_ball3", "kind": "function", "doc": "<p>Produces a rotation from an euclidean point. \nAlso returns the intermediate quaternion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Sphere.rotation2_from_sphere1", "modulename": "agd.Sphere", "qualname": "rotation2_from_sphere1", "kind": "function", "doc": "<p>Produces the rotation whose first column is the given unit vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">q</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Sphere.sphere1_from_rotation2", "modulename": "agd.Sphere", "qualname": "sphere1_from_rotation2", "kind": "function", "doc": "<p>Produces the unit vector which is the first column of the given rotation</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">r</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "agd.Sphere.pauli", "modulename": "agd.Sphere", "qualname": "pauli", "kind": "function", "doc": "<p>Pauli matrix. Symmetric if d is None, Hermitian otherwise.\nDeterminant is $a^2-b^2-c^2-d^2$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();